ARIA role/attribute name: ARIA: alert role

The alert role is for important, and usually time-sensitive, information. The alert is a type of status processed as an atomic live region.

Description

The alert role is used to communicate an important and usually time-sensitive message to the user. When this role is added to an element, the browser will send out an accessible alert event to assistive technology products which can then notify the user.
The alert role should only be used for information that requires the user's immediate attention, for example:

An invalid value was entered into a form field
The user's login session is about to expire
The connection to the server was lost so local changes will not be saved

The alert role should only be used for text content, not interactive elements such as links or buttons. The element with the alert role does not have to be able to receive focus, as screen readers (speech or braille) will automatically announce the updated content regardless of where keyboard focus when the role is added.
The alert role is added to the node containing an alert message, not the element causing the alert to be triggered. Alerts are assertive live regions. Setting role="alert" is equivalent to setting aria-live="assertive" and aria-atomic="true". As they don't receive focus, focus does not need to be managed and no user interaction should be required.
Warning: Because of its intrusive nature, the alert role must be used sparingly and only in situations where the user's immediate attention is required.
The alert role is of the five live region roles. Dynamic changes that are less urgent should use a less aggressive method, such as including aria-live="polite" or using an other live region role like status. If the user is expected to close the alert, then the alertdialog role should be used instead.
The most important thing to know about the alert role is that it's for content that is dynamically displayed, not for content that appears on page load. It is perfect for situations such as when a user fills out a form and JavaScript is used to add an error message - the alert would immediately read out the message. It should not be used on HTML that the user hasn't interacted with. For example, if a page loads with multiple visible alerts scattered throughout, the alert role should not be used, as the messages were not dynamically triggered.
As with all other live regions, alerts will only be announced when the content of the element with role="alert" is updated. Make sure that the element with the role is present in the page's markup first - this will "prime" the browser and screen reader to keep watching the element for changes. After this, any changes to the content will be announced. Do not try to dynamically add/generate an element with role="alert" that is already populated with the alert message you want announced - this generally does not lead to an announcement, as it is not a content change.
As the alert role reads out any content that has changed, it should be used with caution. Alerts, by definition, are disruptive. Several alerts at once, and unnecessary alerts, create bad user experiences.
Examples

The following are common examples of alerts and how to implement them:

Example 1: Making ready-made content inside an element with an alert role visible

If the content inside the element with role="alert" is initially hidden using CSS, making it visible will cause the alert to fire. This means that an existing alert container element can be "reused" multiple times.
CSS
Copy to Clipboard
.hidden {
  display: none;
}

HTML
Copy to Clipboard
<div id="expirationWarning" role="alert">
  <span class="hidden">Your log in session will expire in 2 minutes</span>
</div>

JS
Copy to Clipboard
// removing the 'hidden' class makes the content inside the element visible, which will make the screen reader announce the alert:
document
  .getElementById("expirationWarning")
  .firstChild.classList.remove("hidden");

Example 2: Dynamically changing the content inside an element with an alert role

Using JavaScript, you can dynamically change the content inside the element with role="alert". Note that if you need to fire the same alert multiple times (i.e. the content you're dynamically inserting is the same as before), this generally won't be seen as a change and will not lead to an announcement. For this reason, it's usually best to briefly "clear" the contents of the alert container before then injecting the alert message.
HTML
Copy to Clipboard
<div id="alertContainer" role="alert"></div>

JS
Copy to Clipboard
// clear the contents of the container
document.getElementById("alertContainer").textContent = "";
// inject the new alert message
document.getElementById("alertContainer").textContent =
  "Your session will expire in " + expiration + " minutes";

Example 3: Visually hidden alert container for screen reader notifications

It's possible to visually hide the alert container itself, and use it to provide updates/notifications explicitly for screen readers. This can be useful in situations where important content on the page has been updated, but where the change would not be immediately obvious to a screen-reader user.
However, make sure that the container is not hidden using display:none, as this will hide it even from assistive technologies, meaning that they won't be notified of any changes. Instead, use something like the .visually-hidden styles.
HTML
Copy to Clipboard
<div id="hiddenAlertContainer" role="alert" class="visually-hidden"></div>

CSS
Copy to Clipboard
.visually-hidden {
  clip: rect(0 0 0 0);
  clip-path: inset(50%);
  height: 1px;
  overflow: hidden;
  position: absolute;
  white-space: nowrap;
  width: 1px;
}

JS
Copy to Clipboard
// clear the contents of the container
document.getElementById("hiddenAlertContainer").textContent = "";
// inject the new alert message
document.getElementById("hiddenAlertContainer").textContent =
  "All items were removed from your inventory.";


--------------------------------------------------

ARIA role/attribute name: ARIA: alertdialog role

The alertdialog role is to be used on modal alert dialogs that interrupt a user's workflow to communicate an important message and require a response.

Description

The alertdialog role is used to notify users of urgent information that demands the user's immediate attention. Including role="alertdialog" on the element containing the dialog helps assistive technology identify the content as being grouped and separated from the rest of the page content. Examples include error messages that require confirmation and other action confirmation prompts.
As the name implies, alertdialog is a mashup of the dialog and alert roles. alertdialog is a type of dialog with similar use cases as alert, but for when a user response is required.
Note: The alertdialog role should only be used for alert messages that have associated interactive controls. If an alert dialog only contains static content and has no interactive controls at all, use alert instead.
Being a type of dialog, the dialog role's states, properties, and keyboard focus requirements are applicable to the alertdialog role as well.
Because of its urgent nature, interrupting the user's workflow, alert dialogs should be modal.
The alert dialog must have at least one focusable control — such as Confirm, Close, and Cancel — and focus must be moved to that control when the alert dialog appears. Alert dialogs can have additional interactive controls such as text fields and checkboxes.
The alertdialog role is not to be used as a replacement for other dialogs, including no-confirmation-required alert dialogs (Window.alert()) and prompts (Window.prompt()).
Adding role="alertdialog" alone is not sufficient to make an alert dialog accessible. The following also need to be done:

The alert dialog must be properly labeled
Keyboard focus must be managed correctly

The alertdialog must have an accessible name, defined with aria-labelledby or aria-label. The alert dialog text must have an accessible description using aria-describedby.
Examples

Example 1: A basic alert dialog
HTML
Copy to Clipboard
<div
  role="alertdialog"
  aria-labelledby="dialog1Title"
  aria-describedby="dialog1Desc">
  <div role="document" tabindex="0">
    <h2 id="dialog1Title">Your login session is about to expire</h2>
    <p id="dialog1Desc">To extend your session, click the OK button</p>
    <button>OK</button>
  </div>
</div>


The code snippet above shows how to mark up an alert dialog that only provides a message and an OK button.
Example 2: Confirmation dialog with two options
HTML
Copy to Clipboard
<div
  id="alert_dialog"
  role="alertdialog"
  aria-modal="true"
  aria-labelledby="dialog_label"
  aria-describedby="dialog_desc">
  <h2 id="dialog_label">Confirmation</h2>
  <div id="dialog_desc">
    <p>Are you sure you want to delete this image?</p>
    <p>This change can't be undone.</p>
  </div>
  <ul>
    <li>
      <button type="button" onclick="closeThis()">No</button>
    </li>
    <li>
      <button
        type="button"
        aria-controls="form"
        id="delete_file_confirm"
        onclick="deleteFile()">
        Yes
      </button>
    </li>
  </ul>
</div>

Associated WAI-ARIA roles, states, and properties
aria-labelledby

Use this attribute to label the alertdialog. The aria-labelledby attribute is generally the id of the element used to title the alertdialog.
aria-describedby

Use this attribute to encompass the description of the contents of the alert dialog. The value of the aria-describedby attribute is generally the ID of the element containing the alert dialog's messaging, usually coming right after the title.

--------------------------------------------------

ARIA role/attribute name: ARIA: application role

The application role indicates to assistive technologies that an element and all of its children should be treated similar to a desktop application, and no traditional HTML interpretation techniques should be used. This role should only be used to define very dynamic and desktop-like web applications. Most mobile and desktop web apps are not considered applications for this purpose.

HTML
Copy to Clipboard
<div role="application" aria-label="…">…</div>


By specifying the application role, it indicates this div element and all of its descendants are to be treated like they are part of a desktop application.

Description

The application document structure role, indicates to assistive technologies that this part of the web content contains elements that do not conform to any other known HTML element or WAI-ARIA widget. Any sort of special interpretation of HTML structures and widgets should be suspended, and control should be completely handed over to the browser and web application to handle mouse, keyboard, or touch interaction.
In this mode, the web author is completely responsible for handling any and all keyboard input, focus management, and other interactions and cannot assume assistive technologies would do any processing on their end.
If the web application encompassed by the application role contains parts that should be treated like normal web content, a role of document or article should be used to contain such content.
Background

For historic reasons, especially on Windows, screen readers and some other assistive technologies (AT) have traditionally grabbed the whole web content from the browser at once after it had finished loading. The ATs build their own representation of it that makes the most sense for a visually impaired user to consume the content. This is often referred to as virtual document, browse mode, or similar terms. The document is streamlined to a single-column view. A keyboard interaction model is generated that is very similar to a word processor where users can read line by line, sentence by sentence, or paragraph by paragraph. The AT will read any semantics like links, headings, form controls, tables, lists, or images.
In addition, a set of so-called quick navigation keys has been established over the years that allows visually impaired users to skim through a page via a certain element type. Such elements usually include headings, form fields, lists, tables, links, graphics, or landmark regions.
For all of this to work, ATs intercept almost all keyboard input and consume it themselves, letting nothing through to the browser or other user agent. To be able to interact with a web page, a standard set of widgets is recognized that, when pressing a certain key (usually the Enter key) this mode is switched off. The screen reader mode, often called forms mode or focus mode, lets all keyboard input go through to the browser again. Escape is the most common way of switching back to browse mode, but when within a specific application section, some screen readers may require other keys to purposefully exit this mode. For instance NUMPAD PLUS with JAWS.
The application role is designed to provide a means for widgets that are not part of the standard set to be accessible for direct interaction in ATs that use both browse and focus modes for interacting with web content. Most common widgets have expected keyboard interaction behaviors. Because of this, a custom keyboard experience created by a web author would create a confusing experience.
Associated WAI-ARIA roles, states, and properties
document, article

Used to indicate parts of the application that should be treated as normal web content

aria-activedescendant

Used to manage focus inside the application.
aria-label

Used to provide the name of the application or purpose of the widget that is being exposed.
aria-describedby

Used to indicate the idref of an element that contains additional instructions for navigating or operating this element.
aria-roledescription

Used to give the application a more descriptive role text for screen readers to speak. This should be localized.
aria-disabled

Indicates that an element is visible but disabled

aria-errormessage

A reference to the element that provides the error message for the element on which it is set

aria-expanded

If set to true, the grouping element owned or controlled by this element is expanded, or false if collapsed.
aria-haspopup

Indicates there is a popup, such as menu or dialog, that can be triggered by the element.
Keyboard interactions

Keyboard interaction is completely under the web author's control and can be anything associated with the particular widget being implemented. In a slides application, for example, a widget could be created that uses the arrow keys to position elements on the slide, and uses audio feedback via an ARIA live region to communicate the position and overlap status with other objects. Focus is being managed via aria-activedescendant.
The Tab, Space and Enter keys, as well as Escape, must be handled by the application. The one exception is if focus is set to a standard widget inside the application that supports keyboard navigation from the browser, for example an input element.
Required JavaScript features
keyPress

Used to handle keyboard input and control the focus

Click, Touch

Handle as appropriate for your widget as well

Changing attribute values

aria-activedescendant is used to manage the focus inside the application container. Set in response to keyboard or other application events that change focus or point of interaction.
Note: The application role does not have a related HTML widget and thus is completely free form. The author of the application must take full responsibility for not letting users get stuck in a focus trap inside something the user cannot exit from. All aspects of interaction, including returning to the regular web content on other parts of the page, must be handled. Use wisely, and cautiously, and remember to test!

Examples

Some prominent web applications that use or have used the application role properly are:

Google Docs, Sheets and Slides
CKEditor and TinyMCE WYSIWYG web editors, like the one used on the Mozilla Developer Network
Some parts of Gmail

Accessibility concerns

Improperly using the application role can unintentionally take away access from information on a web page, so be very mindful of using it. Think hard on if you actually need it and cannot just use a set of other known widgets to accomplish the same task.
If used, the application role should be added to the lowest common container possible, not on the <body> element, for example. Also be sure to test what you have written with assistive technology, to verify it works as intended.
Precedence order

Applying the application role will cause this and all of the descendant elements of this element to be treated like application content, not web content. Any reading mechanisms assistive technologies may have for web content will not apply.

--------------------------------------------------

ARIA role/attribute name: ARIA: article role

The article role indicates a section of a page that could easily stand on its own on a page, in a document, or on a website. It is usually set on related content items such as comments, forum posts, newspaper articles or other items grouped together on one page.

HTML
Copy to Clipboard
<div role="article">
  <h2>Heading of the segment</h2>
  <p>Paragraph for the segment.</p>
  <p>Another paragraph.</p>
  Controls to interact with the article, share it, etc.
</div>
<div role="article">…</div>


This example shows two articles side by side on one page that could be structured similarly and are related.

Note: Instead of a <div> with an article role, use the <article> element. Always use native element if available

Don't use role="article". Instead use the <article> element.

HTML
Copy to Clipboard
<article>
  <h2>Heading of the segment</h2>
  <p>Paragraph for the segment.</p>
  <p>Another paragraph.</p>
  Controls to interact with the article, share it, etc.
</article>
<article>…</article>

Description

The article document structure role denotes a section of a document, page, or site that, if it were standing on its own, could be viewed as a complete document, page or site. The aim of a set of article sections is to indicate their relationship to one another.
Articles are not considered a navigational landmark, but many assistive technologies that support landmarks also support a means to navigate among articles. They may also support indication of nesting relationships within articles.
Articles can be nested, indicating that a nested article directly relates to the one it is nested in, but not necessarily to the ones outside the nesting hierarchy. Reference the examples for specific use cases.
If an article is part of a feed, it can have the aria-posinset and aria-setsize attributes set to indicate which position within the feed this particular article represents.
Inside an application or other widget that causes screen readers and other assistive technologies to be in pass-through mode, an article can be used to indicate that these should switch back to treating the enclosed content as regular web content.
Instead of including the article role on a non-semantic element, the <article> element should be used. User agents translate this to the appropriate accessibility information just like the article role. Using the <article> element also helps search engines better discover the structure of a page. Examples of appropriate uses of the role="article", or preferably <article>, include blog posts, forum posts, a comment to a forum or blog post, any an item in a social media feed.
Associated WAI-ARIA roles, states, and properties
aria-posinset

In the context of a feed, indicates the position of this particular article within that feed, based on a count starting at 1.
aria-setsize

In the context of a feed, indicates how many article items there are within that feed.
Keyboard interactions

This role does not support any specific keyboard interaction.
Required JavaScript features
Event handlers

This role does not require any event handlers to be present.
Changing attribute values

When constructing a feed, set the aria-posinset and aria-setsize attributes on each article role to the appropriate values, bearing in mind that aria-posinset is 1-based.
Note: Always use native element if available. Instead of a <div> with the article role, the <article> element should be used.
Examples
The restaurant recommendations feed display along with its separate documentation from the WAI-ARIA 1.1 authoring practices feed design pattern

Precedence order

This role corresponds to the <article> element in HTML, and that element should be used instead, if possible. This role does not require any specific roles to be present among its children. It is the only role allowed as a direct child of an element with the feed role.

--------------------------------------------------

ARIA role/attribute name: ARIA: banner role

The banner role is for defining a global site header, which usually includes a logo, company name, search feature, and possibly the global navigation or a slogan. It is generally located at the top of the page.

By default, the HTML's <header> element has an identical meaning to the banner landmark, unless it is a descendant of <aside>, <article>, <main>, <nav>, or <section>, at which point <header> exposes a generic role, and not the equivalent of the site-wide banner.

Description

A banner landmark role overwrites the implicit ARIA role of the container element upon which it is applied. It should be reserved for globally repeating site-wide content that is generally located at the top of every page.
The banner typically includes things such as a logo or corporate identity, or possibly a site-specific search tool, and is generally what your marketing team would call the "header" or "top banner" of the site. If the header element technique is not being used for that banner, a declaration of role="banner" should be used to define a banner landmark to assistive technologies.
Assistive technologies can identify the header element of a page as the banner if it is a descendant of the body element, and not nested within an article, aside, main, nav or section subsection.
Each page may have a banner landmark, but each page should generally be limited to a single element with the role of banner. In the case of a page containing nested document and/or application roles, each nested document or application role may also have one banner landmark. If a page includes more than one banner landmark, each should have a unique accessible name.
Associated ARIA roles, states, and properties

None

Keyboard interactions

None

Required JavaScript features

None

Examples

Here's a fake simple banner with a skip to navigation link, a logo, a title and a subtitle. As this is the main header for the site, we've added the banner landmark role to the container element.
HTML
Copy to Clipboard
<div role="banner">
  <a href="#main" id="skipToMain" class="skiptocontent">Skip To main content</a>
  <img src="images/w3c.png" alt="W3C Logo" />
  <h1>ARIA Landmarks</h1>
  <p>Identifying page subsections for easy navigation</p>
  <nav>…</nav>
</div>


We could also have written the above with the HTML header element:

HTML
Copy to Clipboard
<header>
  <a href="#main" id="skipToMain" class="skiptocontent">Skip To main content</a>
  <img src="images/w3c.png" alt="W3C Logo" />
  <h1>ARIA Landmarks</h1>
  <p>Identifying page subsections for easy navigation</p>
  <nav>…</nav>
</header>

Best practices

While it is best to use the header element and ensure it is not a descendant of any subsection of the page, sometimes you don't have access to the underlying HTML. If this is the case, you can add the role of banner to the element of the page which should be exposed as a banner with JavaScript. Identifying the page's banner in this way will help improve the site's accessibility.

--------------------------------------------------

ARIA role/attribute name: ARIA: button role

The button role is for clickable elements that trigger a response when activated by the user. Adding role="button" tells the screen reader the element is a button, but provides no button functionality. Use <button> or <input> with type="button" instead.

Description

The button role identifies an element as a button to assistive technology such as screen readers. A button is a widget used to perform actions such as submitting a form, opening a dialog, canceling an action, or performing a command such as inserting a new record or displaying information. Adding role="button" tells assistive technology that the element is a button but provides no button functionality. Use <button> or <input> with type="button" instead.
This button role can be used in combination with the aria-pressed attribute to create toggle buttons.
HTML
Copy to Clipboard
<div id="saveChanges" tabindex="0" role="button" aria-pressed="false">Save</div>


The above example creates a focusable button, but requires JavaScript and CSS to include button appearance and functionality. These are features provided by default when using the <button> and <input> with type="button" elements:

HTML
Copy to Clipboard
<button type="button" id="saveChanges">Save</button>


Note: If using role="button" instead of the semantic <button> or <input type="button"> elements, you will need to make the element focusable and define event handlers for click and keydown events. This includes handling the Enter and Space keypresses in order to process all forms of user input. See the official WAI-ARIA example code.
In addition to the ordinary button widget, role="button" should be included when creating a toggle button or menu button using a non-button element.
A toggle button is a two-state button that can be either off (not pressed) or on (pressed). The aria-pressed attribute values of true or false identify a button as a toggle button.
A menu button is a button that controls a menu and has an aria-haspopup property attribute set to either menu or true.
All descendants are presentational

There are some types of user interface components that, when represented in a platform accessibility API, can only contain text. Accessibility APIs do not have a way of representing semantic elements contained in a button. To deal with this limitation, browsers, automatically apply role presentation to all descendant elements of any button element as it is a role that does not support semantic children.
For example, consider the following button element, which contains a heading.
HTML
Copy to Clipboard
<div role="button"><h3>Title of my button</h3></div>


Because descendants of button are presentational, the following code is equivalent:

HTML
Copy to Clipboard
<div role="button"><h3 role="presentation">Title of my button</h3></div>


From the assistive technology user's perspective, the heading does not exist since the previous code snippets are equivalent to the following in the accessibility tree:

HTML
Copy to Clipboard
<div role="button">Title of my button</div>

Associated ARIA roles, states, and properties
aria-pressed

The aria-pressed attribute defines the button as a toggle button. The value describes the state of the button. The values include aria-pressed="false" when a button is not currently pressed, aria-pressed="true" to indicate a button is currently pressed, and aria-pressed="mixed" if the button is considered to be partially pressed. If the attribute is omitted or set to its default value of aria-pressed="undefined", the element does not support being pressed.
aria-expanded

If the button controls a grouping of other elements, the aria-expanded state indicates whether the controlled grouping is currently expanded or collapsed. If the button has aria-expanded="false" set, the grouping is not currently expanded; If the button has aria-expanded="true" set, it is currently expanded; if the button has aria-expanded="undefined" set or the attribute is omitted, it is not expandable.
Basic buttons

Buttons should always have an accessible name. For most buttons, this name will be the same as the text inside the button, between the opening and closing tags. In some cases, for example buttons represented by icons, the accessible name may be provided from the aria-label or aria-labelledby attributes.
Toggle buttons

A toggle button typically has two states: pressed and not pressed. A third mixed state is available for toggle buttons that control other elements, such as other toggle buttons or checkboxes, which do not all share the same value. Whether an element is a toggle button or not can be indicated with the aria-pressed attribute in addition to the button role (if the element is not already a native button element):

If aria-pressed is not used, or is set to the "undefined" state, the button is not a toggle button.
If aria-pressed="false" is used the button is a toggle button that is currently not pressed.
If aria-pressed="true" is used the button is a toggle button that is currently pressed.
if aria-pressed="mixed" is used, the button is considered to be partially pressed.
As an example, the mute button on an audio player labeled "mute" could indicate that sound is muted by setting the aria-pressed state true. The label of a toggle button should not change when its state changes. In our example the label remains "Mute" with a screen reader reading "Mute toggle button pressed" or "Mute toggle button not pressed" depending on the value of aria-pressed. If the design were to call for the button label to change from "Mute" to "Unmute," a toggle button would not be appropriate, so the aria-pressed attribute would be omitted.
Keyboard interactions
Key	Function
Enter	Activates the button.
Space	Activates the button

Following button activation, focus is set depending on the type of action the button performs. For example, if clicking the button opens a dialog, the focus should move to the dialog. If the button closes a dialog, focus should return to the button that opened the dialog unless the function performed in the dialog context logically leads to a different element. If the button alters the current context, such as muting and unmuting an audio file, then focus typically remains on the button.
Required JavaScript Features
Required event handlers

Buttons can be operated by mouse, touch, and keyboard users. For native HTML <button> elements, the button's onclick event fires for mouse clicks and when the user presses Space or Enter while the button has focus. But if another tag is used to create a button, the onclick event only fires when clicked by the mouse cursor, even if role="button" is used. Because of this, separate key event handlers must be added to the element so that the button is be triggered when the Space or Enter key is pressed.
onclick

Handles the event raised when the button is activated using a mouse click or touch event.
onKeyDown

Handles the event raised when the button is activated using the Enter or Space key on the keyboard. (Note not the deprecated onKeyPress)

Examples

Basic button example

In this example, a span element has been given the button role. Because a <span> element is used, the tabindex attribute is required to make the button focusable and part of the page's tab order. The included CSS style is provided to make the <span> element look like a button, and to provide visual cues when the button has focus.
The handleBtnClick and handleBtnKeyDown event handlers perform the button's action when activated using a mouse click or the Space or Enter key. In this case, the action is to add a new name to the list of names.
Try the example by adding a name to the text box. The button will cause the name to be added to a list.
HTML
HTML
Copy to Clipboard
Play
<h1>ARIA Button Example</h1>
<ul id="nameList"></ul>
<label for="newName">Enter your Name: </label>
<input type="text" id="newName" />
<span
  role="button"
  tabindex="0"
  onclick="handleCommand(event)"
  onKeyDown="handleCommand(event)"
  >Add Name</span
>

CSS
CSS
Copy to Clipboard
Play
[role="button"] {
  padding: 2px;
  background-color: navy;
  color: white;
  cursor: default;
}
[role="button"]:hover,
[role="button"]:focus,
[role="button"]:active {
  background-color: white;
  color: navy;
}
ul {
  list-style: none;
}

JavaScript
JS
Copy to Clipboard
Play
function handleCommand(event) {
  // Handles both mouse clicks and keyboard
  // activate with Enter or Space

  // Keypresses other than Enter and Space should not trigger a command
  if (
    event instanceof KeyboardEvent &&
    event.key !== "Enter" &&
    event.key !== " "
  ) {
    return;
  }

  // Get the new name value from the input element
  const newNameInput = document.getElementById("newName");
  const name = newNameInput.value;
  newNameInput.value = ""; // clear the text field
  newNameInput.focus(); // give the text field focus to enable entering and additional name.
  // Don't add blank entries to the list.
  if (name.length > 0) {
    const listItem = document.createElement("li");
    listItem.appendChild(document.createTextNode(name));

    // Add the new name to the list.
    const list = document.getElementById("nameList");
    list.appendChild(listItem);
  }
}

Play

Toggle button example

In this snippet a <span> element is converted to a toggle button using the button role and the aria-pressed attribute. When the button is activated, the aria-pressed value switches states; changing from true to false and back again.
HTML
HTML
Copy to Clipboard
Play
<button
  type="button"
  onclick="handleBtnClick(event)"
  onKeyDown="handleBtnKeyDown(event)">
  Mute Audio
</button>

<span
  role="button"
  tabindex="0"
  aria-pressed="false"
  onclick="handleBtnClick(event)"
  onKeyDown="handleBtnKeyDown(event)">
  Mute Audio
</span>

<audio
  id="audio"
  src="https://soundbible.com/mp3/Tyrannosaurus%20Rex%20Roar-SoundBible.com-807702404.mp3">
  Your browser does not support the `audio` element.
</audio>

CSS
CSS
Copy to Clipboard
Play
button,
[role="button"] {
  padding: 3px;
  border: 2px solid transparent;
}

button:active,
button:focus,
[role="button"][aria-pressed="true"] {
  border: 2px solid #000;
}

JavaScript
JS
Copy to Clipboard
Play
function handleBtnClick(event) {
  toggleButton(event.target);
}

function handleBtnKeyDown(event) {
  // Check to see if space or enter were pressed
  // "Spacebar" for IE11 support
  if (event.key === " " || event.key === "Enter" || event.key === "Spacebar") {
    // Prevent the default action to stop scrolling when space is pressed
    event.preventDefault();
    toggleButton(event.target);
  }
}

function toggleButton(element) {
  const audio = document.getElementById("audio");

  // Check to see if the button is pressed
  const pressed = element.getAttribute("aria-pressed") === "true";

  // Change aria-pressed to the opposite state
  element.setAttribute("aria-pressed", !pressed);

  // Toggle the play state of the audio file
  if (pressed) {
    audio.pause();
  } else {
    audio.play();
  }
}

Result
Play

Accessibility concerns

Buttons are interactive controls and thus focusable. If the button role is added to an element that is not focusable by itself (such as <span>, <div> or <p>) then, the tabindex attribute has to be used to make the button focusable.
Warning: Be careful when marking up links with the button role. Buttons are expected to be triggered using the Space or Enter key, while links are expected to be triggered using the Enter key. In other words, when links are used to behave like buttons, adding role="button" alone is not sufficient. It will also be necessary to add a key event handler that listens for the Space key in order to be consistent with native buttons.
When the button role is used, screen readers announce the element as a button, generally saying "click" followed by the button's accessible name. The accessible name is either the content of the element or the value of an aria-label or element referenced by an aria-labelledby attribute, or description, if included.
Best practices

If a link performs the action of a button, giving the element role="button" helps assistive technology users understand the function of the element. However, a better solution is to adjust the visual design so it matches the function and ARIA role. Where possible, it is recommended to use native HTML buttons (<button>, <input type="button">, <input type="submit">, <input type="reset"> and <input type="image">) rather than the button role, as native HTML buttons are supported by all user agents and assistive technology and provide keyboard and focus requirements by default, without need for additional customization.

--------------------------------------------------

ARIA role/attribute name: ARIA: cell role

The cell value of the ARIA role attribute identifies an element as being a cell in a tabular container that does not contain column or row header information. To be supported, the cell must be nested in an element with the role of row.

HTML
Copy to Clipboard
<div role="row">
  <span role="cell">France</span>
  <span role="cell">67 million</span>
</div>


A better, more semantic way of writing the cells above would be to use the semantic <td> element.

HTML
Copy to Clipboard
<tr role="row">
  <td role="cell">France</td>
  <td role="cell">67 million</td>
</tr>

Description

The element with role="cell" is a cell within a row, optionally within a rowgroup, within a table. If the cell is in a grid or treegrid, opt for gridcell. Using native HTML <td> elements, whenever possible, is strongly encouraged.
Each element with role="cell" MUST be nested in a container element with role="row". That row, in turn, can be nested within an element with role="rowgroup", and should be nested within a grid, table or treegrid. If a cell contains column or row header information, use the columnheader or rowheader roles, respectively. If the cell does not contain header information and is nested in a grid or treegrid, the role of gridcell may be more appropriate.
A cell can contain a number of property attributes clarifying the cell's position within the tabular data structure, including aria-colindex, aria-colspan, aria-rowindex, and aria-rowspan.
Note: Using the native HTML table element (<table>) element, along with the table row element (<tr>), and table cell element (<td>), whenever possible, is strongly encouraged.
Associated WAI-ARIA roles, states, and properties
Context roles
role="row"

An element with role="row" is a row of cells within a tabular structure. A row contains one or more cells, grid cells, column headers, or row headers within a grid, table or treegrid, and optionally within a rowgroup.
role="rowgroup"

Row is a required cell parent. Rowgroup is an optional contextual row parent. It establishes a relationship between descendant rows. It is a structural equivalent to the thead, tfoot, and tbody elements in an HTML table element.
role="table"

One of the three possible contexts (along with grid and treegrid) in which you'll find a row containing cells. Table identifies the cell as being part of a non-interactive table structure containing data arranged in rows and columns, similar to the native HTML <table> element.
role="grid"

One of the three possible contexts (along with table and treegrid) in which you'll find a row containing cells and gridcells. Grid identifies a cell as being part of a possibly interactive table structure containing data arranged in rows and columns, similar to the native <table> HTML element.
role="treegrid"

Similar to a grid, but with rows that can be expanded and collapsed in the same manner as for a tree.
Subclass roles
role="gridcell"

A cell in a row within a grid or treegrid.
role="columnheader"

A header cell that is the structural equivalent of the HTML <th> element with a column scope. Unlike a plain cell, the columnheader role establishes a relationship between it and all cells in the corresponding column.
role="rowheader"

A header cell that is the structural equivalent of the HTML <th> element with a row scope. Unlike a plain cell, the rowheader role establishes a relationship between it and all cells in the corresponding row.
States and properties
aria-colspan

Similar to the HTML <th> and <td> colspan attribute, it defines the number of columns spanned by the cell.
aria-rowspan

Similar to the HTML <th> and <td> rowspan attribute, it defines the number of rows spanned by the cell.
aria-colindex attribute

The aria-colindex attribute is only needed if columns are hidden from the DOM. The attribute takes as its value an integer between 1 and the total number of columns within the table, grid or treegrid. The aria-colindex defines an element's column index or position with respect to the total number of columns within a row. If all the columns are in the DOM, this attribute is not necessary.
aria-rowindex attribute

The aria-rowindex attribute is only needed if rows are hidden from the DOM, to indicate which row, in the list of total rows, the current cell is in. The attribute, takes as its value an integer between 1 and the total number of rows within the table, grid, or treegrid, indicating the position, or index, of the cell. For example, a cell in the first row of the first header would likely have aria-rowindex="1" set, and cells in row 47 would have aria-rowindex="47", if aria-rowindex were needed due to not all rows being in the DOM. If the rows that are visible are contiguous, and there are no cells with a colspan or rowspan greater than one, this property can be added to the parent rows instead of all the rows' cells.
Keyboard interactions

None

Required JavaScript features

The first rule of ARIA use is if you can use a native feature with the semantics and behavior you require already built in, instead of repurposing an element and adding an ARIA role, state or property to make it accessible, then do so. Employ the HTML <td> element instead of the ARIA role of cell whenever possible.
Examples
HTML
Copy to Clipboard
<div
  role="table"
  aria-label="Semantic Elements"
  aria-describedby="semantic_elements_table_desc"
  aria-rowcount="81">
  <div id="semantic_elements_table_desc">
    Semantic Elements to use instead of ARIA's roles
  </div>
  <div role="rowgroup">
    <div role="row">
      <span role="columnheader" aria-sort="none" aria-rowindex="1"
        >ARIA Role</span
      >
      <span role="columnheader" aria-sort="none" aria-rowindex="1"
        >Semantic Element</span
      >
    </div>
  </div>
  <div role="rowgroup">
    <div role="row">
      <span role="cell" aria-rowindex="11">header</span>
      <span role="cell" aria-rowindex="11">h1</span>
    </div>
    <div role="row">
      <span role="cell" aria-rowindex="16">header</span>
      <span role="cell" aria-rowindex="16">h6</span>
    </div>
    <div role="row">
      <span role="cell" aria-rowindex="18">rowgroup</span>
      <span role="cell" aria-rowindex="18">thead</span>
    </div>
    <div role="row">
      <span role="cell" aria-rowindex="24">term</span>
      <span role="cell" aria-rowindex="24">dt</span>
    </div>
  </div>
</div>


The above is a non-semantic ARIA table with five of 81 rows present in the DOM: one within a table header and four rows within the table body. Because not all the rows are in the DOM, we've included the aria-rowindex property on every cell. If no cells spanned more than one row or column, the aria-rowindex could have been placed on the row rather than the row's individual cells.
Best practices

Only use <table>, <tbody>, <thead>, <tr>, <th>, <td>, etc., for data table structure. You can add ARIA roles to ensure accessibility should the native semantics of the table be removed, such as with CSS. A relevant use case for the ARIA table role is when the native semantics of a table are overridden by CSS's display property, such as by display: grid. In this case, you can use the ARIA table roles to add the semantics back in.
HTML
Copy to Clipboard
<table
  role="table"
  aria-label="Semantic Elements"
  aria-describedby="semantic_elements_table_desc"
  aria-rowcount="81">
  <caption id="semantic_elements_table_desc">
    Semantic Elements to use instead of ARIA's roles
  </caption>
  <thead role="rowgroup">
    <tr role="row">
      <th role="columnheader" aria-sort="none" aria-rowindex="1">ARIA Role</th>
      <th role="columnheader" aria-sort="none" aria-rowindex="1">
        Semantic Element
      </th>
    </tr>
  </thead>
  <tbody role="rowgroup">
    <tr role="row">
      <td role="cell" aria-rowindex="11">header</td>
      <td role="cell" aria-rowindex="11">h1</td>
    </tr>
    <tr role="row">
      <td role="cell" aria-rowindex="16">header</td>
      <td role="cell" aria-rowindex="16">h6</td>
    </tr>
    <tr role="row">
      <td role="cell" aria-rowindex="18">rowgroup</td>
      <td role="cell" aria-rowindex="18">thead</td>
    </tr>
    <tr role="row">
      <td role="cell" aria-rowindex="24">term</td>
      <td role="cell" aria-rowindex="24">dt</td>
    </tr>
  </tbody>
</table>


Above is the semantic way of writing a table. The ARIA roles are not necessary if the native semantics of the table, and therefore the table rows, have not been altered, such as through the display property.
Added benefits

When applied to a <td>, it returns cell semantics to the element in case the semantics were removed, such as with display: grid;.

--------------------------------------------------

ARIA role/attribute name: ARIA: checkbox role

The checkbox role is for checkable interactive controls. Elements containing role="checkbox" must also include the aria-checked attribute to expose the checkbox's state to assistive technology.

HTML
Copy to Clipboard
<span
  role="checkbox"
  aria-checked="false"
  tabindex="0"
  aria-labelledby="chk1-label"></span>
<label id="chk1-label">Remember my preferences</label>


Note: The first rule of ARIA is if a native HTML element or attribute has the semantics and behavior you require, use it instead of re-purposing an element and adding ARIA. Instead use the native HTML checkbox of <input type="checkbox"> (with an associated <label>), which natively provides all the functionality required:

HTML
Copy to Clipboard
<input type="checkbox" id="chk1-label" name="RememberPreferences" />
<label for="chk1-label">Remember my preferences</label>

Description

The native HTML checkbox (<input type="checkbox">) form control had two states ("checked" or "not checked"), with an indeterminate state settable via JavaScript. Similarly, an element with role="checkbox" can expose three states through the aria-checked attribute: true, false, or mixed.
Since a checkbox is an interactive control, it must be focusable and keyboard accessible. If the role is applied to a non-focusable element, use the tabindex attribute to change this. The expected keyboard shortcut for activating a checkbox is the Space key.
The developer is required to change the value of the aria-checked attribute dynamically when the checkbox is activated.
All descendants are presentational

There are some types of user interface components that, when represented in a platform accessibility API, can only contain text. Accessibility APIs do not have a way of representing semantic elements contained in a checkbox. To deal with this limitation, browsers, automatically apply role presentation to all descendant elements of any checkbox element as it is a role that does not support semantic children.
For example, consider the following checkbox element, which contains a heading.
HTML
Copy to Clipboard
<div role="checkbox"><h6>Name of my checkbox</h6></div>


Because descendants of checkbox are presentational, the following code is equivalent:

HTML
Copy to Clipboard
<div role="checkbox"><h6 role="presentation">Name of my checkbox</h6></div>


From the assistive technology user's perspective, the heading does not exist since the previous code snippets are equivalent to the following in the accessibility tree:

HTML
Copy to Clipboard
<div role="checkbox">Name of my checkbox</div>

Associated WAI-ARIA Roles, States, and Properties
aria-checked

The value of aria-checked defines the state of a checkbox. This attribute has one of three possible values:

true

The checkbox is checked.
false

The checkbox is not checked.
mixed

The checkbox is partially checked, or indeterminate.
tabindex="0"

Used to make it focusable so the assistive technology user can tab to it and start reading right away.
Keyboard interactions
Key	Function
Space	Activates the checkbox

Required JavaScript
Required event handlers
onclick

Handle mouse clicks on both the checkbox and the associated label that will change the state of the checkbox by changing the value of the aria-checked attribute and the appearance of the checkbox so it appears checked or unchecked to the sighted user

onKeyDown

Handle the case where the user presses the Space key to change the state of the checkbox by changing the value of the aria-checked attribute and the appearance of the checkbox so it appears checked or unchecked to the sighted user

Examples

The following example creates an otherwise non-semantic checkbox element using CSS and JavaScript to handle the checked or unchecked status of the element.
HTML
HTML
Copy to Clipboard
Play
<span
  role="checkbox"
  id="chkPref"
  aria-checked="false"
  onclick="changeCheckbox()"
  onKeyDown="changeCheckbox(event.code)"
  tabindex="0"
  aria-labelledby="chk1-label"></span>
<label
  id="chk1-label"
  onclick="changeCheckbox()"
  onKeyDown="changeCheckbox(event.code)"
  >Remember my preferences</label
>

CSS
CSS
Copy to Clipboard
Play
[role="checkbox"] {
  padding: 5px;
}

[role="checkbox"]:focus {
  border: 2px solid #0198e1;
}

[aria-checked="true"]::before {
  content: "[x]";
}

[aria-checked="false"]::before {
  content: "[ ]";
}

JavaScript
JS
Copy to Clipboard
Play
function changeCheckbox(code) {
  const item = document.getElementById("chkPref");
  const checked = item.getAttribute("aria-checked");

  if (code && code !== "Space") {
    return;
  } else if (checked === "true") {
    item.setAttribute("aria-checked", "false");
  } else {
    item.setAttribute("aria-checked", "true");
  }
}

Play

Accessibility concerns

When the checkbox role is added to an element, the user agent should do the following:

Expose the element as having a checkbox role in the operating system's accessibility API.
When the aria-checked value changes, send an accessible state changed event.
Assistive technology products should do the following:

Screen readers should announce the element as a checkbox, and optionally provide instructions on how to activate it.
People implementing checkboxes should do the following:

Ensure that the checkbox can be reached and interacted with by both keyboard controls and clicks
Keep the aria-checked attribute up to date following user interactions
Provide styles that indicate when the checkbox has focus

Note: Opinions may differ on how assistive technology should handle this technique. The information provided above is one of those opinions and may change.
Best practices

The first rule of ARIA is: if a native HTML element or attribute has the semantics and behavior you require, use it instead of re-purposing an element and adding an ARIA role, state or property to make it accessible. As such, it is recommended to use the native HTML checkbox using form control instead of recreating a checkbox's functionality with JavaScript and ARIA.

--------------------------------------------------

ARIA role/attribute name: ARIA: columnheader role

The columnheader value of the ARIA role attribute identifies an element as being a cell in a row contains header information for a column, similar to the native <th> element with column scope.

Description

An element with role="columnheader" nested as a descendant for an element with role="row", is a static tabular structure of a column header cell in a tabular container, either a table or grid, or other chart that needs to show data relationships. To be supported, the columnheader must be nested in an element with the role of row.
Associated WAI-ARIA roles, states, and properties

All column headers should be nested within a row. Every row, in turn, should be nested within a grid, table, or treegrid, alternatively within a rowgroup nested within one of the above.
aria-sort

Only applied to one column header at a time, if any, the aria-sort attribute indicates if a column is sorted in the three values of ascending or descending order, or none for not sorted.
Keyboard interactions

This role does not support any specific keyboard interaction.
Required JavaScript features

JavaScript is only required if the aria-sort attribute is used.
Examples
HTML
Copy to Clipboard
<table>
  <thead>
    <tr role="row">
      <th role="columnheader" scope="col">
        <button>First Name</button>
      </th>
      <th role="columnheader" scope="col">
        <button>Last Name</button>
      </th>
      <th role="columnheader" scope="col" aria-sort="ascending">
        <button>Company Name</button>
      </th>
      <th role="columnheader" scope="col">
        <button>Job Title</button>
      </th>
    </tr>
  </thead>
  <tbody>
    …
  </tbody>
</table>

Best Practices

Column headers should contain a title or header information for the column.
The first rule of ARIA is: if a native HTML element or attribute has the semantics and behavior you require, use it instead of re-purposing an element and adding an ARIA role, state or property to make it accessible. It is recommended to use the native HTML <th> element with the scope attribute set <th scope="col"> instead of a <div> or other element. If you use semantic HTML's <th scope="col"> the role attribute is not required, but can be included as a back up to ensure the table retains its semantics should the default semantics be removed with a CSS display property value.
The aria-sort attribute can be added to a <th scope="col"> even when the ARIA role attribute is not specified.
Prefer HTML

Columnheader has the same semantics <th scope="col">.

--------------------------------------------------

ARIA role/attribute name: ARIA: combobox role

The combobox role identifies an element as an input that controls another element, such as a listbox or grid, that can dynamically pop up to help the user set the value of that input.

Description

A combobox is a composite widget that combines a named input field with a popup providing possible values for that input field. The purpose of this widget is to improve user experience by helping the user select a value without having to type in the complete value and, optionally depending whether supported values are limited, preventing the user from entering invalid or otherwise unsupported values.
The combobox role is set on input that controls another element, such as a listbox or grid, that can dynamically pop up to help the user set the value of the input.
The combobox input field can either be a single-line text field that supports editing and typing, similar to a HTML <input> with a <datalist>, or an element that only displays the current value of the combobox.
A WAI-ARIA combobox only has one attribute that is required that authors specify: aria-expanded. However, it also has several other attributes which will be necessary to specify, depending on the combobox's implementation. These include aria-haspopup, aria-controls, aria-activedescendant, and aria-autocomplete.
Typically, the initial state of a combobox is collapsed, with aria-expanded="false" set. In the collapsed state, only the combobox element and, optionally a sibling button to invoke the popup, are visible. The aria-expanded, with the value set to false, is required when collapsed, because it indicates to assistive technologies that the widget is expandable.
The combobox is in the expanded state when both the combobox element showing its current value and its associated popup element are visible. When expanded, aria-expanded="true" must be set.
The popup element associated with a combobox can be either a listbox, tree, grid, or dialog element.
Comboboxes have an implicit aria-haspopup value of listbox, so including this attribute is optional if the popup is a listbox. If the combobox popup element is a tree, grid, or dialog (anything other than a listbox), the aria-haspopup attribute is required. The value of aria-haspopup must be either the tree, grid, dialog, or listbox role. Note that for this property, true means menu, so make sure that the value corresponds to the role of the popup, not a Boolean value.
When a combobox's popup is displayed, ensure the aria-controls attribute on the combobox element is set to the id of the popup listbox, tree, grid, or dialog element. This is how the relationship between the element with the combobox role and the popup it controls is indicated. (Note: In older ARIA specs, this was aria-owns rather than aria-controls, so you may see aria-owns in older combobox implementations. The aria-owns in the code should be updated to aria-controls!)

If the combobox UI includes a visible control, such as an icon, that allows the visibility of the popup to be controlled via pointer and touch events, that control should be a <button>, <input> of type button, or a button role element with a tabindex of -1. Doing so will allow the button to be focusable but not included in keyboard tab sequence. It must not be a descendant of the element with role combobox.
To be keyboard accessible, keyboard support for moving focus between the combobox input field element and elements contained in the popup listbox, tree, grid, or dialog, must be programmed in. One common convention is that Down Arrow moves focus from the input to the first focusable descendant of the popup element.
The aria-activedescendant property can be used to identify the currently active element of the combobox popup, for instance an option within a popup listbox, for implementations where DOM focus remains on the combobox. If DOM focus does not remain on the combobox when its popup is invoked, but rather DOM focus moves into the popup, such as a dialog, then aria-activedescendant may not be necessary.
If the combobox element is an <input> element, the value of the combobox is the input's value. Otherwise, the value of the combobox comes from its descendant elements.
If the combobox supports text input and provides autocompletion behavior, set aria-autocomplete on the combobox element to the value that corresponds to the provided behavior: inline, list, or both. The aria-autocomplete attribute indicates that inputting text will trigger display of one or more predictions of the user's intended value for the combobox and specifies how the predictions will be presented when made.
Every combobox must have an accessible name. If using an <input> element, the accessible name should come from the associated <label>. If not, if an appropriate label is visible in the content, provide the name via aria-labelledby. In other words, if there is an element in the user interface that serves as a label for the combobox input field, include aria-labelledby as an attribute on the element with the role of combobox, and set the value of the attribute to the id of the labelling element or elements. If no visible label is present, use aria-label instead. Not both.
Associated WAI-ARIA roles, states, and properties
aria-expanded

Required. Identifies whether the combobox is open (true) or closed (false).
aria-haspopup

Implied. If omitted, defaults to listbox. Also supports tree, grid, or dialog. Identifies the combobox has having a popout, and indicates the type.
Keyboard interactions
Down Arrow

Moves focus to the next option, or to the first option if none was selected.
Alt + Down Arrow (Optional)

If the popup is available but not displayed, displays the popup without moving focus.
Up Arrow

Moves focus to the previous option. Moving focus to the first option if focus was originally on the last option.
Alt + Up Arrow (Optional)

If the popup has focus, returns focus to the combobox, otherwise it closes the popup.
Enter

If the combobox is editable and an autocomplete suggestion is selected in the popup, accepts the suggestion either by placing the input cursor at the end of the accepted value in the combobox or by performing a default action on the value. For example, in a messaging application, the default action may be to add the accepted value to a list of message recipients and then clear the combobox so the user can add another recipient.
Examples
HTML
Copy to Clipboard
<label for="jokes">Pick what type of jokes you like</label>
<div class="combo-wrap">
  <input
    type="text"
    id="jokes"
    role="combobox"
    aria-controls="joketypes"
    aria-autocomplete="list"
    aria-expanded="false"
    data-active-option="item1"
    aria-activedescendant="" />
  <span aria-hidden="true" data-trigger="multiselect"></span>
  <ul id="joketypes" role="listbox" aria-label="Jokes">
    <li class="active" role="option" id="item1">Puns</li>
    <li class="option" role="option" id="item2">Riddles</li>
    <li class="option" role="option" id="item3">Observations</li>
    <li class="option" role="option" id="item4">Knock-knock</li>
    <li class="option" role="option" id="item5">One liners</li>
  </ul>
</div>


--------------------------------------------------

ARIA role/attribute name: ARIA: command role

The command role defines a widget that performs an action but does not receive input data.

Note: The command role is an abstract role. It is included here for completeness of documentation. It should not be used by web authors.

Description

A command is form of widget that performs an action but does not receive input data. It is a superclass for the widget roles button, link, and menuitem

Best Practices

Do not use.

--------------------------------------------------


--------------------------------------------------

ARIA role/attribute name: ARIA: complementary role

The complementary landmark role is used to designate a supporting section that relates to the main content, yet can stand alone when separated. These sections are frequently presented as sidebars or call-out boxes. If possible, use the HTML <aside> element instead.

HTML
Copy to Clipboard
<div role="complementary">
  <h2>Our partners</h2>
  <!-- complementary section content -->
</div>


This is a sidebar containing links to project sponsors.

Description

The complementary role is a landmark role. Landmarks can be used by assistive technology to quickly identify and navigate to large sections of the document. Content listed within a container with the complementary landmark role should make sense if separated from the main content of the document.
Note: Using the <aside> element will automatically communicate a section has a role of complementary. Developers should always prefer using the correct semantic HTML element over using ARIA.
Examples
HTML
Copy to Clipboard
<div role="complementary">
  <h2>Trending articles</h2>
  <ul>
    <li><a href="#">18 tweets that will make you feel all the feels</a></li>
    <li>
      <a href="#">Stop searching! I've found the perfect lunch containers.</a>
    </li>
    <li>
      <a href="#">The time has come to decide how to call these foods</a>
    </li>
    <li><a href="#">17 really good posts we saw on Tumblr this week</a></li>
    <li><a href="#">10 parent hacks we know work because we tried them</a></li>
  </ul>
</div>

Accessibility concerns

Landmark roles are intended to be used sparingly, to identify larger overall sections of the document. Using too many landmark roles can create "noise" in screen readers, making it difficult to understand the overall layout of the page.
Best practices

Prefer HTML

Using the <aside> element will automatically communicate a section has a role of complementary. If at all possible, prefer using it instead.
Labeling landmarks
Multiple landmarks

If there is more than one complementary landmark role or <aside> element in a document, provide a label for each landmark using the aria-label attribute, or, if the aside has an appropriately descriptive title, point to it with the aria-labelledby attribute. This label will allow an assistive technology user to be able to quickly understand the purpose of each landmark.
HTML
Copy to Clipboard
<aside aria-label="Note about usage">
  <!-- content -->
</aside>

…

<aside id="sidebar" aria-label="Sponsors">
  <!-- content -->
</aside>

Redundant descriptions

Screen readers will announce the type of role the landmark is. Because of this, you do not need to describe what the landmark is in its label. For example, a declaration of role="complementary" with an of aria-label="Sidebar" may be announced redundantly as, "complementary sidebar".
Added benefits

Certain technologies such as browser extensions can generate lists of all landmark roles present on a page, allowing non-screen reader users to also quickly identify and navigate to large sections of the document.
Landmarks browser extension


--------------------------------------------------

ARIA role/attribute name: ARIA: composite role

The composite abstract role indicates a widget that may contain navigable descendants or owned children.

Note: The composite role is an abstract role. It is included here for completeness of documentation. It should not be used by web authors.

Description

Composite is an abstract role used for the ontology. Don't use this role in content. Instead, use the composite subclasses of grid, select, spinbutton, and tablist

Best Practices

Do not use.

--------------------------------------------------

ARIA role/attribute name: ARIA: contentinfo role

The contentinfo role defines a footer, containing identifying information such as copyright information, navigation links, and privacy statements, found on every document within a site. This section is commonly called a footer.

HTML
Copy to Clipboard
<div role="contentinfo">
  <h2>Footer</h2>
  <!-- footer content -->
</div>


This is a website footer. Using the <footer> element instead is recommended:

HTML
Copy to Clipboard
<footer>
  <h2>Footer</h2>
  <!-- footer content -->
</footer>

Description

The contentinfo role is a landmark used to identify a page footer. Landmarks can be used by assistive technology to quickly identify and navigate to large sections of the document. Pages should only include one top-level contentinfo landmark role per page.
Each page should only include one contentinfo landmark, created by either using the <footer> element or by declaring role="contentinfo". contentinfo landmarks present in content embedded via <iframe> do not count towards this limit.
Note: Using the <footer> element will automatically communicate a section has a role of contentinfo. Developers should always prefer using the correct semantic HTML element over using ARIA, making sure to test for known issues in VoiceOver.
Examples
HTML
Copy to Clipboard
<body>
  <!-- other page content -->

  <div role="contentinfo">
    <h2>MDN Web Docs</h2>
    <ul>
      <li><a href="#">Web Technologies</a></li>
      <li><a href="#">Learn Web Development</a></li>
      <li><a href="#">About MDN</a></li>
      <li><a href="#">Feedback</a></li>
    </ul>
    <p>
      © 2005-2012 Mozilla and individual contributors. Content is available
      under <a href="#">these licenses</a>.
    </p>
  </div>
</body>

Accessibility concerns

Use sparingly

Landmark roles are intended to identify larger overall sections of the document. Using too many landmark roles can create "noise" in screen readers, making it difficult to understand the overall layout of the page.
One contentinfo landmark per page
The <body> element

There should be only one contentinfo landmark per document, used as the immediate descendant of the <body> element.
Mega-footers

Do not nest additional <footer> elements or contentinfo landmarks inside the document's footer. Use other content sectioning elements instead.
Labeling landmarks
Multiple landmarks

If there is more than one contentinfo landmark role or <footer> element in a document, provide a label with the aria-label attribute for each landmark. This label will allow assistive technology users to quickly understand the purpose of each landmark.
HTML
Copy to Clipboard
<body>
  …

  <article>
    <h2>Everyday Pad Thai</h2>
    <!-- article content -->
    <footer aria-label="Everyday Pad Thai metadata">
      <p>
        Posted on <time datetime="2021-09-23 12:17">September 23</time> by
        <a href="#">Lisa</a>.
      </p>
    </footer>
  </article>

  …

  <footer aria-label="Footer">
    <!-- footer content -->
  </footer>
</body>

Redundant descriptions

Screen readers will announce the type of role the landmark is. Because of this, you do not need to describe what the landmark is in its label. For example, a declaration of role="contentinfo" with an of aria-label="Footer" may be announced redundantly as, "contentinfo footer".
Best practices

Prefer HTML

When it is an immediate descendant of the <body> using the <footer> element will automatically communicate a section has a role of contentinfo (save for a known issue in VoiceOver). If at all possible, prefer using <footer> instead. Note that a footer element nested within an article, aside, main, nav, or section is not considered contentinfo.
Added benefits

Certain technologies such as browser extensions can generate lists of all landmark roles present on a page, allowing non-screen reader users to also quickly identify and navigate to large sections of the document.
Landmarks browser extension


--------------------------------------------------

ARIA role/attribute name: ARIA: definition role

The definition ARIA role indicates the element is a definition of a term or concept.

Description

The definition ARIA role can be included on an element that is a definition of a term or concept, similar to the native <dfn> element. To associate the definition with the term being defined, and to provide an accessible name, reference the term being defined with role="term", using aria-labelledby.
HTML
Copy to Clipboard
<p>
  <span role="term">Mansplaining</span>,
  <span role="definition">
    a portmanteau of "man" and "explain", is the patronizing act of explaining
    without being asked to do so, to someone already learned on the topic, often
    after someone has already explained it
  </span>.
</p>


Note: Instead of a <span> with the term and definition roles, use the <dfn> element. Always use native element if available.
HTML
Copy to Clipboard
<p>
  <dfn>Mansplaining</dfn>, a portmanteau of "man" and "explain", is the
  patronizing act of explaining without being asked to do so, to someone already
  learned on the topic, often after someone has already explained it.
</p>


--------------------------------------------------

ARIA role/attribute name: ARIA: dialog role

The dialog role is used to mark up an HTML based application dialog or window that separates content or UI from the rest of the web application or page. Dialogs are generally placed on top of the rest of the page content using an overlay. Dialogs can be either non-modal (it's still possible to interact with content outside of the dialog) or modal (only the content in the dialog can be interacted with).

HTML
Copy to Clipboard
<div
  role="dialog"
  aria-labelledby="dialog1Title"
  aria-describedby="dialog1Desc">
  <h2 id="dialog1Title">Your personal details were successfully updated</h2>
  <p id="dialog1Desc">
    You can change your details at any time in the user account section.
  </p>
  <button>Close</button>
</div>

Description

A dialog is a descendant window of the primary window of a web application. For HTML pages, the primary application window is the entire web document, i.e., the body element.
Marking up a dialog element with the dialog role helps assistive technology identify the dialog's content as being grouped and separated from the rest of the page content. However, adding role="dialog" alone is not sufficient to make a dialog accessible. Additionally, the following needs to be done:

The dialog must be properly labeled
Keyboard focus must be managed correctly

The sections below describe how these two requirements can be met.
Labeling

Even though it is not required for the dialog itself to be able to receive focus, it still needs to be labeled. The label given to the dialog will provide contextual information for the interactive controls inside the dialog. In other words, the dialog's label acts like a grouping label for the controls inside it (similar to how a <legend> element provides a grouping label for the controls inside a <fieldset> element).
If a dialog already has a visible title bar, the text inside that bar can be used to label the dialog itself. The best way to achieve this is by using the aria-labelledby attribute to the role="dialog" element. Additionally, if the dialog contains additional descriptive text besides the dialog title, this text can be associated with the dialog using the aria-describedby attribute. This approach is shown in the code snippet below:

HTML
Copy to Clipboard
<div
  role="dialog"
  aria-labelledby="dialog1Title"
  aria-describedby="dialog1Desc">
  <h2 id="dialog1Title">Your personal details were successfully updated</h2>
  <p id="dialog1Desc">
    You can change your details at any time in the user account section.
  </p>
  <button>Close</button>
</div>


Note: Keep in mind that a dialog's title and description text do not have to be focusable in order to be perceived by screen readers operating in a non-virtual mode. The combination of the ARIA dialog role and labeling techniques should make the screen reader announce the dialog's information when focus is moved into it.
Required JavaScript features
Focus management

A dialog has particular requirements for how keyboard focus should be managed:

Dialogs should always have at least one focusable control. For many dialogs, there will be a button like "Close", "OK" or "Cancel". In addition to the needed control, dialogs can contain any number of focusable elements, even entire forms or other container widgets like tabs.
When the dialog appears on the screen, keyboard focus (whose control depends upon the dialog's purpose) should be moved to the default focusable control inside the dialog. For dialogs that only provide a basic message, it could be an "OK" button. For dialogs containing a form it could be the first field in the form.
After the dialog is dismissed, keyboard focus should be moved back to where it was before it moved into the dialog. Otherwise the focus can be dropped to the beginning of the page.
For most dialogs, the expected behavior is that the dialog's tab order wraps, which means that when the user tabs through the focusable elements in the dialog, the first focusable element will be focused after the last one has been reached. In other words, the tab order should be contained within and by the dialog.
If the dialog can be moved or resized, ensure that these actions must be performable by keyboard users as well as mouse users. Similarly, if a dialog provides special features like toolbars or context menus, these must be reachable and operable by keyboard users as well.
Dialogs can be modal or non-modal. When a modal dialog appears on the screen, it's not possible to interact with any page content outside the dialog. In other words, the main application UI or page content is considered to be temporarily disabled as long as the modal dialog is showing. For non-modal dialogs it is still possible to interact with content outside of the dialog while the dialog is showing. Note that for non-modal dialogs there will have to be a global keyboard shortcut that allows focus to be moved between opened dialogs and the main page.
Associated ARIA roles, states, and properties
aria-labelledby

Use this attribute to label the dialog. Often, the value of the aria-labelledby attribute will be the id of the element used to title the dialog.
aria-describedby

Use this attribute to describe the contents of the dialog.
Possible effects on user agents and assistive technology

When the dialog role is used, the user agent should do the following:

Expose the element as a dialog in the operating system's accessibility API.
When the dialog is correctly labeled and focus is moved to an element (often an interactive element, such as a button) inside the dialog, screen readers should announce the dialog's accessible role, name and optionally description, along with announcing the focused element.
Note: Opinions may differ on how assistive technology should handle this technique, and the order of announcements may differ depending on the assistive technology used. The information provided above is one of those opinions and may change as the specification is defined.
Examples

A dialog containing a form
HTML
Copy to Clipboard
<div
  role="dialog"
  aria-labelledby="dialog1Title"
  aria-describedby="dialog1Desc">
  <h2 id="dialog1Title">Subscription Form</h2>
  <p id="dialog1Desc">We will not share this information with third parties.</p>
  <form>
    <p>
      <label for="firstName">First Name</label>
      <input id="firstName" type="text" />
    </p>
    <p>
      <label for="lastName">Last Name</label>
      <input id="lastName" type="text" />
    </p>
    <p>
      <label for="interests">Interests</label>
      <textarea id="interests"></textarea>
    </p>
    <p>
      <input type="checkbox" id="autoLogin" name="autoLogin" />
      <label for="autoLogin">Auto-login?</label>
    </p>
    <p>
      <input type="submit" value="Save Information" />
    </p>
  </form>
</div>

Working Examples
jQuery-UI Dialog

Notes

Note: While it is possible to prevent keyboard users from moving focus to elements outside of the dialog, screen reader users may still be able to navigate to that content using their screen reader's virtual cursor. It is important for developers to ensure that content outside of the modal dialog is inaccessible to all users while the modal dialog is active.

--------------------------------------------------

ARIA role/attribute name: ARIA: directory role

The directory role was for a list of references to members of a group, such as a static table of contents.

Warning: The directory role was deprecated in ARIA 1.2

Description

A directory is a static table of contents, whether linked or unlinked. This includes tables of contents built with lists, including nested lists. Dynamic tables of contents, however, might use a tree role instead.
The deprecated directory role was used for lists of references to members of a group, such as a static table of contents. Use the list role instead. Or, better yet, use the <ul> or <ol> elements, as using directory does not provide any additional benefits to assistive technology users.

--------------------------------------------------

ARIA role/attribute name: ARIA: document role

The document role is for focusable content within complex composite widgets or applications for which assistive technologies can switch reading context back to a reading mode.

Description

The document role is for the top container containing content that assistive technology users may want to browse in a reading mode. Only useful on focusable sections within complex composite widgets or applications, the document role informs assistive technologies to the reading context back to a reading mode: The document role tells assistive technologies with reading or browse modes to use the document mode to read the content contained within this element.
HTML
Copy to Clipboard
<div role="dialog">
  …
  <div id="InfoText" role="document" tabindex="0">
    <p>Some informational text goes here.</p>
  </div>
  …
  <button>Close</button>
</div>


This example shows a dialog, a complex composite widget role, with some controls and a section with some informational text that the assistive technology user can go into reading mode when tabbed to.
By default, web pages are treated as documents; assistive technologies (AT) enter browse or read mode when entering a new web page. This mode can be altered through various roles, including the widget and application roles. The document role brings the AT back into browse or read mode.
Generally placed within an application role or other interactive widget role, the document role is used to indicate a section of a complex composite widget that an assistive technology user should read using its browse or virtual reading mode, if available.
Because ATs with reading mode default to that mode for all elements except for those with a widget or application role set, document role is only useful for focusable elements within a widget or application that should be read as static rich text. Adding role="document" and tabindex="0" to the element containing the text within a widget enables the screen reader user to press the Tab key to place focus on the document element and read the text with the screen reader's reading cursor.
Assistive technologies should switch context back to document mode, possibly intercepting from controls rewired for the parent's dynamic context, re-enabling the standard input events, such as Up or Down arrow keyboard events, to control the reading cursor.
In contrast to the article role, the document role does not have any relation to other elements with a document role, it merely has a relationship to the containing composite widget. An article can have associated articles.
Associated WAI-ARIA roles, states, and properties
aria-expanded

Include with a value of true or false if the document element is collapsible, to indicate if the document is currently expanded or collapsed. Other values include the default undefined which means the document is not collapsible.
tabindex="0"

Used to make it focusable so the assistive technology user can tab to it and start reading right away.
Keyboard interactions

The element should be made focusable by setting the tabindex="0" attribute / value pair on it. This way, the user can tab to it, reading mode is invoked automatically, and the content can be read right away.
Required JavaScript features

None, except as required by any attributes. For example, if the document is collapsible, then the state and the value of aria-expanded must be maintained.
Examples

An example is Gmail and the single conversation view. GMail is a web application. When in GMail, most user agent interactions are usurped by the application. However, when the Keyboard focus is set on the starting heading on a single conversation that contains the subject of the conversation, the screen reader user can use the reading mode commands to read through the messages, expand or collapse them, and manipulate them. Once focus returns to the message list either by activating the Back button or pressing an associated keystroke, direct application interaction mode is invoked again, and the user can move to a different conversation in the list with the arrow keys.
Best practices

Always make sure an item with the document role is focusable, by setting the tabindex attribute with a value of 0. That will also include it in the tab order.
Added benefits

The document role is an easy way to indirectly control assistive technology behavior by unambiguously stating that this is content the user should read with standard screen reader commands.

--------------------------------------------------


--------------------------------------------------

ARIA role/attribute name: ARIA: feed role

A feed is a dynamic scrollable list of articles in which articles are added to or removed from either end of the list as the user scrolls. A feed enables screen readers to use the browse mode reading cursor to both read and scroll through a stream of rich content that may continue scrolling infinitely by loading more content as the user reads.

HTML
Copy to Clipboard
<section role="feed" aria-busy="false">
  …
  <article aria-posinset="427" aria-setsize="-1">…</article>
  <article aria-posinset="428" aria-setsize="-1">…</article>
  <article aria-posinset="429" aria-setsize="-1">…</article>
  …
</section>

Description

A feed is a type of list, the containing role for scrollable articles where scrolling may cause articles to be added to the top or end of the list. The role enables assistive technology to use the browse mode reading cursor to both read and scroll through a stream of rich content that may continue scrolling infinitely by loading more content as the user reads. Examples include an RSS feed, news feeds, social media feeds like Facebook, Instagram or Mastodon, or even a list of related products on an e-commerce page. These streams can be limited or infinite, loading more content as the user scrolls. Implementing the feed pattern allows a screen reader to reliably read and trigger the loading of feed content while in reading mode.
Unlike the document structure elements that represent static HTML elements, the feed role requires specific interactions and implementation of keyboard navigation. The feed is a container element whose children are <article>s or have role article. Each article within a feed should be focusable, with tabindex of 0 or -1. An article should be scrolled into view when it, or a descendant element, receives focus. If the addition of articles occupies the main browser thread, make sure to set aria-busy="true" on the feed itself, and make sure to set it back to false when processing ends, or the user may not see the updates.
If the number of articles is known, set aria-setsize on the articles themselves. However, if the total number is extremely large, indefinite, or changes often, set aria-setsize="-1" to indicate that the size of the feed is not known.
Another feature of the feed pattern is skim reading: Articles within a feed can contain both an accessible name with the aria-label and a description with an aria-describedby, suggesting to screen readers which elements to speak after the label when navigating by article. By identifying the elements inside an article that provide the title and the primary content, assistive technologies can provide functions that enable users to jump from article to article and efficiently discern which articles they want to read.
The feed pattern enables reliable assistive technology reading mode interaction by establishing the following interoperability agreement between the web page and assistive technologies:

In the context of a feed, the web page code is responsible for:

Appropriate visual scrolling of the content based on which article contains DOM focus.
Loading or removing feed articles based on which article contains DOM focus.
Keyboard interactions

Supporting the following, or a similar, interface is recommended when focus is inside the feed:

Page Down: Move focus to next article.
Page Up: Move focus to previous article.
Control + End: Move focus to the first focusable element after the feed.
Control + Home: Move focus to the first focusable element before the feed.
If a feed is nested within a feed, such as a comments feed within a feed of blog posts, the convention is to tab into the nested feed with the Tab key and to provide another key, such as Alt + Page Down, to navigate from an 'outer' article to the first item in that article's nested feed. Navigate between the nested feed and main feed with Control + End, moving focus from the inner feed to the next article in the outer feed.
WAI-ARIA roles, states, and properties
aria-label

If the feed has no visible title, the feed element has a label specified with aria-label. If it does, see aria-labelledby.
aria-labelledby

If the feed has a visible title, the feed element has aria-labelledby referring to the element containing the title. If not, add an aria-label.
aria-busy

When busy, such as when articles are being added or removed from the feed, set aria-busy="true" during the update operation. Make sure it's reset to false when the operation is complete or the changes may not become visible.
article

Each section of content in a feed should be contained in an <article> or element with role article. Each article should have an aria-labelledby referring to the article title or other child that can serve as a distinguishing label. Each article should preferably have aria-describedby referring to one or more elements inside the article that serve as the primary content of the article. Each article element has aria-posinset set to a value that represents its position in the feed and an aria-setsize set to a value that represents either the total number of articles that have been loaded or the total number in the feed, depending on which value is more helpful to users. If the total number in the feed is not known, set aria-setsize="-1".
Required JavaScript features

None, except as required by any attributes. For example, setting aria-busy to true during the update operation if needed, and then to false upon completion.
Note: It is the author's responsibility to apply the "above" keyboard behavior.
Examples

Example Implementation of Feed Pattern

Best practices

To ensure good user experience, avoid inserting or removing articles in the middle of a feed, load new articles before the user has reached the end of the feed, and provide keyboard commands for moving focus among articles so that keyboard users can navigate through your feed. See Keyboard interactions.

--------------------------------------------------

ARIA role/attribute name: ARIA: figure role

The ARIA figure role can be used to identify a figure inside page content where appropriate semantics do not already exist. A figure is generally considered to be one or more images, code snippets, or other content that puts across information in a different way to a regular flow of text.

Description

A figure is a perceivable section of content that typically contains a graphical document, images, code snippets, or example text. The parts of a figure MAY be user-navigable. Any content that should be grouped together and consumed as a figure (which could include images, video, audio, code snippets, or other content) can be identified as a figure using role="figure".
HTML
Copy to Clipboard
<div role="figure" aria-labelledby="caption">
  <img src="image.png" alt="put image description here" />
  <p id="caption">Figure 1: The caption</p>
</div>


In the above example, we have a figure that consists of two separate content items — an image and a caption. This is wrapped by a <div> element that identifies the content as a figure using role="figure".
For HTML, use the <figure> and <figcaption> elements. The figcaption will serve as the accessible name for the figure. When not using HTML, or when retrofitting legacy HTML, use the aria-labelledby on the figure, pointing to the figure's caption. If there is no visible caption, aria-label can be used.
HTML
Copy to Clipboard
<div role="figure" aria-labelledby="figure-1">
  …
  <p id="figure-1">Text that describes the figure.</p>
</div>

Use aria-labelledby when the text is a concise label.
Use aria-describedby when the text is a longer description.
Use aria-label when there is no visible figure caption.
This can be done semantically, without ARIA, with HTML's <figure> element along with <figcaption>.
HTML
Copy to Clipboard
<figure>
  <img src="image.png" alt="put image description here" />
  <figcaption>Figure 1: The caption</figcaption>
</figure>


Note: If at all possible in your work, you should use the appropriate semantic HTML elements to mark up a figure and its caption — <figure> and <figcaption>.
Associated WAI-ARIA roles, states, and properties
aria-describedby

The id of an element containing reference text serving as a caption.
aria-labelledby

The id of an element containing text serving as a label.
aria-label

If there is no element containing text that could serve as a label, you can add the label directly as a value on the aria-label on the element with the figure role or on the <figure> element.
Keyboard interactions

No role specific keyboard interactions.
Required JavaScript features

No role specific JavaScript requirements. If you don't have control over the HTML semantics, you can improve the accessibility of HTML by adding these roles and properties with JavaScript.
Examples

We could extend the initial example on the page to also identify a paragraph that provides a descriptive label for the figure by referencing its ID in aria-labelledby:

HTML
Copy to Clipboard
<div role="figure" aria-labelledby="figure-1">
  <img
    src="diagram.png"
    alt="diagram showing the four layers of awesome and their relative priority order —
        music, cats, nature, and ice cream" />
  <pre>
`
        let awesome = ['music', 'cats', 'nature', 'ice cream'];
      `</pre
  >
  <p id="figure-1">Figure 1: The four layers of awesome.</p>
</div>

Best practices

Only use role="figure" if you have to — for example if you don't have control over your HTML but are able to improve accessibility dynamically after the fact with JavaScript.
If at all possible, you should use the appropriate semantic HTML elements to mark up a figure and its caption — <figure> and <figcaption>. For example, our above example should be rewritten as follows:

HTML
Copy to Clipboard
<figure>
  <img
    src="diagram.png"
    alt="diagram showing the four layers of awesome and their relative priority order —
         music, cats, nature, and ice cream" />
  <pre>
`
    let awesome = ['music', 'cats', 'nature', 'ice cream'];
  `</pre
  >
  <figcaption>Figure 1: The four layers of awesome.</figcaption>
</figure>


--------------------------------------------------

ARIA role/attribute name: ARIA: form role

The form role can be used to identify a group of elements on a page that provide equivalent functionality to an HTML form. The form is not exposed as a landmark region unless it has an accessible name.

HTML
Copy to Clipboard
<div role="form" id="contact-info" aria-label="Contact information">
  <!-- form content -->
</div>


This is a form that collects and saves a user's contact information.

Warning: Use an HTML <form> element to contain your form controls, rather than the ARIA form role, unless you have a very good reason. The HTML <form> element is sufficient to tell assistive technologies that there is a form.

Description

A form landmark identifies a region of content that contains a collection of items and objects that, as a whole, combine to create a form when no other named landmark is appropriate (e.g. main or search).
Note: Using the <form> element will automatically communicate a section of content as a form landmark, if it is provided an accessible name. Developers should always prefer using the correct semantic HTML element over using ARIA.
Use the HTML <form> element if possible. The <form> element defines a form landmark when it has an accessible name (e.g. aria-labelledby, aria-label or title). Make sure to have a unique label on each form in a document to help users understand the purpose of the form. This label should be visible to all users, not just assistive technology users. Use the search landmark instead of the form landmark when the form is used for search functionality.
Use the role="form" to identify a region of the page; do not use it to identify every form field. Even if you are using the form landmark instead of <form>, you are encouraged to use native HTML form controls like <button>, <input>, <select>, and <textarea>.
Associated WAI-ARIA Roles, States, and Properties

No role specific states or properties.
Keyboard Interactions

No role specific keyboard interactions

Required JavaScript features
onsubmit

The onSubmit event handler handles the event raised when the form is submitted. Anything that is not a <form> cannot be submitted, therefore you would have to use JavaScript to build an alternative data submission mechanism, for example with fetch().
Examples
HTML
Copy to Clipboard
<div role="form" id="send-comment" aria-label="Add a comment">
  <label for="username">Username</label>
  <input
    id="username"
    name="username"
    autocomplete="nickname"
    autocorrect="off"
    type="text" />

  <label for="email">Email</label>
  <input
    id="email"
    name="email"
    autocomplete="email"
    autocapitalize="off"
    autocorrect="off"
    spellcheck="false"
    type="text" />

  <label for="comment">Comment</label>
  <textarea id="comment" name="comment"></textarea>

  <input value="Comment" type="submit" />
</div>


It is recommended to use <form> instead.
HTML
Copy to Clipboard
<form id="send-comment" aria-label="Add a comment">…</form>

Accessibility concerns

Use sparingly

Landmark roles are intended to identify larger overall sections of the document. Using too many landmark roles can create "noise" in screen readers, making it difficult to understand the overall layout of the page.
Inputs are not forms

You do not need to declare role="form" on every form element (inputs, text areas, selects, etc.). It should be declared on the HTML element that wraps the form elements. Ideally, use the <form> element as the wrapping element and do not declare role="form".
Search

If a form is used to search, you should use the more specialized role="search" value.
Labeling landmarks

Each <form> element and form role that needs to be exposed as a landmark must be given an accessible name. This name will allow an assistive technology user to be able to quickly understand the purpose of the form landmark.
Use an aria-labelledby, aria-label or title on the same element that was given the role="form" to provide it an accessible name.
Using role="form"
HTML
Copy to Clipboard
<div role="form" id="gift-cards" aria-label="Purchase a gift card">
  <!-- form content -->
</div>

Redundant descriptions

Screen readers will announce the type of role the landmark is. Because of this, you do not need to describe what the landmark is in its label. For example, a declaration of role="form" with an of aria-label="Contact form" may be announced redundantly as, "contact form form".
Best practices

Prefer HTML

Using the <form> element will automatically communicate a section has a role of form. If at all possible, prefer using it instead.

--------------------------------------------------

ARIA role/attribute name: ARIA: generic role

The generic role creates a nameless container element which has no semantic meaning on its own.

Note: The generic role is the implicit role of generic elements used by user agents. It is included here for completeness of documentation. It should not be used by web authors.

Description

While ARIA is primarily used to express semantics, there are some elements that shouldn't expose a semantic name to assistive technologies. The generic role indicates an element's role is equivalent to that of the non-semantic <div> and <span> elements.
The generic role is intended for use as the implicit role of generic elements in host languages for use by user agents only; not for use by developers. Instead, to remove implicit accessibility semantics, use presentation or none, the <div> and <span> elements that have no semantic meaning, or semantic container roles such as group to semantically group descendants in a named container.
Like an element with role presentation, an element with role="generic" can provide a limited number of accessible states and properties for its descendants, such as aria-live attributes. However, unlike elements with role presentation, generic elements are exposed in accessibility APIs so that assistive technologies can gather certain properties such as layout and bounds.
Because the generic role is nameless, the aria-labelledby and aria-label attributes are prohibited. Because the role is generic, the aria-roledescription and aria-brailleroledescription attributes are also prohibited.
Note: The element with role="generic" should not have an accessible name or role description.
Associated WAI-ARIA roles, states, and properties

None. If a global ARIA state and property is set, generic or none will be ignored, and the implicit role of the element will be used.
Examples

This role is for use by user agents and not by developers. As such, no appropriate example exists.

--------------------------------------------------

ARIA role/attribute name: ARIA: grid role

The grid role is for a widget that contains one or more rows of cells. The position of each cell is significant and can be focused using keyboard input.

Description

The grid role is a composite widget containing a collection of one or more rows with one or more cells where some or all cells in the grid are focusable by using methods of two-dimensional navigation, such as directional arrow keys.
HTML
Copy to Clipboard
<table role="grid" aria-labelledby="id-select-your-seat">
  <caption id="id-select-your-seat">
    Select your seat
  </caption>
  <tbody role="presentation">
    <tr role="presentation">
      <td></td>
      <th>Row A</th>
      <th>Row B</th>
    </tr>
    <tr>
      <th scope="row">Aisle 1</th>
      <td tabindex="0">
        <button id="1a" tabindex="-1">1A</button>
      </td>
      <td tabindex="-1">
        <button id="1b" tabindex="-1">1B</button>
      </td>
      <!-- More Columns -->
    </tr>
    <tr>
      <th scope="row">Aisle 2</th>
      <td tabindex="-1">
        <button id="2a" tabindex="-1">2A</button>
      </td>
      <td tabindex="-1">
        <button id="2b" tabindex="-1">2B</button>
      </td>
      <!-- More Columns -->
    </tr>
  </tbody>
</table>


A grid widget contains one or more rows with one or more cells of thematically related interactive content. While it does not imply a specific visual presentation, it implies a relationship among elements. Uses fall into two categories: presenting tabular information (data grids) and grouping other widgets (layout grids). Even though both data grids and layout grids employ the same ARIA roles, states, and properties, differences in their content and purpose surface factors that are important to consider in keyboard interaction design. See ARIA Authoring Practices Guide for more details.
Cell elements have the role gridcell, unless they are a row or column header, in which case, the elements are rowheader and columnheader, respectively. Cell elements need to be owned by elements with a row role. Rows can be grouped using the rowgroup role.
If the grid is used as an interactive widget, keyboard interactions need to be implemented.
Associated ARIA roles, states, and properties
Roles
treegrid (subclass)

If a grid has columns that can expanded or collapsed, a treegrid can be used.
row

A row inside the grid.
rowgroup

A group containing one or multiple rows.
States and properties
aria-level

Indicates the hierarchical level of the grid within other structures.
aria-multiselectable

If aria-multiselectable is set to true, multiple items in the grid can be selected. The default value is false.
aria-readonly

If the user can navigate the grid but not change the value or values of the grid, the aria-readonly should be set to true. The default value is false.
Note: For many use cases, an HTML <table> element is sufficient as it and the various table elements already include many ARIA roles.
Keyboard interactions

When a keyboard user encounters a grid, they navigate the rows and columns using the left, right, top and down keys. To activate the interactive component, they will use the return and space keys.
Key	Action
→	Moves focus one cell to the right. Optionally (layout grids), if focus is on the right-most cell in the row, focus may move to the first cell in the following row. If focus is on the last cell in the grid, focus does not move.
←	Moves focus one cell to the left. Optionally (layout grids), if focus is on the left-most cell in the row, focus may move to the last cell in the previous row. If focus is on the first cell in the grid, focus does not move.
↓	Moves focus one cell down. Optionally (layout grids), if focus is on the bottom cell in the column, focus may move to the top cell in the following column. If focus is on the last cell in the grid, focus does not move.
↑	Moves focus one cell up. Optionally (layout grids), if focus is on the top cell in the column, focus may move to the bottom cell in the previous column. If focus is on the first cell in the grid, focus does not move.
Page Down	Moves focus down an author-determined number of rows, typically scrolling so the bottom row in the currently visible set of rows becomes one of the first visible rows. If focus is in the last row of the grid, focus does not move.
Page Up	Moves focus up an author-determined number of rows, typically scrolling so the top row in the currently visible set of rows becomes one of the last visible rows. If focus is in the first row of the grid, focus does not move.
Home	Moves focus to the first cell in the row that contains focus.
End	Moves focus to the last cell in the row that contains focus.
ctrl + Home	Moves focus to the first cell in the first row.
ctrl + End	Moves focus to the last cell in the last row.
If cells, rows, or columns can be selected, the following key combination are commonly used:

Key combination	Action
ctrl + Space	Select the column that contains the focus.
shift + Space	Selects the row that contains the focus. If the grid includes a column with checkboxes to select rows, this key combination can be used to check that box even if the focus is not on the checkbox.
ctrl + A	Selects all cells.
shift + →	Extends selection one cell to the right.
shift + ←	Extends selection one cell to the left.
shift + ↓	Extends selection one cell down.
shift + ↑	Extends selection one cell up.
Examples

Calendar example
Play
HTML
HTML
Copy to Clipboard
Play
<table role="grid" aria-labelledby="calendarheader">
  <caption id="calendarheader">
    September 2018
  </caption>
  <thead role="rowgroup">
    <tr role="row">
      <td></td>
      <th role="columnheader" aria-label="Sunday">S</th>
      <th role="columnheader" aria-label="Monday">M</th>
      <th role="columnheader" aria-label="Tuesday">T</th>
      <th role="columnheader" aria-label="Wednesday">W</th>
      <th role="columnheader" aria-label="Thursday">T</th>
      <th role="columnheader" aria-label="Friday">F</th>
      <th role="columnheader" aria-label="Saturday">S</th>
    </tr>
  </thead>
  <tbody role="rowgroup">
    <tr role="row">
      <th scope="row" role="rowheader">Week 1</th>
      <td>26</td>
      <td>27</td>
      <td>28</td>
      <td>29</td>
      <td>30</td>
      <td>31</td>
      <td role="gridcell" tabindex="-1">1</td>
    </tr>
    <tr role="row">
      <th scope="row" role="rowheader">Week 2</th>
      <td role="gridcell" tabindex="-1">2</td>
      <td role="gridcell" tabindex="-1">3</td>
      <td role="gridcell" tabindex="-1">4</td>
      <td role="gridcell" tabindex="-1">5</td>
      <td role="gridcell" tabindex="-1">6</td>
      <td role="gridcell" tabindex="-1">7</td>
      <td role="gridcell" tabindex="-1">8</td>
    </tr>
    <tr role="row">
      <th scope="row" role="rowheader">Week 3</th>
      <td role="gridcell" tabindex="-1">9</td>
      <td role="gridcell" tabindex="-1">10</td>
      <td role="gridcell" tabindex="-1">11</td>
      <td role="gridcell" tabindex="-1">12</td>
      <td role="gridcell" tabindex="-1">13</td>
      <td role="gridcell" tabindex="-1">14</td>
      <td role="gridcell" tabindex="-1">15</td>
    </tr>
    <tr role="row">
      <th scope="row" role="rowheader">Week 4</th>
      <td role="gridcell" tabindex="-1">16</td>
      <td role="gridcell" tabindex="-1">17</td>
      <td role="gridcell" tabindex="-1">18</td>
      <td role="gridcell" tabindex="-1">19</td>
      <td role="gridcell" tabindex="-1">20</td>
      <td role="gridcell" tabindex="-1">21</td>
      <td role="gridcell" tabindex="-1">22</td>
    </tr>
    <tr role="row">
      <th scope="row" role="rowheader">Week 5</th>
      <td role="gridcell" tabindex="-1">23</td>
      <td role="gridcell" tabindex="-1">24</td>
      <td role="gridcell" tabindex="-1">25</td>
      <td role="gridcell" tabindex="-1">26</td>
      <td role="gridcell" tabindex="-1">27</td>
      <td role="gridcell" tabindex="-1">28</td>
      <td role="gridcell" tabindex="-1">29</td>
    </tr>
    <tr role="row">
      <th scope="row" role="rowheader">Week 6</th>
      <td role="gridcell" tabindex="-1">30</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
      <td>5</td>
      <td>6</td>
    </tr>
  </tbody>
</table>

CSS
CSS
Copy to Clipboard
Play
table {
  margin: 0;
  border-collapse: collapse;
  font-variant-numeric: tabular-nums;
}

tbody th,
tbody td {
  padding: 5px;
}

tbody td {
  border: 1px solid #000;
  text-align: right;
  color: #767676;
}

tbody td[role="gridcell"] {
  color: #000;
}

tbody td[role="gridcell"]:hover,
tbody td[role="gridcell"]:focus {
  background-color: #f6f6f6;
  outline: 3px solid blue;
}

JavaScript
JS
Copy to Clipboard
Play
const selectables = document.querySelectorAll('table td[role="gridcell"]');

selectables[0].setAttribute("tabindex", 0);

const trs = document.querySelectorAll("table tbody tr");
let rowIndex = 0;
let colIndex = 0;
let maxRow = trs.length - 1;
let maxCol = 0;

trs.forEach((row) => {
  row.querySelectorAll("td").forEach((el) => {
    el.dataset.row = rowIndex;
    el.dataset.col = colIndex;
    colIndex++;
  });
  if (colIndex > maxCol) {
    maxCol = colIndex - 1;
  }
  colIndex = 0;
  rowIndex++;
});

function moveTo(newRow, newCol) {
  const tgt = document.querySelector(
    `[data-row="${newRow}"][data-col="${newCol}"]`,
  );
  if (tgt?.getAttribute("role") === "gridcell") {
    document.querySelectorAll("[role=gridcell]").forEach((el) => {
      el.setAttribute("tabindex", "-1");
    });
    tgt.setAttribute("tabindex", "0");
    tgt.focus();
    return true;
  } else {
    return false;
  }
}

document.querySelector("table").addEventListener("keydown", (event) => {
  const col = parseInt(event.target.dataset.col, 10);
  const row = parseInt(event.target.dataset.row, 10);
  switch (event.key) {
    case "ArrowRight": {
      const newRow = col === 6 ? row + 1 : row;
      const newCol = col === 6 ? 0 : col + 1;
      moveTo(newRow, newCol);
      break;
    }
    case "ArrowLeft": {
      const newRow = col === 0 ? row - 1 : row;
      const newCol = col === 0 ? 6 : col - 1;
      moveTo(newRow, newCol);
      break;
    }
    case "ArrowDown":
      moveTo(row + 1, col);
      break;
    case "ArrowUp":
      moveTo(row - 1, col);
      break;
    case "Home": {
      if (event.ctrlKey) {
        let i = 0;
        let result;
        do {
          let j = 0;
          do {
            result = moveTo(i, j);
            j++;
          } while (!result);
          i++;
        } while (!result);
      } else {
        moveTo(row, 0);
      }
      break;
    }
    case "End": {
      if (event.ctrlKey) {
        let i = maxRow;
        let result;
        do {
          let j = maxCol;
          do {
            result = moveTo(i, j);
            j--;
          } while (!result);
          i--;
        } while (!result);
      } else {
        moveTo(
          row,
          document.querySelector(
            `[data-row="${event.target.dataset.row}"]:last-of-type`,
          ).dataset.col,
        );
      }
      break;
    }
    case "PageUp": {
      let i = 0;
      let result;
      do {
        result = moveTo(i, col);
        i++;
      } while (!result);
      break;
    }
    case "PageDown": {
      let i = maxRow;
      let result;
      do {
        result = moveTo(i, col);
        i--;
      } while (!result);
      break;
    }
    case "Enter": {
      console.log(event.target.textContent);
      break;
    }
  }
  event.preventDefault();
});

More examples
Data Grid Examples
Layout Grids Examples
W3C/WAI Tutorial: Tables

Accessibility concerns

Even if the keyboard use is properly implemented, some users might not be aware that they have to use the arrow keys. Make sure that the functionality and interaction needed can be best achieved using the grid role.

--------------------------------------------------

ARIA role/attribute name: ARIA: gridcell role

The gridcell role is used to make a cell in a grid or treegrid. It is intended to mimic the functionality of the HTML <td> element for table-style grouping of information.

HTML
Copy to Clipboard
<div role="gridcell">Potato</div>
<div role="gridcell">Cabbage</div>
<div role="gridcell">Onion</div>


Elements that have role="gridcell" applied to them must be the child of an element with a role of row.

HTML
Copy to Clipboard
<div role="row">
  <div role="gridcell">Jane</div>
  <div role="gridcell">Smith</div>
  <div role="gridcell">496-619-5098</div>
  …
</div>


The first rule of ARIA is if a native HTML element or attribute has the semantics and behavior you require, use it instead of re-purposing an element and adding ARIA. Instead use the HTML <td> element:

HTML
Copy to Clipboard
<td>Potato</td>
<td>Cabbage</td>
<td>Onion</td>

Description

gridcells with dynamically added, hidden, or removed rows and columns

Any element with a role="gridcell" applied to it should use ARIA to describe its order in the table-style grouping, provided the table, grid, or treegrid has the ability to have rows and/or columns dynamically added, hidden, or removed.
Use aria-colindex to describe a gridcell's order in the list of columns, and aria-rowindex to describe a gridcell's order in the list of rows. Use aria-colcount and aria-rowcount on the parent element with role="grid" applied to it to set the total number of columns or rows.
This sample code demonstrates a table-style grouping of information where the third and fourth columns have been removed. aria-colindex is being used to describe the rows' position and allows a person using assistive technology to infer that certain rows have been removed:

HTML
Copy to Clipboard
<div role="grid" aria-colcount="6">
  <div role="rowgroup">
    <div role="row">
      <div role="columnheader" aria-colindex="1">First name</div>
      <div role="columnheader" aria-colindex="2">Last name</div>
      <div role="columnheader" aria-colindex="5">City</div>
      <div role="columnheader" aria-colindex="6">Zip</div>
    </div>
  </div>
  <div role="rowgroup">
    <div role="row">
      <div role="gridcell" aria-colindex="1">Debra</div>
      <div role="gridcell" aria-colindex="2">Burks</div>
      <div role="gridcell" aria-colindex="5">New York</div>
      <div role="gridcell" aria-colindex="6">14127</div>
    </div>
  </div>
  …
</div>

Describing the position of gridcells when the overall structure is unknown

In situations where the table-style grouping of content does not provide information about the columns and rows, gridcells must have their positions programmatically described by using aria-describedby. The ids provided for aria-describedby should correspond to parent elements intended to be the rows and columns.
By referencing the parent elements with roles of rowheader or columnheader applied to them via aria-describedby, it allows assistive technology to understand the position and relationship of the gridcell element to the rest of the table-style grouping of content.
Interactive grids and treegrids
Editable cells

Both <td> elements and elements with a role of gridcell applied to them can be made editable, mimicking functionality similar to editing a spreadsheet. This is done by applying the HTML contenteditable attribute.
HTML
Copy to Clipboard
<td contenteditable="true">Notes</td>

<div role="gridcell" contenteditable="true">Item cost</div>


contenteditable will make the element it is applied to focusable via the Tab key. If a gridcell is conditionally toggled into a state where editing is prohibited, toggle aria-readonly on the gridcell element.
Expandable cells

In a treegrid, gridcells may be made expandable by toggling the aria-expanded attribute. Note that if this attribute is provided, it applies only to the individual gridcell.
Associated WAI-ARIA Roles, States, and Properties
grid

Communicates that a parent element is a table or tree style grouping of information.
row

Required to communicate the gridcell is part of a row of a table-style grouping of information.
columnheader

Specifies which element is the associated column header.
aria-colindex

Identifies the position of an element in relation to the rest of the table-style grouping of information's columns.
rowheader

Specifies which element is the associated row header.
aria-rowindex

Identifies the position of an element in relation to the rest of the table-style grouping of information's rows.
Examples

The following example creates a table-style grouping of information:

HTML
Copy to Clipboard
<h3 id="table-title">Jovian gas giant planets</h3>
<div role="grid" aria-describedby="table-title">
  <div role="rowgroup">
    <div role="row">
      <div role="columnheader">Name</div>
      <div role="columnheader">Diameter (km)</div>
      <div role="columnheader">Length of day (hours)</div>
      <div role="columnheader">Distance from Sun (10<sup>6</sup>km)</div>
      <div role="columnheader">Number of moons</div>
    </div>
  </div>
  <div role="rowgroup">
    <div role="row">
      <div role="gridcell">Jupiter</div>
      <div role="gridcell">142,984</div>
      <div role="gridcell">9.9</div>
      <div role="gridcell">778.6</div>
      <div role="gridcell">67</div>
    </div>
  </div>
  <div role="rowgroup">
    <div role="row">
      <div role="gridcell">Saturn</div>
      <div role="gridcell">120,536</div>
      <div role="gridcell">10.7</div>
      <div role="gridcell">1433.5</div>
      <div role="gridcell">62</div>
    </div>
  </div>
</div>

Accessibility concerns

Support for gridcell and certain gridcell related ARIA roles and properties have poor support with assistive technologies. If at all possible, use HTML table markup in their place.
Best practices

The first rule of ARIA is: if a native HTML element or attribute has the semantics and behavior you require, use it instead of re-purposing an element and adding an ARIA role, state or property to make it accessible. As such, it is recommended to use native HTML table markup instead of recreating a table's form and functionality with ARIA and JavaScript.

--------------------------------------------------

ARIA role/attribute name: ARIA: group role

The group role identifies a set of user interface objects that is not intended to be included in a page summary or table of contents by assistive technologies.

Description

Most closely related to HTML's <fieldset> element, the group document structure role is used to identify a set of user interface objects which, as compared to region, is not intended to be included in the page's summary or table of contents.
The group role should be used to form a logical collection of items with related functionality, such as children in a tree widget forming a collection of siblings in a hierarchy, or a collection of items having the same container in a directory.
When a group is used in the context of list, limit the children of the group to listitem elements. In this case, it is recommended to use multiple ordered or unordered lists, <ol> or <ul>, with nested <li> children.
When used in the context of a listbox, the only children allowed are <option> elements. In this case, it is recommended to use <select>, <option> and <optgroup> instead.
Group elements may be nested.
The group role should not be used for major perceivable sections of a page. If a section is significant enough that it should be included in the page's table of contents, use the region role or a standard landmark role.
When the role is added to an element, the browser will send out an accessible group event to assistive technology products, which can then notify the user about it.
Examples

The HTML code example below uses the group role with a tree view:

HTML
Copy to Clipboard
<div id="tree1" role="tree" tabindex="-1">
  <div
    id="animals"
    class="groupHeader"
    role="presentation"
    aria-owns="animalGroup"
    aria-expanded="true">
    <img role="presentation" tabindex="-1" src="images/treeExpanded.gif" />
    <span role="treeitem" tabindex="0">Animals</span>
  </div>
  <div id="animalGroup" role="group">
    <div id="birds" role="treeitem">
      <span tabindex="-1">Birds</span>
    </div>
    <div
      id="cats"
      class="groupHeader"
      role="presentation"
      aria-owns="catGroup"
      aria-expanded="false">
      <img role="presentation" tabindex="-1" src="images/treeContracted.gif" />
      <span role="treeitem" tabindex="0">Cats</span>
    </div>
    <div id="catGroup" role="group">
      <div id="siamese" role="treeitem">
        <span tabindex="-1">Siamese</span>
      </div>
      <div id="tabby" role="treeitem">
        <span tabindex="-1">Tabby</span>
      </div>
    </div>
  </div>
</div>


The following example uses the group role with a drop-down menu containing menuitems:

HTML
Copy to Clipboard
<div role="menu">
  <ul role="group">
    <li role="menuitem">Inbox</li>
    <li role="menuitem">Archive</li>
    <li role="menuitem">Trash</li>
  </ul>
  <ul role="group">
    <li role="menuitem">Custom Folder 1</li>
    <li role="menuitem">Custom Folder 2</li>
    <li role="menuitem">Custom Folder 3</li>
  </ul>
  <ul role="group">
    <li role="menuitem">New Folder</li>
  </ul>
</div>


This menu could be constructed using <select> and <option> elements. In this case, the group role would be most similar to the <optgroup> element.

--------------------------------------------------

ARIA role/attribute name: ARIA: heading role

The heading role defines this element as a heading to a page or section, with the aria-level attribute providing for more structure.

Description

The heading role indicates to assistive technologies that this element should be treated like a heading. Screen readers would read the text and indicate that it is formatted like a heading. In addition, the level tells assistive technologies which part of the page structure this heading represents. A level 1 heading, indicated with aria-level="1", usually indicates the main heading of a page, a level 2 heading, defined with aria-level="2" the first subsection, a level 3 is a subsection of that, and so on.
HTML
Copy to Clipboard
<div role="heading" aria-level="1">This is a main page heading</div>


This defines the text in the <div> to be the main heading of the page, indicated by being level 1 via the aria-level attribute. Opt for using the h1 (through h6) element instead.
HTML
Copy to Clipboard
<h1>This is a main page heading</h1>

Associated WAI-ARIA roles, states, and properties
aria-level

The aria-level attribute specifies the heading level in the document structure. If no level is present, a value of 2 is the default.
Keyboard interactions

This role does not require any special keyboard navigation. As with any heading, giving it an ID ensures it can be referenced from anchor links, making it accessible via the keyboard.
Required JavaScript features
Required event handlers

None.
Changing attribute values

Usually not required, unless dynamically inserting content. In that case, the newly-added headings need aria-level attributes whose values are consistent with the rest of the document structure.
Note: Instead of using a <div> or <span> with a heading role and aria-level, consider using a native h1 through h6 elements instead to indicate that this text is a heading, and what part of the structure it represents.
Examples

The following shows a typical page structure.
HTML
Copy to Clipboard
<div id="container">
  <div role="heading" aria-level="1">The main page heading</div>
  <p>This article is about showing a page structure.</p>
  <div role="heading" aria-level="2">Introduction</div>
  <p>An introductory text.</p>
  <div role="heading" aria-level="2">Chapter 1</div>
  <p>Text</p>
  <div role="heading" aria-level="3">Chapter 1.1</div>
  <p>More text in a sub section.</p>
</div>


However, instead, you should do:

HTML
Copy to Clipboard
<div id="container">
  <h1>The main page heading</h1>
  <p>This article is about showing a page structure.</p>
  <h2>Introduction</h2>
  <p>An introductory text.</p>
  <h2>Chapter 1</h2>
  <p>Text</p>
  <h3>Chapter 1.1</h3>
  <p>More text in a sub section.</p>
</div>

Accessibility concerns

Warning: Using aria-label or aria-labelledby will hide the content of your heading from assistive technologies, reading the label instead of the heading.
If you must use the heading role and aria-level attribute, do not go over level 6 so that you are consistent with HTML. Although theoretically you can go higher, and some screen readers may support it, the results can be unpredictable with other browser and screen reader combinations.
Best practices

The best way to use this role is to not use it at all, and instead use the native heading tags h1 through h6 as shown in the example above. The heading role and aria-level attribute should only be used to retrofit accessibility on legacy code that you cannot make major changes to.
Instead of using the ARIA heading role, use the semantic HTML element:

HTML Element	heading role
h1	<div role="heading" aria-level="1">
h2	<div role="heading" aria-level="2">
h3	<div role="heading" aria-level="3">
h4	<div role="heading" aria-level="4">
h5	<div role="heading" aria-level="5">
h6	<div role="heading" aria-level="6">

Added benefits

None.
Precedence order

The heading role overrides the native semantic meaning of the element it is being used for. The aria-level attribute, in addition, determines what level of heading is being exposed.

--------------------------------------------------

ARIA role/attribute name: ARIA: img role

The ARIA img role can be used to identify multiple elements inside page content that should be considered as a single image. These elements could be images, code snippets, text, emojis, or other content that can be combined to deliver information in a visual manner.

HTML
Copy to Clipboard
<div role="img" aria-label="Description of the overall image">
  <img src="graphic1.png" alt="" />
  <img src="graphic2.png" />
</div>

Description

Any set of content that should be consumed as a single image (which could include images, video, audio, code snippets, emojis, or other content) can be identified using role="img".
You shouldn't count on the alt text of individual images for conveying context to assistive technologies; most screen readers will consider the element with role="img" set on it to be like a black box, and not access the individual elements inside it. Therefore, provide a comprehensive overall descriptive alt text for image, either in the surrounding text, or by using an aria-label attribute, with alt attributes for search engines or sighted users to be written to the page should an image fail:

HTML
Copy to Clipboard
<div role="img" aria-label="Description of the overall image">
  <img src="graphic1.png" alt="alternative text" />
  <img src="graphic2.png" alt="in case the images don't load" />
</div>


If you wish to add a caption or label to your image that is visible on the page, you can do using:

aria-labelledby when the text is a concise label.
aria-describedby when the text is a longer description.
For example:

HTML
Copy to Clipboard
<div role="img" aria-labelledby="image-1">
  …
  <p id="image-1">Text that describes the group of images.</p>
</div>


If an image is purely presentational, consider using the presentation role.
SVG and role="img"

If you are using embedded SVG images in your page, it is a good idea to set role="img" on the outer <svg> element and give it a label. This will cause screen readers to just consider it as a single entity and describe it using the label, rather than trying to read out all the child nodes:

HTML
Copy to Clipboard
<svg role="img" aria-label="Description of your SVG image">
  <!-- contents of the SVG image -->
</svg>

Using role="img" to confer meaning that is obscured or implied

In certain cases, assistive technology users won't be able to get the meaning of content expressed in certain ways, through certain media, or implied in certain ways. This is obvious to fix in the case of images (you can use the alt attribute), but in the case of mixed or other certain types of content it is not so obvious, and role="img" can come into play.
For example, if you use emojis in your text, the meaning might be obvious to a sighted user, but someone using a screen reader might get confused because the emojis might have either no text representation at all, or the alternative text might be confusing and not match the context it is being used in. For example, take the following code:

HTML
Copy to Clipboard
<div role="img" aria-label="That cat is so cute">
  <p>&#x1F408; &#x1F602;</p>
</div>


&#x1F408; &#x1F602;, 🐈 and 😂, are entity references for emojis read out as "Cat" and "Face with tears of joy", but this doesn't necessarily make sense — the implied meaning is possibly more like "That cat is so cute", so we include that in an aria-label along with role="img".
This seems to work OK across some browser/screen reader combinations, but some of them end up reading the label out twice. Use with caution and test thoroughly.
Another example where this might be suitable is when using ASCII emoji combinations, like the legendary "Table flip":

HTML
Copy to Clipboard
<div role="img" aria-label="Table flip">
  <p>(╯°□°）╯︵ ┻━┻</p>
</div>


If aria-labelledby were used, the screen reader would read it. In this case, only the contents of the aria-label are announced to screen reader users, hiding the gibberish of the characters without the need for descendant ARIA to hide things, but also hiding potential content that may be part of the image.
All descendants are presentational

There are some types of user interface components that, when represented in a platform accessibility API, can only contain text. Accessibility APIs do not have a way of representing semantic elements contained in an img. To deal with this limitation, browsers, automatically apply role presentation to all descendant elements of any img element as it is a role that does not support semantic children.
For example, consider the following img element, which contains a heading.
HTML
Copy to Clipboard
<div role="img"><h3>Title of my image</h3></div>


Because descendants of img are presentational, the following code is equivalent:

HTML
Copy to Clipboard
<div role="img"><h3 role="presentation">Title of my image</h3></div>


From the assistive technology user's perspective, the heading does not exist since the previous code snippets are equivalent to the following in the accessibility tree.:

HTML
Copy to Clipboard
<div role="img">Title of my image</div>

Associated WAI-ARIA Roles, States, and Properties
aria-label or aria-labelledby

An accessible name is required. For the HTML <img> element, use the alt attribute. For all other elements with the img role, use aria-labelledby if a visible label is present, otherwise use aria-label.
Examples
HTML
Copy to Clipboard
<span role="img" aria-label="Rating: 4 out of 5 stars">
  <span>★</span>
  <span>★</span>
  <span>★</span>
  <span>★</span>
  <span>☆</span>
</span>


--------------------------------------------------

ARIA role/attribute name: ARIA: input role

The input abstract role is a generic type of widget that allows user input.

Note: The input role is an abstract role. It is included here for completeness of documentation. It is not to be used by web authors.

Description

The input role is an abstract role. It must not be used by web authors. It is the superclass for input widgets that provide for user input, including checkbox, radio, and textbox. For all three, consider using the <input> element of type checkbox, radio and text, respectively.
Best Practices

Do not use.

--------------------------------------------------

ARIA role/attribute name: ARIA: landmark role

A landmark is an important subsection of a page. The landmark role is an abstract superclass for the aria role values for sections of content that are important enough that users will likely want to be able to navigate directly to them.

Note: The landmark role is an abstract role. It is included here for completeness of documentation. It should not be used by web authors.

Description

A landmark is an abstract role for a section of content that is important enough that users will likely want to be able to navigate to the section easily and have it included in a dynamically generated summary of the page. Landmarks allow assistive technologies to navigate and to find content quickly.
To create a landmark role, define the purpose of the content by using a semantic element such as <section>, <nav>, or <main>, or adding an ARIA role that is a subclass of the landmark role such as role="banner", role="complementary", or role="region". Do not use role="landmark".
A visible label should be provided, referenced with aria-labelledby. If necessary, brief, descriptive, label can be provided with aria-label.
For screen reader users, adding landmark roles effectively creates 'skip links' for screen reader users, but don't replace in page navigation as the landmark roles are not otherwise surfaced.
Best Practices

Do not use role="landmark". Do use HTML and subclass landmark roles.
Landmarks ensure content is in navigable regions. Use <main> for role="main", <header> for role="banner", <nav> for role="navigation", and <footer> for role="contentinfo". It is also good practice to include the role redundantly with the associated semantic element. It is not as good practice to use non-semantic elements, such as <div>, adding semantics with landmark roles. But do include one or the other or both. Otherwise, your content is no longer as navigable for screen reader users.

--------------------------------------------------

ARIA role/attribute name: ARIA: link role

A link widget provides an interactive reference to a resource. The target resource can be either external or local; i.e., either outside or within the current page or application.

Note: Where possible, it is recommended that you use a native <a> element rather than the link role, as native elements are more widely supported by user agents and assistive technology. Native <a> elements also support keyboard and focus requirements by default, without need for additional customization.

Description

The link role is used to identify an element that creates a hyperlink to a resource that is in the application or external.
When not using semantic HTML for its intended purpose, interactive features must be re-implemented. For example, when role="link" is added to an element, the tab key should enable giving focus to the link and the enter key should execute the link when focused.
Use the tabindex attribute with a value of 0 to ensure the link is in the correct tab focus order.
Warning: Applying the link role to an element will not cause browsers to enhance the element with standard link appearance or behaviors, such as underlining, focus rings, navigation to the link target, or context menu actions. That's the developer's responsibility.
Examples

To recreate an accessible link using the link role on an element that is not an <a>, you need to ensure the link receives focus in the correct tab order, that the element looks like a link, and that the "link" behaves like a link.
HTML
Copy to Clipboard
<span data-href="https://mozilla.org" tabindex="0" role="link">
  Fake accessible link created using a span
</span>

CSS
CSS
Copy to Clipboard
span[role="link"] {
  color: blue;
  text-decoration: underline;
  cursor: pointer;
}
span[role="link"]:hover,
span[role="link"]:active,
span[role="link"]:focus {
  color: purple;
}

span[role="link"]:focus {
  background-color: palegoldenrod;
  outline: 1px dotted;
}

JavaScript
JS
Copy to Clipboard
const fakeLinks = document.querySelectorAll('[role="link"]');

for (let i = 0; i < fakeLinks.length; i++) {
  fakeLinks[i].addEventListener("click", navigateLink);
  fakeLinks[i].addEventListener("keydown", navigateLink);
}

// handles click and keydown events on the link
function navigateLink(e) {
  if (e.type === "click" || e.key === "Enter") {
    const ref = e.target ?? e.srcElement;
    if (ref) {
      window.open(ref.getAttribute("data-href"), "_blank");
    }
  }
}


If the element with role="link" receives an Enter key event, this executes the link, going to the linked page or moving focus to the in page target.
Optionally, Shift + F10 opens a context menu for the link.
Best practices

The various widget roles are used to define common interactive patterns. Similar to the document-structure roles, some of these roles, including the link role, duplicate the semantics of native HTML elements that are well supported, and should not be used.
Avoid using link, which we've included for completeness. The <a> semantic equivalent with accessible interactivity is available and supported.
Prefer HTML

Using the <a> instead.
Note: There is no need to include role="link" on an HTML link as the <a>, by default, has that role already.

--------------------------------------------------

ARIA role/attribute name: ARIA: list role

The ARIA list role can be used to identify a list of items. It is normally used in conjunction with the listitem role, which is used to identify a list item contained inside the list.

HTML
Copy to Clipboard
<div role="list">
  <div role="listitem">List item 1</div>
  <div role="listitem">List item 2</div>
  <div role="listitem">List item 3</div>
</div>

Description

Any content that consists of an outer container with a list of elements inside can be identified to assistive technologies using the list and listitem containers, respectively. A list can only contain zero or more listitem children.
There are no hard and fast rules about which elements you should use to mark up the list and list items, but you should make sure that the list items make sense in the context of a list, e.g. a shopping list, recipe steps, driving directions.
Note: Best practices dictate using the appropriate semantic HTML elements over ARIA roles to mark up lists and listitems — <ul>, <ol> and <li>. See Best practices for a full example.
Associated WAI-ARIA Roles, States, and Properties
listitem role

A single item in a list. Elements with role listitem can only be found in an element with the role list.
Best practices

Only use role="list" and role="listitem" if you have to — for example if you don't have control over your HTML but are able to improve accessibility dynamically after the fact with JavaScript.
Unlike the HTML <ol> and <ul>, the ARIA list roles doesn't distinguish between ordered and unordered lists. If at all possible, you should use the appropriate semantic HTML elements to mark up a list (<ol> and <ul>) and list items (<li>). For example, our above example should be rewritten as follows:

HTML
Copy to Clipboard
<ul>
  <li>List item 1</li>
  <li>List item 2</li>
  <li>List item 3</li>
</ul>


or use an ordered list if the order of the list items matters:

HTML
Copy to Clipboard
<ol>
  <li>List item 1</li>
  <li>List item 2</li>
  <li>List item 3</li>
</ol>


Note: The ARIA list / listitem roles don't distinguish between ordered and unordered lists.
As an aside, note that if you are using the semantic HTML elements of <ol> or <ul> and apply a role of presentation, each child <li> element inherits the presentation role because ARIA requires the listitem elements to have the parent list element. So, the <li> elements are not exposed to assistive technologies, but elements contained inside of those <li> elements, including nested lists, are visible to assistive technologies.
Note: If you are marking up a list of items that will function as a tabbed interface, you should instead use the tab, tabpanel, and tablist roles.

--------------------------------------------------

ARIA role/attribute name: ARIA: listbox role

The listbox role is used for lists from which a user may select one or more items which are static and, unlike HTML <select> elements, may contain images.

Description

The listbox role is used to identify an element that creates a list from which a user may select one or more static items, similar to the HTML <select> element. Unlike <select>, a listbox can contain images. Listboxes contain children whose role is option or elements whose role is group which in turn contain children whose role is option.
It is highly recommended using the HTML select element, or a group of radio buttons if only one item can be selected, or a group of checkboxes if multiple items can be selected, because there is a lot of keyboard interactivity to manage focus for all the descendants, and native HTML elements provide this functionality for you for free.
Elements with the role listbox have an implicit aria-orientation value of vertical.
When a list is tabbed to, the first item in the list will be selected if nothing else already is. Up/down arrows navigate the list, and pressing Shift + Up/Down arrows will move and extend the selection. Typing one or more letters will navigate the list items (same letter goes to each item starting with that, different letters go to the first item starting with that entire string). If the current item has an associated context menu, Shift+F10 will launch that menu. If list items are checkable, Space can be used to toggle checkboxes. For selectable list items, Space toggles their selection, Shift+Space can be used to select contiguous items, Ctrl+Arrow moves without selecting, and Ctrl+Space can be used to select non-contiguous items. It is recommended that a checkbox, link or other method be used to select all items, and Ctrl+A could be used as a shortcut key for this.
When the listbox role is added to an element, or such an element becomes visible, screen readers announce the label and role of the listbox when it gets focus. If an option or item is focused within the list, it gets announced next, followed by an indication of the item's position with the list if the screen reader supports this. As focus moves within the list, the screen reader announces the relevant items.
Associated ARIA roles, states, and properties
Associated Roles
option role

One or more nested options are required. All selected options have aria-selected set to true. All options that are not selected have aria-selected set to false. If an option is not selectable, omit the aria-selected.
list role

A section containing listitem elements

States and Properties
aria-activedescendant

Holds the id string of the currently active element within the listbox. If that's an option element, then that would be the id of the most recently interacted with option, regardless of whether that option has an aria-selected value of true or not. Takes the value of only one id, even in a multiselectable listbox. If the id does not refer to a DOM descendant of the listbox, then that id must be included among the IDs in the aria-owns attribute.
aria-owns

This is a space-separated list of element IDs which are not DOM child elements of the listbox. IDs listed here cannot also be listed in aria-owns attributes of any other elements.
aria-multiselectable

Include and set to true if the user can select more than one option. If set to true, every selectable option should have an aria-selected attribute included and set to true or false. Options which are not selectable should not have the aria-selected attribute. If false or omitted, only the currently selected option, if any option is selected, needs the aria-selected attribute, and it must be set to true.
aria-required

A Boolean attribute which indicates that an option with a non-empty string value must be selected.
aria-readonly

The user cannot change which options are selected or unselected, but the listbox is otherwise operable.
aria-label

A human-readable string value which identifies the listbox. If there's a visible label, then aria-labelledby should be used instead to refer to that label.
aria-labelledby

Identifies the visible element or elements in a space-separated list of element IDs which identify the listbox. If there's no visible label, then aria-label should be used instead to include a label. (Note: "labelled", with two L's, is the correct spelling based on the accessibility API conventions.)

aria-roledescription

A human-readable string value which more clearly identifies the role of the listbox. Screen readers will often read this value to the user after reading the label (if there is one), in place of saying "listbox".
Keyboard interactions

When a single-select listbox receives focus:

If none of the options are selected before the listbox receives focus, the first option receives focus. Optionally, the first option may be automatically selected.
If an option is selected before the listbox receives focus, focus is set on the selected option.
When a multi-select listbox receives focus:

If none of the options are selected before the listbox receives focus, focus is set on the first option and there is no automatic change in the selection state.
If one or more options are selected before the listbox receives focus, focus is set on the first option in the list that is selected.
Down Arrow

: Moves focus to the next option. Optionally, in a single-select listbox, selection may also move with focus.
Up Arrow

: Moves focus to the previous option. Optionally, in a single-select listbox, selection may also move with focus.
Home

(Optional): Moves focus to first option. Optionally, in a single-select listbox, selection may also move with focus. Supporting this key is strongly recommended for lists with more than five options.
End

(Optional): Moves focus to last option. Optionally, in a single-select listbox, selection may also move with focus. Supporting this key is strongly recommended for lists with more than five options.
Type-ahead is recommended for all listboxes, especially those with more than seven options:

Type a character: focus moves to the next item with a name that starts with the typed character.
Type multiple characters in rapid succession: focus moves to the next item with a name that starts with the string of characters typed.
Multiple Selection: Authors may implement either of two interaction models to support multiple selection: a recommended model that does not require the user to hold a modifier key, such as Shift or Control, while navigating the list or an alternative model that does require modifier keys to be held while navigating in order to avoid losing selection states.
Recommended selection model — holding modifier keys is not necessary:

Space: changes the selection state of the focused option.
Shift + Down Arrow (Optional): Moves focus to and toggles the selected state of the next option.
Shift + Up Arrow (Optional): Moves focus to and toggles the selected state of the previous option.
Shift + Space (Optional): Selects contiguous items from the most recently selected item to the focused item.
Control + Shift + Home (Optional): Selects the focused option and all options up to the first option. Optionally, moves focus to the first option.
Control + Shift + End (Optional): Selects the focused option and all options down to the last option. Optionally, moves focus to the last option.
Control + A (Optional): Selects all options in the list. Optionally, if all options are selected, it may also unselect all options.
Required JavaScript features
selecting an option in a single select listbox

When the user selects an option, the following must occur:

Deselect the previously selected option, setting the aria-selected to false, or removing the attribute altogether, changing the appearance of the newly unselected option to appear not selected.
Select the newly selected option, setting aria-selected="true" on the option and changing the appearance of the newly selected option to appear selected.
Update the aria-activedescendant value on the listbox to the id of the newly selected option
Visually handle the blur, focus, and selected states of the option
Toggling the state of an option in a multi select listbox

When the user clicks on an option, hits Space when focused on an option, or otherwise toggles the state of an option, the following must occur:

Toggle the aria-selected state of the currently focused option, changing the state of the aria-selected to true if it was false or false if it was true.
Change the appearance of the option to reflect its selected state
Update the aria-activedescendant value on the listbox to the ID of the option the user just interacted with, even if they toggled the option to be unselected.
Note: The first rule of ARIA use is you can use a native feature with the semantics and behavior you require already built in, instead of re-purposing an element and adding an ARIA role, state or property to make it accessible, then do so. The <select> element with descendant <option> elements handles all the needed interactions natively.
Examples

Example 1: A single select listbox that uses aria-activedescendant

The snippet below, using aria-activedescendant, shows how the listbox role is added directly into the HTML source code.
HTML
Copy to Clipboard
<p id="listbox1label" role="label">Select a color:</p>
<div
  role="listbox"
  tabindex="0"
  id="listbox1"
  aria-labelledby="listbox1label"
  onclick="return listItemClick(event);"
  onkeydown="return listItemKeyEvent(event);"
  onkeypress="return listItemKeyEvent(event);"
  aria-activedescendant="listbox1-1">
  <div role="option" id="listbox1-1" class="selected" aria-selected="true">
    Green
  </div>
  <div role="option" id="listbox1-2">Orange</div>
  <div role="option" id="listbox1-3">Red</div>
  <div role="option" id="listbox1-4">Blue</div>
  <div role="option" id="listbox1-5">Violet</div>
  <div role="option" id="listbox1-6">Periwinkle</div>
</div>


This could have more easily been handled with the native HTML <select> and <label> elements.
HTML
Copy to Clipboard
<label for="listbox1">Select a color:</label>
<select id="listbox1">
  <option selected>Green</option>
  <option>Orange</option>
  <option>Red</option>
  <option>Blue</option>
  <option>Violet</option>
  <option>Periwinkle</option>
</select>

More examples
Scrollable Listbox Example: Single-select listbox that scrolls to reveal more options, similar to HTML <select> with size attribute greater than one.
Listbox Example with Grouped Options: Single-select listbox with grouped options, similar to HTML <select> with the attribute size set to greater than "1" and options grouped with optgroup elements.
Example Listboxes with Rearrangeable Options: Examples of both single-select and multi-select listboxes with accompanying toolbars where options can be added, moved, and removed.
Best practices
To be keyboard-accessible, authors should manage focus of all descendants of this role.
It is recommended that authors use different styling for the selection when the list is not focused, e.g. a non-active selection is often shown with a lighter background color.
If the listbox is not part of another widget, it should have the aria-labelledby property set.
If one or more entries are not DOM children of listbox, additional aria-* properties will need to be set (see ARIA Best Practices).
If there is a valid reason to expand the listbox, the combobox role may be more appropriate.

--------------------------------------------------

ARIA role/attribute name: ARIA: listitem role

The ARIA listitem role can be used to identify an item inside a list of items. It is normally used in conjunction with the list role, which is used to identify a list container.

HTML
Copy to Clipboard
<section role="list">
  <div role="listitem">List item 1</div>
  <div role="listitem">List item 2</div>
  <div role="listitem">List item 3</div>
</section>

Description

Any content that consists of an outer container with a list of elements inside it can be identified to assistive technologies using the list and listitem containers respectively.
There are no hard and fast rules about which elements you should use to mark up the list and list items, but you should make sure that the list items make sense in the context of a list, e.g. a shopping list, recipe steps, driving directions.
Note: If at all possible in your work, you should use the appropriate semantic HTML elements to mark up a list and its listitems — <ul>/<ol> and <li>. See Best practices for a full example.
Associated WAI-ARIA Roles, States, and Properties
list

A list of items. Elements with role list must have one or more elements with the role listitem as children, a one or more elements with the role of group that have one or more elements with the listitem role as children.
group

A collection of related objects, limited to list items when nested in a list, not important enough to have their own place in a pages table of contents.
Best practices

Only use role="list" and role="listitem" if you have to — for example if you don't have control over your HTML but are able to improve accessibility dynamically after the fact with JavaScript.
If at all possible, you should use the appropriate semantic HTML elements to mark up a list and listitems — <ol>, <ul> and <li>. For example, our above example should be rewritten as follows:

HTML
Copy to Clipboard
<ul>
  <li>List item 1</li>
  <li>List item 2</li>
  <li>List item 3</li>
</ul>


or use an ordered list if the order of the list items matters:

HTML
Copy to Clipboard
<ol>
  <li>List item 1</li>
  <li>List item 2</li>
  <li>List item 3</li>
</ol>


Note: The ARIA list / listitem roles don't distinguish between ordered and unordered lists.
Note: Styling a list with list-style: none; in CSS removes the list semantics. Adding role="listitem" returns the semantics.
Note: If you are marking up a list of items that will function as a tabbed interface, you should instead use the tab, tabpanel, and tablist roles.

--------------------------------------------------

ARIA role/attribute name: ARIA: log role

The log role is used to identify an element that creates a live region where new information is added in a meaningful order and old information may disappear.

Description

A log is a type of live region where new information is added in meaningful order and old information may disappear. Examples include chat logs, messaging history, game log, or an error log. In contrast to other live regions, in this role there is a relationship between the arrival of new items in the log and the reading order. The log contains a meaningful sequence and new information is added only to the end of the log, not at arbitrary points.
In contrast to other types of live region, a log is sequentially ordered and new information is only added to the end of the log. When this role is added to an element, the browser will send out an accessible log event to assistive technology products which can then notify the user about it.
By default, updates contain only the changes to the live region and these are announced when the user is idle. Elements with the role log have an implicit aria-live value of polite. Where the user needs to hear the entire live region upon a change aria-atomic="true" should be set. To have announcements made as soon as possible and where the user may be interrupted, aria-live="assertive" can be set for more aggressive updates.
Associated WAI-ARIA roles, states, and properties
aria-atomic

Defines whether assistive technologies should present all, or only parts of, the changed region. Elements with the role log have an implicit aria-atomic value of false.
aria-live

Defines when assistive technology should inform the user of updates to content. Elements with the role log have an implicit aria-live value of polite, meaning screen readers will announce changes inside the log when the user is idle.
aria-label and aria-labelledby

The log is required to have an accessible name. Use aria-labelledby if a visible label is present, otherwise use aria-label.
Best Practices

With an area that has scrolling text, such as a stock ticker, the marquee role should be used instead.

--------------------------------------------------

ARIA role/attribute name: ARIA: main role

The main landmark role is used to indicate the primary content of a document. The main content area consists of content that is directly related to or expands upon the central topic of a document, or the main function of an application.

HTML
Copy to Clipboard
<div id="main" role="main">
  <h1>Avocados</h1>
  <!-- main section content -->
</div>


This is the main section of a document that discusses avocados. Subsections of this document could discuss their history, the different types, regions where they grow, etc.

Description

The main role is a navigational landmark role identifying the main content of a document. Landmarks can be used by assistive technology such as screen readers to quickly identify and navigate to large sections of the document.
By classifying and labeling sections of a page, structural information conveyed visually through layout can be represented programmatically. Screen readers use landmark roles to provide keyboard navigation to important sections of a page. For those navigating via landmark roles, the main role is an alternative for "skip to main content" links.
There should only be one main landmark role per document.
The <main> element has a role of main. Developers should use semantic HTML — in this case <main> — over using ARIA.
Associated ARIA roles, states, and properties
aria-owns

The aria-owns attribute establishes relationships in the accessibility layer that aren't present in the DOM. Documents and applications can be nested in the DOM, which may lead to having more than one main element as DOM descendants. If this is the case, include aria-owns to identify the relationship of the main to its document or application ancestor.
aria-label or aria-labelledby

Identify the accessible name with aria-labelledby if a visible header is present. Otherwise, including an aria-label can be helpful for orienting assistive technology users, especially in single-page applications where main content changes happen without generating a page load event.
Example
HTML
Copy to Clipboard
<body>
  <!-- primary navigation -->

  <div role="main">
    <h1>The First Indochina War</h1>
    <!-- article content -->
  </div>

  <!-- sidebar and footer -->
</body>

Accessibility concerns

Use only one main role per document

The main landmark role should only be used once per document.
If a document contains two main roles, say updating page content when triggered by JavaScript, the inactive main role's presence should be removed from assistive technology via techniques such as toggling the hidden attribute.
HTML
Copy to Clipboard
<main>
  <h1>Active `main` element</h1>
  <!-- content -->
</main>

<main hidden>
  <h1>Hidden `main` element</h1>
  <!-- content -->
</main>


It is also helpful to include an accessible name to help orient assistive technology users, especially in single-page applications where main content changes happen without generating a page load event. This can be added with aria-labelledby if there is an appropriate name in the content, or aria-label if not.
Best practices

Prefer HTML

Using the <main> element will automatically communicate a section has a role of main. If at all possible, prefer using it instead.
Skip navigation

Skip navigation, also known as "skipnav", is a technique that allows an assistive technology user to quickly bypass large sections of repeated content (main navigation, info banners, etc.). This allows the user to access the main content of the page faster.
Adding an id attribute to the element with a declaration of role="main" allows it to be a target of a skip navigation link users.
HTML
Copy to Clipboard
<body>
  <a href="#main-content">Skip to main content</a>

  <!-- navigation and header content -->

  <div id="main-content" role="main">
    <!-- main page content -->
  </div>
</body>


Which is the equivalent of:

HTML
Copy to Clipboard
<body>
  <a href="#main-content">Skip to main content</a>

  <!-- navigation and header content -->

  <main id="main-content">
    <!-- main page content -->
  </main>
</body>

WebAIM: "Skip Navigation" Links


--------------------------------------------------

ARIA role/attribute name: ARIA: mark role

The mark role denotes content which is marked or highlighted for reference or notation purposes, due to the content's relevance in the enclosing context.

Description

The mark role semantically denotes HTML elements containing text that is marked/highlighted for reference purposes. This is semantically equivalent to the HTML <mark> element. If possible, you should use this element instead.
Example uses for mark are the exact same as the <mark> element. They include highlighting text in a quotation which is of special interest but is not marked in the original source material, comparable to using a highlighter pen to mark passages of a print article and indicating portions of the content that are relevant to the user's current activity, such as highlighting text matches found by a search feature.
Don't use mark for purely decorative styling such as syntax highlighting.
The mark element should not be given an accessible name; both aria-label and aria-labelledby attributes are prohibited on mark.
Examples

In the following example we have a document section that has been commented. The commented section is marked up using <span role="mark">.
HTML
Copy to Clipboard
<p>
  The last half of the song is a slow-rising crescendo that peaks at the
  <span role="mark" aria-details="thread-1">end of the guitar solo</span>,
  before fading away sharply.
</p>

<div role="comment" id="thread-1" data-author="chris">
  <h3>Chris said</h3>
  <p class="comment-text">I really think this moment could use more cowbell.</p>
  <p><time datetime="2022-03-30T19:29">March 30 2022, 19:29</time></p>
</div>


The related comment is marked up using an HTML structure wrapped with a <div> containing role="comment".
To associate the comment with the text being commented, we need to wrap the commented text with an element containing the aria-details attribute, the value of which should be the ID of the comment.
Best practices

Prefer HTML

Using the <mark> element will automatically communicate a node has a role of mark. If at all possible, prefer using it instead.
Specifications

Will be part of WAI-ARIA 1.3, which is still being drafted.

--------------------------------------------------

ARIA role/attribute name: ARIA: marquee role

A marquee is a type of live region containing non-essential information which changes frequently.

Description

The marquee role defines an area as a type of live region that presents non-essential information that changes frequently. Examples of marquees include stock tickers and ad banners; information that is not necessarily sought out by the user that may be presented in any order. The main difference between a marquee and a log is that log information is presented in a meaningful order such as a by date.
Elements with the role marquee have an implicit aria-live value of off.
The marquee is required to have an accessible name. Use aria-labelledby if a visible label is present, otherwise use aria-label.
Associated WAI-ARIA roles, states, and properties
aria-live

Defines when assistive technology should inform the user of updates to content. Elements with the role marquee have an implicit aria-live value of off, meaning screen readers will not announce changes inside the marquee, even when the user is idle.
aria-label or aria-labelledby

The marquee is required to have an accessible name. Use aria-labelledby if a visible label is present, otherwise use aria-label.

--------------------------------------------------

ARIA role/attribute name: ARIA: math role

The math role indicates that the content represents a mathematical expression.

Description

Content with the role math is intended to be marked up in an accessible format such as MathML, or with another type of textual representation, which can be converted to an accessible format by the browser or a polyfill library.
Unfortunately, browser support for MathML is not universal. While using an image of a mathematical expression is not optimal, if you do use image, use the math role. Make sure any images of math are labeled by an alt attribute that describes the mathematical expression as it would be spoken.
If the math element has only presentational children and the accessible name is intended to convey the mathematical expression, use aria-label to provide a string that represents the expression. If the math element contains navigable content that conveys the mathematical expression and a visible label for the expression is present, use aria-labelledby. Otherwise, use aria-label to name the expression, e.g., aria-label="Pythagorean Theorem".
Examples

If you use image or non-semantic HTML to create an equation, use the math role.
a2 + b2 = c2

The above pythagorean theorem is written accessibly as:

HTML
Copy to Clipboard
<div role="math" aria-label="a^{2} + b^{2} = c^{2}">
  a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup>
</div>


Had an image been used, the alt attribute would be used along with the math role:

HTML
Copy to Clipboard
<img src="pythagorean_theorem.gif" alt="a^{2} + b^{2} = c^{2}" role="math" />


--------------------------------------------------

ARIA role/attribute name: ARIA: menu role

The menu role is a type of composite widget that offers a list of choices to the user.

Description

A menu generally represents a grouping of common actions or functions that the user can invoke. The menu role is appropriate when a list of menu items is presented in a manner similar to a menu on a desktop application. Submenus, also known as pop-up menus, also have the role menu.
While the term "menu" is a generically used term to describe site navigation, the menu role is for a list of actions or functions that require complex functionality, such as composite widget focus management and first-character navigation

A menu can be a permanently visible list of controls or a widget that can be made to open and close. A closed menu widget is usually opened, or made visible, by activating a menu button, choosing an item in a menu that opens a submenu, or by invoking a command, such as Shift + F10 in Windows which opens a context specific menu.
When a user activates a choice in a menu that has been opened, the menu usually closes. If the menu choice action invokes a submenu, the menu will remain open and the submenu is displayed.
When a menu opens, keyboard focus is placed on the first menu item. To be keyboard accessible, you need to manage focus for all descendants: all menu items within the menu are focusable. The menu button which opens the menu and the menu items, rather than the menu itself, are the focusable elements.
Menu items include menuitem, menuitemcheckbox, and menuitemradio. Disabled menu items are focusable but cannot be activated.
Menu items can be grouped in elements with the group role, and separated by elements with role separator. Neither group nor separator receive focus or are interactive.
If a menu is opened as a result of a context action, Escape or Enter may return focus to the invoking context. If focus was on the menu button, Enter opens the menu, giving focus to the first menu item. If focus is on the menu itself, Escape closes the menu and returns focus to the menu button or parent menubar item (or the context action that opened the menu).
Elements with the role menu have an implicit aria-orientation value of vertical. For horizontally oriented menu, use aria-orientation="horizontal".
If the menu is visually persistent, consider the menubar role instead.
Associated WAI-ARIA roles, states, and properties
menuitem, menuitemcheckbox, and menuitemradio roles

Roles of items contained in a containing menu or menubar, known collectively as "menu items". These must be able to receive focus.
group role

Menu items can be nested in a group

separator role

A divider that separates and distinguishes sections of content or groups of menu items within the menu

tabindex attribute

The menu container has tabindex set to -1 or 0 and each item in the menu has tabindex set to -1.
aria-activedescendant

Set to the ID of the focused item, if there is one.
aria-orientation

indicates whether the menu orientation is horizontal or vertical; defaults to vertical if omitted.
aria-label or aria-labelledby

The menu is required to have an accessible name. Use aria-labelledby if a visible label is present, otherwise use aria-label. Either include the aria-labelledby set to a the id to the menuitem or button that controls its display or use aria-label to define the label.
aria-owns

Only set on the menu container to include elements that are not DOM children of the container. If set, those elements will appear in the reading order in the sequence they are referenced and after any items that are DOM children. When managing focus, ensure the visual focus order matches this assistive technology reading order.
Keyboard interactions
Space / Enter

If the item is a parent menu item, it opens the submenu and moves focus to the first item in the submenu. Otherwise, activates the menu item, which loads new content and places focus on the heading that titles the content.
Escape

When in a submenu, it closes the submenu and moves focus to the parent menu or menubar item.
Right Arrow

In a menubar, moves focus to the next item in the menubar. If focus is on the last item, it moves focus to the first item. If in a submenu, if focus is on an item that does not have a submenu, it closes the submenu and moves focus to the next item in the menubar. Otherwise, it opens the submenu of the newly focused menubar item, keeping focus on that parent menubar item. If not in a menubar or submenu and not on a menuitem with a submenu, if focus is not the last focusable element in the menu, it optionally moves focus to the next focusable element.
Left Arrow

Moves focus to the previous item in the menubar. If focus is on the first item, it moves focus to the last item. If in a submenu, it closes the submenu and moves focus to the parent menu item. If not in a menubar or submenu, if focus is not the first focusable element in the menu, it optionally moves focus to the last focusable element.
Down Arrow

Opens submenu and moves focus to the first item in the submenu.
Up Arrow

Opens submenu and moves focus to the last item in the submenu.
Home

Moves focus to the first item in the menubar.
End

Moves focus to the last item in the menubar.
Any character key

Moves focus to the next item in the menubar having a name that starts with the typed character. If none of the items have a name starting with the typed character, focus does not move.
Examples

Below are two example menu implementations.
Example 1: navigation menu
HTML
Copy to Clipboard
<div>
  <button id="menubutton" aria-haspopup="true" aria-controls="menu">
    <img src="hamburger.svg" alt="Page Sections" />
  </button>
  <ul id="menu" role="menu" aria-labelledby="menubutton">
    <li role="presentation">
      <a role="menuitem" href="#description">Description</a>
    </li>
    <li role="presentation">
      <a
        role="menuitem"
        href="#associated_wai-aria_roles_states_and_properties">
        Associated WAI-ARIA roles, states, and properties
      </a>
    </li>
    <li role="presentation">
      <a role="menuitem" href="#keyboard_interactions">
        Keyboard interactions
      </a>
    </li>
    <li role="presentation">
      <a role="menuitem" href="#examples">Examples</a>
    </li>
    <li role="presentation">
      <a role="menuitem" href="#specifications">Specifications</a>
    </li>
    <li role="presentation">
      <a role="menuitem" href="#see_also">See Also</a>
    </li>
  </ul>
</div>


To progressively enhance this navigation widget that is by default accessible, the class to hide the menu and the inclusion of tabindex="-1" on the interactive menuitem content should be added with JavaScript on load.
When including a "menu" for site navigation, do not use the menu role. Rather, for the main site navigation use the native HTML <nav> element or simply a list of links. The menu role should be reserved for composite widgets requiring focus management. See ARIA practices for disclosure navigation for an explanation and additional examples.
Example 2: menubar submenu option picker

The following snippet of code is a popup menu nested in a menubar. It is displayed when the menu button is activated. It is a menu to select the text color from a list of color options:

HTML
Copy to Clipboard
<div>
  <button
    type="button"
    aria-haspopup="menu"
    aria-controls="colormenu"
    tabindex="0"
    aria-label="Text Color: purple">
    Purple
    <span></span>
  </button>
  <ul role="menu" id="colormenu" aria-label="Color Options" tabindex="-1">
    <li
      role="menuitemradio"
      aria-checked="true"
      style="color: purple"
      tabindex="-1">
      Purple
    </li>
    <li
      role="menuitemradio"
      aria-checked="false"
      style="color: magenta"
      tabindex="-1">
      Magenta
    </li>
    <li
      role="menuitemradio"
      aria-checked="false"
      style="color: black;"
      tabindex="-1">
      Black
    </li>
  </ul>
</div>


The button that opens the menu has aria-haspopup="menu" set, explicitly indicating that the popup it controls is a menu.
For a menu to open, the user generally interacts with a menu button as the opener. The menu button must be focusable and respond to both click and keyboard events. When focused, selecting Enter, Space, Down Arrow, or the Up Arrow should open the menu and place focus on a menu item.
The opening and closing of the menu toggles the aria-expanded="true" attribute on the button. It is added when the menu is open. Removed or set to false when the menu is closed. The true value indicates that the menu is displayed and that activating the menu button closes the menu.
When the menu is open, the button itself generally does not receive focus as users arrow through the menu items. Rather, Escape and optionally Shift + Tab closes the menu and returns focus to the menu button.
The menu role was set on the <ul>, identifying the <ul> element as a menu.
The showing and hiding of the menu can be done with CSS. For example, in these code examples we can use the attribute and next-sibling selectors to toggle the visibility of the menu:

CSS
Copy to Clipboard
[role="menu"] {
  display: none;
}
[aria-expanded="true"] + [role="menu"] {
  display: block;
}


The navigation example has a static button. The submenu example has a button that gets updated when the user selects a new value. In this case, the aria-label="Text Color: purple" is set on the menu element. It defines the accessible name for the menu as "Text color: purple"; identifying the purpose of the menu (selecting a text color) and the current value (purple). When a new color is selected, the value of the aria-label property should be updated as well.

--------------------------------------------------

ARIA role/attribute name: ARIA: menubar role

A menubar is a presentation of menu that usually remains visible and is usually presented horizontally.

Description

A menu is a widget that offers a list of choices to the user, such as a set of actions or functions. The menubar type of menu is usually presented as a persistently visible horizontal bar of commands. Menubars behave like native operating system menubars, such as the menubars containing pull down menus, commonly found at the top of many desktop application windows.
The menubar role is used to create a menu bar similar to those found near the top of the window in many desktop applications, visually persistent, typically horizontal, bar of menu items offering the user quick access to a consistent set of commands.
A menubar contains three types of menu items, including menuitem, menuitemradio and menuitemcheckbox. These menu items may optionally be nested in one or more group containers. Groups or items may optionally by separated with separator elements. While every menu item must be able to receive focus, even if disabled, the group and separator elements are not focusable.
An example of a native menubar is the bar which may be present at the top of the screen if you are reading this in a desktop browser. An example of a web-based menubar is the horizontal menu bar that reads "File Edit View Insert Format", etc., which is usually visible under the document name in a Google doc.
Menubar interactions should be similar to the typical menu bar interaction in a desktop graphical user interface. In Google Docs, each of those menu items is a menuitem with a popup submenu, so each has an aria-haspopup attribute set to true. The menubar element does not.
The menubar and all the menu items are focusable and have a tabindex attribute set. When the menubar receives focus through tabbing, keyboard focus is placed on the first menuitem. Each item in the menu has tabindex set to -1, except the first item has which has its tabindex set to 0.
If a menubar receives focus as a result of a context action, such as a shortcut key, Escape or Enter may return focus to the invoking context. That said, make sure not to create shortcut keys that interfere with user agent, operating system, or assistive technology shortcuts - any UA, OS, or AT.
Every menu item, no matter how deeply nested, is able to receive focus, even if disabled.
If a menubar has a visible label, include aria-labelledby set to a value that refers to the labelling element. Otherwise, provide the menubar with an accessible name by including a descriptive aria-label.
A menuitem element in the menubar can contain a child submenu of menu items. Submenus can be nested several deep. Generally, the outer menubar is horizontal and all the submenus are vertical. If this is not the case, if your menubar is vertical, include aria-orientation="vertical" on the menubar element. Otherwise, this attribute is not necessary, as the default value is horizontal.
Associated WAI-ARIA roles, states, and properties
group role

Identifies a set of menu items

menuitem role

An option in a set of choices contained by a menubar. May have a submenu.
menuitemradio role

A checkable menu item in a set of elements with the same role, only one of which can be checked at a time.
menuitemcheckbox role

a menu item with a checkable state whose possible values are true, false, or mixed.
aria-orientation

Include aria-orientation="vertical" on menubar element if it's the menubar is vertical. The default orientation is horizontal.
Keyboard interactions

When focus is in a menubar it is always on a menu item within the menu bar. When focus is on a top level menuitem in a menu bar, the following keyboard interactions must be supported:

Down Arrow

If the currently focused menuitem has a submenu, opens the submenu and places focus on the first item in the submenu.
Up Arrow

(Optional) If the currently focused menuitem has a submenu, opens the submenu and places focus on the last item in the submenu.
Right Arrow

Moves focus to the next item, optionally wrapping from the last to the first.
Left Arrow

Moves focus to the previous item, optionally wrapping from the first to the last.
Home

If arrow key wrapping is not supported, moves focus to the first item in the menubar.
End

If arrow key wrapping is not supported, moves focus to the last item in the menubar.
Tab

Moves focus to the next element in the tab sequence. If that makes it exit the menubar, all submenus in the menubar get closed.
shift + Tab

Moves focus to the previous element in the tab sequence. If that makes it exit the menubar, all submenus in the menubar get closed.
See menuitem keyboard interactions, menuitemradio keyboard interactions, and menuitemcheckbox keyboard interactions for more information on keyboard interactions when focus is on a menuitem in a menubar (which it always is).
Note: The above interactions assumed the menubar is horizontal. If the menubar is vertical, include aria-orientation="vertical" and change the following keyboard keys accordingly:

Down Arrow

Performs like the Right Arrow as described above.
Up Arrow

Performs like the Left Arrow as described above

Right Arrow

Performs like the Down Arrow as described above.
Left Arrow

Performs as the Up Arrow as described above

Examples
W3C WAI-ARIA practices: navigation menubar example
W3C WAI-ARIA practices: editor menubar example


--------------------------------------------------

ARIA role/attribute name: ARIA: menuitem role

The menuitem role indicates the element is an option in a set of choices contained by a menu or menubar.

Description

A menuitem is one of the three types of options in a set of choices contained by a menu or menubar; the other two being menuitemcheckbox and menuitemradio. The menuitem is only found as a descendant of, or owned by, elements with role menu or menubar, optionally nested within an element with role group that is contained in, or owned by, a menu.
If the menuitem is not a descendant of a menu in the DOM, include the aria-owns attribute on menu to indicate the relationship. If aria-owns is set on the menu container to include elements that are not DOM children of the container, those elements will appear in the reading order in the sequence they are referenced and after any items that are DOM children in supporting technologies. Ensure the visual focus order matches the assistive technology reading order.
Every menuitem in a menu is focusable, whether or not it is disabled. Indicate a menuitem is disabled by setting aria-disabled="true" on the element with the role.
If a menuitem has a submenu, program it to display a new sub-level menu when the menu item is activated and include aria-haspopup="menu" or with the true value to indicate to assistive technologies that the menu item is used to open a submenu.
A common convention for indicating that a menuitem launches a dialog box is to append "…" (ellipsis) to the menu item label, e.g., "Save as …".
Every menuitem must have an accessible name. This name comes from the element's contents by default. If the contents don't provide for a useful accessible name, aria-labelledby can be used to reference visible label. If no visible content is available to provide the accessible name, an accessible name can be provided with aria-label.
Associated WAI-ARIA roles, states, and properties
menu role

A widget providing a list of choices. Required context role (or menubar)

menubar role

A presentation of a menu that usually remains visible and is usually presented horizontally. Required context role (or menu)

group role

Can be used to identify a set of related menuitems within or otherwise owned by a menu or menubar

aria-disabled

Indicates the element is perceivable but disabled, so it is not operable

aria-haspopup

Indicates the availability and type of interactive popup that can be triggered by the menuitem

Keyboard interactions
Enter and Space

If the menuitem has a submenu, opens the submenu and places focus on its first item. Otherwise, activates the item and closes the menu.
Down Arrow

On a menuitem that has a submenu in a menubar, opens the submenu and places focus on the first item in the submenu. Otherwise, moves focus to the next item, optionally wrapping from the last to the first.
Up Arrow

Moves focus to the previous item, optionally wrapping from the first to the last. Optionally, if the menuitem is in a menubar and has a submenu, opens the submenu and places focus on the last item in the submenu.
Right Arrow

If in a menu opened with a menubutton and not in a menubar, if the menuitem does not have a submenu, does nothing. When focus is in a menubar, moves focus to the next item, optionally wrapping from the last to the first. When focus is in a menu and on a menuitem that has a submenu, opens the submenu and places focus on its first item. When focus is in a menu and on an item that does not have a submenu, closes the submenu and any parent menus, moves focus to the next item in the menubar, and, if focus is now on a menuitem with a submenu, either opens the submenu of that menuitem without moving focus into the submenu, or opens the submenu of that menuitem and places focus on the first item in the submenu.
Left Arrow

When focus is in a menubar, moves focus to the previous item, optionally wrapping from the first to the last. When focus is in a submenu of an item in a menu, closes the submenu and returns focus to the parent menuitem. When focus is in a submenu of an item in a menubar, closes the submenu, moves focus to the previous item in the menubar, and, if focus is now on a menuitem with a submenu, either opens the submenu of that menuitem without moving focus into the submenu, or opens the submenu of that menuitem and places focus on the first item in the submenu.
Home

If arrow key wrapping is not supported, moves focus to the first item in the current menu or menubar.
End

If arrow key wrapping is not supported, moves focus to the last item in the current menu or menubar.
Any key that corresponds to a printable character (Optional)

Move focus to the next item in the current menu whose label begins with that printable character.
Escape

Close the menu that contains focus and return focus to the element or context, e.g., menu button or parent menuitem, from which the menu was opened.
Tab

Moves focus to the next element in the tab sequence, and if the item that had focus is not in a menubar, closes its menu and all open parent menu containers.
Shift + Tab

Moves focus to the previous element in the tab sequence, and if the item that had focus is not in a menubar, closes its menu and all open parent menu containers.
If a menu is opened or a menu bar receives focus as a result of a context action, Escape or Enter may return focus to the invoking context.
Some implementations of navigation menubars may have menuitem elements that both perform a function and open a submenu. In such implementations, Enter and Space perform a navigation function while Down Arrow, in a horizontal menubar, opens the submenu associated with that same menuitem.
When items in a menubar are arranged vertically and items in menu containers are arranged horizontally the Down Arrow performs as Right Arrow is described above, the Up Arrow performs as Left Arrow is described above, and vice versa.
Examples
HTML
Copy to Clipboard
<div>
  <button id="menubutton" aria-haspopup="true" aria-controls="menu">
    <img src="hamburger.svg" alt="Page Sections" />
  </button>
  <ul id="menu" role="menu" aria-labelledby="menubutton">
    <li role="presentation">
      <a role="menuitem" href="#description">Description</a>
    </li>
    <li role="presentation">
      <a
        role="menuitem"
        href="#associated_wai-aria_roles_states_and_properties">
        Associated WAI-ARIA roles, states, and properties
      </a>
    </li>
    <li role="presentation">
      <a role="menuitem" href="#keyboard_interactions">
        Keyboard interactions
      </a>
    </li>
    <li role="presentation">
      <a role="menuitem" href="#examples">Examples</a>
    </li>
    <li role="presentation">
      <a role="menuitem" href="#specifications">Specifications</a>
    </li>
    <li role="presentation">
      <a role="menuitem" href="#see_also">See Also</a>
    </li>
  </ul>
</div>


--------------------------------------------------

ARIA role/attribute name: ARIA: menuitemcheckbox role

A menuitemcheckbox is a menuitem with a checkable state whose possible values are true, false, or mixed.

Description

The items in menu and menubars are menu items. There are three types of menu items: menuitem, menuitemradio, and menuitemcheckbox.
These three elements can only be contained in, or owned by, an element with role menu or menubar, optionally nested within a grouping element with role of group. Being nested or otherwise owned (see aria-owns) in a menu or menubar identifies the menu items as being related widgets.
Menu items, including menuitemcheckbox elements, may be grouped within group elements or separated by elements with the separator role or other equivalent native role such as <fieldset> and <hr>.
Menu items containing the role of menuitemcheckbox must include the aria-checked attribute to expose the checkbox's state to assistive technology, unless using <input type="checkbox">, in which case the checked attribute should be used.
Similar to the checked attribute of <input>s of type checkbox, the aria-checked attribute of a menuitemcheckbox indicates whether the menu item is checked (true), unchecked (false), or represents a sub-level menu of other menu items that have a mixture of checked and unchecked values (mixed). The mixed value is similar to the checkbox's indeterminate attribute, which gives the appearance of a third, neither checked nor unchecked, state.
An accessible name is required. Ideally, the accessible name should come from an associated <label> element if using <input type="checkbox"> or visible, descendant content. Realize if the label or descendant content is not sufficient and, preferably, aria-labelledby is used referencing non-descendant content or aria-label is used, these two ARIA properties will hide other descendant content from assistive technologies.
If all elements in the set are not present in the DOM include the aria-setsize and aria-posinset properties. When specifying aria-setsize and aria-posinset on a menuitemcheckbox, set the value with respect to the total number of items in the menu, excluding any separators.
The menuitemcheckbox element can have phrasing content, but can not have interactive content as descendants and no descendants with a tabindex attribute specified.
All descendants are presentational

There are some types of user interface components that, when represented in a platform accessibility API, can only contain text. Accessibility APIs do not have a way of representing semantic elements contained in a menuitemcheckbox. To deal with this limitation, browsers, automatically apply role presentation to all descendant elements of any menuitemcheckbox element as it is a role that does not support semantic children.
For example, consider the following menuitemcheckbox element, which contains a heading.
HTML
Copy to Clipboard
<div role="menuitemcheckbox"><h6>Name of my checkbox</h6></li>


Because descendants of menuitemcheckbox are presentational, the following code is equivalent:

HTML
Copy to Clipboard
<div role="menuitemcheckbox"><h6 role="presentation">Name of my checkbox</h6></li>


From the assistive technology user's perspective, the heading does not exist since the previous code snippets are equivalent to the following in the accessibility tree:

HTML
Copy to Clipboard
<div role="menuitemcheckbox">Name of my checkbox</div>

Associated WAI-ARIA roles, states, and properties
menu role

Widget that offers a list of common actions or functions the user can invoke.
menubar role

Similar to menu for a consistent set of frequently used commands remaining visible and usually presented horizontally.
group role

Container for a group of menuitem elements, including menuitemcheckbox elements within a menu or menubar.
aria-checked (Required)

Set to true, false, or mixed, it indicates the current "checked" state of the menuitemcheckbox

Keyboard interactions

When a menu opens, or when a menubar receives focus, keyboard focus is placed on the first item. All items in both are focusable, including all menuitemcheckbox elements.
If the menuitemcheckbox is in a submenu in a menubar or a menu opened with a menu button, the following keyboard interactions must be programmed in. :

Enter

Toggles the aria-checked state of the menuitemcheckbox and closes the menu.
Space

Toggles the aria-checked state of the menuitemcheckbox. Does not close the menu.
Escape

Closes menu. In menubar, moves focus to parent menubar item.
Right Arrow

Closes submenu. In menubar, moves focus to next item in the menubar, opening any submenu if there is one.
Left Arrow

Closes menu. In menubar, moves focus to previous item in the menubar, opening any submenu if there is one.
Down Arrow

Moves focus to the next item in the menu. If focus is on the last item, moves focus to the first item.
Up Arrow

Moves focus to previous item in the menu. If focus is on the first item, moves focus to the last item.
Home

Moves focus to the first item in the menu.
End

Moves focus to the last item in the menu.
Character

Moves focus to the next item having a name that starts with the typed character. If none of the items have a name starting with the typed character, focus does not move.
Required JavaScript
Required event handlers
onclick

Handle mouse clicks on both the checkbox and the associated label that will change the state of the checkbox by changing the value of the aria-checked attribute and the appearance of the checkbox so it appears checked or unchecked to the sighted user

onKeyDown

Handle the case where the user presses the Space key to change the state of the checkbox by changing the value of the aria-checked attribute and the appearance of the checkbox so it appears checked or unchecked to the sighted user. Also handles all keys listed in the keyboard navigation section above.
Examples
HTML
Copy to Clipboard
<li role="menuitemcheckbox" tabindex="-1" aria-checked="false">Purple</li>


The tabindex="-1" makes the menuitemcheckbox focusable but not part of the page tab sequence. Had we included aria-checked="true" it would have indicated that the menuitemcheckbox was checked, and we would have visually styled the selected state to look checked using the attribute selector [role='menuitemcheckbox'][aria-checked='true']. Instead, the presence of aria-checked="false" indicates to assistive technologies that the menuitemcheckbox is checkable but not currently checked. The accessible name "purple" comes from the contents.
The visual appearance of the selected state is a checked checkbox which we can create using generated content, making it visible and the same color as the content by synchronizing with the aria-checked value using CSS attribute selectors and inheriting the color.
CSS
Copy to Clipboard
[role="menuitemcheckbox"]::before {
  display: inline-block;
  content: "";
  color: transparent;
  width: 1em;
  text-align: center;
  outline: 1px solid;
  margin-inline-end: 2px;
  font-family: sans-serif;
}
[role="menuitemcheckbox"][aria-checked="true"]::before {
  color: inherit;
  content: "X";
}

Prefer HTML

The first rule of ARIA is: if a native HTML element or attribute has the semantics and behavior you require, use it instead of re-purposing an element and adding an ARIA role, state or property to make it accessible. As such, it is recommended to use the native HTML checkbox form control instead of recreating a checkbox's functionality with JavaScript and ARIA.

--------------------------------------------------

ARIA role/attribute name: ARIA: menuitemradio role

A menuitemradio is checkable menuitem in a set of elements with the same role, only one of which can be checked at a time.

Description

The items in menu and menubars are menu items. There are three types of menu items: menuitem, menuitemcheckbox, and menuitemradio. To limit the number of checked menu items to one within a group, use the menuitemradio role on all the elements in the group.
A menuitemradio is checkable menuitem in a set of elements with the same role, of which only can be checked at a time.
The three menu item elements can only be contained in, or owned by, an element with role menu or menubar, optionally nested within a grouping element with role of group. Being nested or otherwise owned (see aria-owns) in a menu or menubar identifies the menu items as being related widgets.
When all items in a submenu are members of the same radio group, the group is defined by the menu element; the group element is not necessary.
Menu items containing the role of menuitemradio must include the aria-checked attribute to expose the radio button's state to assistive technology, unless using <input type="radio">, in which case the checked attribute should be used.
Similar to the checked attribute of <input>s of type radio, the aria-checked attribute of a menuitemradio indicates whether the menu item is checked (true), unchecked (false). There is no mixed value like there is for menuitemcheckbox.
Only one menuitemradio in a group can be checked at the same time. When one item in the group is checked, the aria-checked attribute gets set to true, while the previously checked menuitemradio element in the same group, if there was one, becomes unchecked, by having the aria-checked attribute value switched to false.
If your want more than one item in a group to be checked, or if you want to enable checking and unchecking an item, consider using menuitemcheckbox.
If a menu or menubar contains more than one group of menuitemradio elements, or if the menu contains a group of menuitemradio elements as well as other, unrelated menuitem elements and/or menuitemcheckbox elements, contain each set of related menuitemradio elements in a group element or delimit the group the menuitemradio elements from the other menu items with a separator element (or an HTML element with an equivalent role such as a <fieldset> grouping or a thematic break <hr> separator.
An accessible name is required. Ideally, the accessible name should come from an associated <label> element if using <input type="radio"> or visible, descendant content. Realize if the label or descendant content is not sufficient and, preferably, aria-labelledby is used referencing non-descendant content or aria-label is used, these two ARIA properties will hide other descendant content from assistive technologies.
If all elements in the set are not present in the DOM include the aria-setsize and aria-posinset properties. When specifying aria-setsize and aria-posinset on a menuitemradio, set the value with respect to the total number of items in the menu, excluding any separators.
The menuitemradio element can have phrasing content, but can not have interactive content as descendants and no descendants with a tabindex attribute specified.
All descendants are presentational

There are some types of user interface components that, when represented in a platform accessibility API, can only contain text. Accessibility APIs do not have a way of representing semantic elements contained in a menuitemradio. To deal with this limitation, browsers, automatically apply role presentation to all descendant elements of any menuitemradio element as it is a role that does not support semantic children.
For example, consider the following menuitemradio element, which contains a heading.
HTML
Copy to Clipboard
<div role="menuitemradio"><h6>Name of my radio button</h6></li>


Because descendants of menuitemradio are presentational, the following code is equivalent:

HTML
Copy to Clipboard
<div role="menuitemradio"><h6 role="presentation">Name of my radio button</h6></li>


From the assistive technology user's perspective, the heading does not exist since the previous code snippets are equivalent to the following in the accessibility tree:

HTML
Copy to Clipboard
<div role="menuitemradio">Name of my radio button</div>

Associated WAI-ARIA roles, states, and properties
menu role

Widget that offers a list of common actions or functions the user can invoke.
menubar role

Similar to menu for a consistent set of frequently used commands remaining visible and usually presented horizontally.
group role

Container for a group of menuitem elements, including menuitemradio elements within a menu or menubar.
aria-checked (Required)

Set to true or false, it indicates the current "checked" state of the menuitemradio

Keyboard interactions

When a menu opens, or when a menubar receives focus, keyboard focus is placed on the first item. All items in both are focusable, including all menuitemradio elements.
If the menuitemradio is in a submenu in a menubar or a menu opened with a menu button, the following keyboard interactions must be programmed in. :

Enter

If not checked, checks the focused menuitemradio and unchecks any other checked menuitemradio element in the same group. Also, closes the menu.
Space

If not checked, checks the focused menuitemradio and unchecks any other checked menuitemradio element in the same group without closing the menu.
Escape

Closes menu. In menubar, moves focus to parent menubar item.
Right Arrow

Closes submenu. In menubar, moves focus to next item in the menubar, opening any submenu if there is one.
Left Arrow

Closes menu. In menubar, moves focus to previous item in the menubar, opening any submenu if there is one.
Down Arrow

Moves focus to the next item in the menu. If focus is on the last item, moves focus to the first item.
Up Arrow

Moves focus to previous item in the menu. If focus is on the first item, moves focus to the last item.
Home

Moves focus to the first item in the menu.
End

Moves focus to the last item in the menu.
Character

Moves focus to the next item having a name that starts with the typed character. If none of the items have a name starting with the typed character, focus does not move.
Required JavaScript
Required event handlers
onclick

Handle mouse clicks on both the radio button and the associated label that will change the state of the radio button by changing the value of the aria-checked attribute and the appearance of the radio button so it appears checked or unchecked to the sighted user

onKeyDown

Handle the case where the user presses the Space key to change the state of the radio button by changing the value of the aria-checked attribute and the appearance of the radio button so it appears checked or unchecked to the sighted user. Also handles all keys listed in the keyboard navigation section above.
Examples
HTML
Copy to Clipboard
<li role="menuitemradio" tabindex="-1" aria-checked="false">Purple</li>


The tabindex="-1" makes the menuitemradio focusable but not part of the page tab sequence. Had we included aria-checked="true" it would have indicated that the menuitemradio was checked, and we would have visually styled the selected state to look checked using the attribute selector [role='menuitemradio'][aria-checked='true']. Instead, the presence of aria-checked="false" indicates to assistive technologies that the menuitemradio is checkable but not currently checked. The accessible name "purple" comes from the contents.
The visual appearance of the selected state is a checked radio button which we can create using generated content, making it visible and the same color as the content by synchronizing with the aria-checked value using CSS attribute selectors and changing the background-color.
CSS
Copy to Clipboard
[role="menuitemradio"]::before {
  display: inline-block;
  content: "";
  width: 1em;
  height: 1em;
  padding: 0.1em;
  border: 2px solid #333;
  border-radius: 50%;
  box-sizing: border-box;
  background-clip: content-box;
  margin-inline-end: 2px;
}
[role="menuitemradio"][aria-checked="true"]::before {
  background-color: purple;
}


Don't use the background shorthand property, as that will override the background-clip property we used to create the radio button effect.
Prefer HTML

The first rule of ARIA is: if a native HTML element or attribute has the semantics and behavior you require, use it instead of re-purposing an element and adding an ARIA role, state or property to make it accessible. As such, it is recommended to use the native HTML radio button form control instead of recreating a radio button's functionality with JavaScript and ARIA.

--------------------------------------------------

ARIA role/attribute name: ARIA: meter role

The meter role is used to identify an element being used as a meter.

Note: Where possible, it is recommended that you use a native <meter> element rather than the meter role, as native elements are more widely supported by user agents and assistive technology.

Description

A meter is a graphical display of a numeric value within a defined range. For example, showing battery percentage. A meter is not appropriate for values that do not have a meaningful maximum limit. Meters should not be used to indicate progress (for example loading), this should be communicated with the <progress> element.
Each element with role="meter" must also have one of the following:

An aria-label attribute.
An aria-labelledby attribute pointing to an element with text that describes the meter.
All descendants are presentational

There are some types of user interface components that, when represented in a platform accessibility API, can only contain text. Accessibility APIs do not have a way of representing semantic elements contained in a meter. To deal with this limitation, browsers, automatically apply role presentation to all descendant elements of any meter element as it is a role that does not support semantic children.
For example, consider the following meter element, which contains a heading.
HTML
Copy to Clipboard
<div role="meter"><h3>Title of my meter</h3></div>


Because descendants of meter are presentational, the following code is equivalent:

HTML
Copy to Clipboard
<div role="meter"><h3 role="presentation">Title of my meter</h3></div>


From the assistive technology user's perspective, the heading does not exist since the previous code snippets are equivalent to the following in the accessibility tree.:

HTML
Copy to Clipboard
<div role="meter">Title of my meter</div>

Associated ARIA roles, states, and properties
aria-valuenow

Set to a decimal value between aria-valuemin and aria-valuemax indicating the current value of the meter.
aria-valuetext

Assistive technologies often present the value of aria-valuenow as a percentage. If this would not be accurate use this property to make the meter value understandable.
aria-valuemin

Set to a decimal value representing the minimum value, and less than aria-valuemax.
aria-valuemax

Set to a decimal value representing the maximum value, and greater than aria-valuemin.
It is recommended to use a native <meter> element rather than the meter role. User agents provide a stylize widget for the <meter> element based on the current value as it relates to the min and max values. When using non-semantic elements, all features of the native semantic element need to be recreated with ARIA attributes, JavaScript and CSS.
Examples

An example of a meter using role="meter":

HTML
Copy to Clipboard
<div
  role="meter"
  aria-valuenow="90"
  aria-valuemin="0"
  aria-valuemax="100"
  aria-labelledby="cpu_usage_label">
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" style="width: 90%">
    <rect x="0" y="0" width="100%" height="100%" fill="currentcolor"></rect>
  </svg>
</div>


In the above scenario, when the aria-valuenow value updates, the width of the SVG also needs to be updated as can be seen in the W3C working meter example.

--------------------------------------------------

ARIA role/attribute name: ARIA: navigation role

The navigation role is used to identify major groups of links used for navigating through a website or page content.

HTML
Copy to Clipboard
<div role="navigation" aria-label="Main">
  <!-- list of links to main website locations -->
</div>


This is a website's main navigation.

Description

The navigation role is a landmark role. Landmark roles provide a way to identify the organization and structure of a web page. By classifying and labeling sections of a page, structural information conveyed visually through layout is represented programmatically. Screen readers use landmark roles to provide keyboard navigation to important sections of a page. Like the HTML <nav> element, navigation landmarks provide a way to identify groups (e.g. lists) of links that are intended to be used for website or page content navigation. If a page includes more than one navigation landmark, each should have a unique label. If two or more navigational landmark on a page have the same set of links, use the same label for each.
It is preferable to use the HTML5 <nav> element to define a navigation landmark. If the HTML5 nav element technique is not being used, use a role="navigation" attribute to define a navigation landmark.
Note: Using the <nav> element will automatically communicate a section has a role of navigation. Developers should always prefer using the correct semantic HTML element over using ARIA

Associated WAI-ARIA Roles, States, and Properties
aria-label

A brief description of the purpose of the navigation, omitting the term "navigation", as the screen reader will read both the role and the contents of the label.
Keyboard Interactions

None.
Required JavaScript features

None.
Examples
HTML
Copy to Clipboard
<div role="navigation" aria-label="Customer service">
  <ul>
    <li><a href="#">Help</a></li>
    <li><a href="#">Order tracking</a></li>
    <li><a href="#">Shipping &amp; Delivery</a></li>
    <li><a href="#">Returns</a></li>
    <li><a href="#">Contact us</a></li>
    <li><a href="#">Find a store</a></li>
  </ul>
</div>

Accessibility concerns

Landmark roles are intended to be used sparingly, to identify larger overall sections of the document. Using too many landmark roles can create "noise" in screen readers, making it difficult to understand the overall layout of the page.
Best practices

Prefer HTML

Using the <nav> element will automatically communicate a section has a role of navigation. If at all possible, prefer using it instead.
Labeling landmarks
Multiple landmarks

If there is more than one navigation landmark role or <nav> element in a document, provide a label for each landmark. This label will allow an assistive technology user to be able to quickly understand the purpose of each landmark.
HTML
Copy to Clipboard
<div id="main-nav" role="navigation" aria-label="Main">
  <!-- content -->
</div>

…

<nav id="footer-nav" aria-label="Footer">
  <!-- content -->
</nav>

Repeated landmarks

If a navigation landmark role or <nav> element in a document is repeated in a document, and both landmarks have identical content, use the same label for each landmark. An example of this would be repeating the main navigation at the top and bottom of the page.
HTML
Copy to Clipboard
<header>
  <nav id="main-nav" aria-label="Main">
    <!-- list of links to main website locations -->
  </nav>
</header>

…

<footer>
  <nav id="footer-nav" aria-label="Main">
    <!-- list of links to main website locations -->
  </nav>
</footer>

Redundant descriptions

Screen readers will announce the type of role the landmark is. Because of this, you do not need to describe what the landmark is in its label. For example, a declaration of role="navigation" with an of aria-label="Primary navigation" may be announced redundantly as, "primary navigation navigation".

--------------------------------------------------


--------------------------------------------------

ARIA role/attribute name: ARIA: note role

A note role suggests a section whose content is parenthetic or ancillary to the main content.

Description

The note role can be added to parenthetic or ancillary content if no other native element or other role fits the purpose.
Associated WAI-ARIA roles, states, and properties
aria-label or aria-labelledby (optional)

Naming a note is optional, but can help screen reader users understand its context and purpose. The name can be provided using aria-labelledby if a visible label is present, otherwise with aria-label.
Examples
HTML
Copy to Clipboard
<h1>Madam C. J. Walker</h1>
<p>
  Madam C.J. Walker was an African American entrepreneur, philanthropist, and
  political and social activist.
</p>
<h2>Early Life</h2>
…
<h2>Career</h2>
…
<p role="note" class="highlight-box">
  At the height of the depression, Madam C. J. Walker trained 20,000 women to
  sell hair pomade door-to-door
</p>
<h2>Activism and Philanthropy</h2>
…


In the above Wikipedia style entry for Madam C.J. Walker, the highlight-box with role note could have been a <blockquote> if it contained a quote or <figcaption> in a <figure> if there was an associated image. In this case, as neither of those made sense, the note role was added to add semantics to the parenthetic content.

--------------------------------------------------

ARIA role/attribute name: ARIA: option role

The option role is used for selectable items in a listbox.

Description

The option role is used to identify selections a user can make in a listbox. These options are similar to the <option> elements in a <select> element, but they can contain images.
All selectable options should have aria-selected match their state, true when selected and false when not. If an option is not selectable, aria-selected can be omitted. A disabled option can have aria-disabled="true" and aria-selected="false" to communicate to the user that the option is present, albeit disabled.
The option role is for identifying selectable choices of a listbox. Options must be provided an accessible name. Generally, the accessible name for an option should come from the element's descendant content.
Authors can also explicitly provide an accessible name by specifying aria-label or aria-labelledby to the element with the option role. If using aria-label or aria-labelledby, and the option also displays a visible text label, authors must ensure they adhere to WCAG Success Criterion 2.5.3 Label in Name.
It is highly recommended to use a <select> element or an <input> element with the checkbox or radio type instead, when possible. These native HTML elements provide keyboard interactivity to manage focus for all the descendants for you automatically.
All descendants are presentational

There are some types of user interface components that, when represented in a platform accessibility API, can only contain text. Accessibility APIs do not have a way of representing semantic elements contained in a option. To deal with this limitation, browsers, automatically apply role presentation to all descendant elements of any option element as it is a role that does not support semantic children.
For example, consider the following option element, which contains a heading.
HTML
Copy to Clipboard
<div role="option"><h3>Title of my option</h3></div>


Because descendants of option are presentational, the following code is equivalent:

HTML
Copy to Clipboard
<div role="option"><h3 role="presentation">Title of my option</h3></div>


From the assistive technology user's perspective, the heading does not exist since the previous code snippets are equivalent to the following in the accessibility tree:

HTML
Copy to Clipboard
<div role="option">Title of my option</div>

Associated ARIA roles, states, and properties
Associated Roles
listbox

An option must be contained in or owned by a listbox

States and Properties
aria-selected

Used to describe the selection state of the option. Required.
aria-checked

Used to describe the checked state when options are used in a multiple selection fashion. Supports true, false and mixed. Optional.
aria-posinset

Used to describe the position in the set of options when it does not match the DOM, such as virtual scrolling where only some options are present at a time. Optional.
aria-setsize

Used in conjunction with aria-posinset to declare the total number of options. Optional.
aria-disabled

Used to indicate that the option is present but not editable. Optional.
aria-hidden

Used to hide the option from accessibility tools. It should only be used to hide non-visible content or visible content if it improves the experience of assistive technology, such as redundant content. Optional.
aria-invalid

Used to indicate that the value of the option is considered invalid by the application. Optional.
aria-busy

Used to indicate that an element is being modified, such as while it is loading. Optional.
aria-labelledby

Used to indicate which element labels the option. The content of the option should be used instead where appropriate. Optional.
aria-label

Used to label the option. If the label is present in the DOM, aria-labelledby should be used instead. Optional.
(For further details and a full list of ARIA states and properties see the ARIA option (role) documentation.)


--------------------------------------------------

ARIA role/attribute name: ARIA: presentation role

The presentation role and its synonym none remove an element's implicit ARIA semantics from being exposed to the accessibility tree.

The content of the element will still be available to assistive technologies; it is only the semantics of the container — and in some instance, required associated descendants — which will no longer expose their mappings to the accessibility API.

Description

While ARIA is primarily used to express semantics, there are some situations where hiding an element's semantics from assistive technologies is helpful. This is done with the presentation role or its synonym role none, which declare that an element is being used only for presentation and therefore does not have any accessibility semantics.
Writing <h2 role="presentation">Democracy Dies in Darkness</h2> removes the heading semantics of the h2 element, making it the equivalent of <div>Democracy Dies in Darkness</div>. The heading role semantics are removed, but the content itself is still available.
When an element has required descendants, such as the various <table>, elements and <li>s children of a <ul> or <ol>, the presentation or none role on the table or list removes the default semantics of the element on which it was applied and their required descendant elements.
If presentation or none is applied to a <table> element, the descendant <caption>, <thead>, <tbody>, <tfoot>, <tr>, <th>, and <td> elements inherit the role and are thus not exposed to assistive technologies. But, elements inside of the <th> and <td> elements, including nested tables, are exposed to assistive technologies.
HTML
Copy to Clipboard
<ul role="presentation">
  <li>
    <a href="#">Link 1</a>
  </li>
  <li>
    <a href="#">Link 2</a>
  </li>
  <li>
    <a href="#">Link 3</a>
  </li>
</ul>


Because the presentation role was applied to the <ul> element, every child <li> element inherits the presentation role. This is because ARIA requires the listitem elements to have a parent list element. While the <li> elements, in this case, are not exposed to assistive technologies, descendants of those required elements are exposed. If we had nested a list within one of those <li>'s, they would be visible to assistive technologies. For elements with no required children, any elements nested inside the element with role="presentation" or role="none" preserve their semantics. In this case, the <a> elements contained inside of those <li> elements are exposed.
The <a> is a special case. Its role would have been exposed even if it had the presentation or none role directly applied to it. Browsers ignore role="presentation" and role="none" on focusable elements, including link and inputs, or anything with a tabindex attribute set. Browsers also ignore the inclusion of the role if any of the element contains any global ARIA states and properties, such as aria-describedby.
Note: The element with role="presentation" is not part of the accessibility tree and should not have an accessible name. Do not use aria-labelledby or aria-label.
Associated WAI-ARIA roles, states, and properties

None. If a global ARIA state and property is set, presentation or none will be ignored, and the implicit role of the element will be used.
Examples
HTML
Copy to Clipboard
<hr role="none" />


--------------------------------------------------

ARIA role/attribute name: ARIA: progressbar role

The progressbar role defines an element that displays the progress status for tasks that take a long time.

Description

The progressbar range widget indicates that a request has been received and the application is making progress toward completing the requested action.
Authors may set aria-valuemin and aria-valuemax to indicate the minimum and maximum progress indicator values. Otherwise, their implicit values follow the same rules as HTML's <input type="range">:

If aria-valuemin is missing or not a number, it defaults to 0 (zero).
If aria-valuemax is missing or not a number, it defaults to 100.
The aria-valuemin and aria-valuemax properties only need to be set for the progressbar role when the progress bar's minimum is not 0 or the maximum value is not 100.
The read-only aria-valuenow should be provided and updated unless the value is indeterminate, in which case don't include the attribute. If set, make sure the aria-valuenow value is between the minimum and maximum values.
If the progressbar role is applied to an HTML <progress> element, the accessible name can come from the associated <label>. Otherwise use aria-labelledby if a visible label is present or aria-label if a visible label is not present.
All descendants are presentational

There are some types of user interface components that, when represented in a platform accessibility API, can only contain text. Accessibility APIs do not have a way of representing semantic elements contained in a progressbar. To deal with this limitation, browsers, automatically apply role presentation to all descendant elements of any progressbar element as it is a role that does not support semantic children.
For example, consider the following progressbar element, which contains a heading.
HTML
Copy to Clipboard
<div role="progressbar"><h3>Title of my progressbar</h3></div>


Because descendants of progressbar are presentational, the following code is equivalent:

HTML
Copy to Clipboard
<div role="progressbar">
  <h3 role="presentation">Title of my progressbar</h3>
</div>


From the assistive technology user's perspective, the heading does not exist since the previous code snippets are equivalent to the following in the accessibility tree:

HTML
Copy to Clipboard
<div role="progressbar">Title of my progressbar</div>

Associated WAI-ARIA roles, states, and properties
aria-valuenow

Only present and required if the value is not indeterminate. Set to a decimal value between 0, or aria-valuemin if present, and aria-valuemax indicating the current value of the progress bar.
aria-valuetext

Assistive technologies often present the value of aria-valuenow as a percentage. If this would not be accurate use this property to make the progress bar value understandable.
aria-valuemin

Set to a decimal value representing the minimum value, and less than aria-valuemax. If not present, the default value is 0.
aria-valuemax

Set to a decimal value representing the maximum value, and greater than aria-valuemin. If not present, the default value is 100.
aria-label or aria-labelledby

Defines the string value or identifies the element (or elements) that label the progressbar element providing an accessible name. An accessible name is required.
It is recommended to use a native <progress> or <input type="range"> elements rather than the progressbar role. User agents provide a stylize widget for the <progress> element based on the current value as it relates to the 0, the minimum value, and the max value. When using non-semantic elements, all features of the native semantic element need to be recreated with ARIA attributes, JavaScript and CSS.
Examples

In the example below, the progress bar uses the default values of 0 and 100 for aria-valuemin and aria-valuemax:

HTML
Copy to Clipboard
<div>
  <span id="loadinglabel">Loading:</span>
  <span role="progressbar" aria-labelledby="loadinglabel" aria-valuenow="23">
    <svg width="100" height="10">
      <rect height="10" width="100" stroke="black" fill="black" />
      <rect height="10" width="23" fill="white" />
    </svg>
  </span>
</div>


Using semantic HTML, this could be written as:

HTML
Copy to Clipboard
<label for="loadinglabel">Loading:</label>
<progress id="loadinglabel" max="100" value="23"></progress>

Best Practices

If the progress bar is describing the loading progress of a particular region of a page, include the aria-describedby attribute to reference the progress bar's status, and set the aria-busy attribute to true on the region until it is finished loading.
Prefer HTML

It is recommended to use a native <progress> or <input type="range"> elements rather than the progressbar role.

--------------------------------------------------

ARIA role/attribute name: ARIA: radio role

The radio role is one of a group of checkable radio buttons, in a radiogroup, where no more than a single radio button can be checked at a time.

Description

A radio button is a checkable input that when associated with other radio buttons, only one of which can be checked at a time. The radio buttons must be grouped together in a radiogroup to indicate which ones affect the same value.
HTML
Copy to Clipboard
<div role="radiogroup" aria-labelledby="legend25" id="radiogroup25">
  <p id="legend25">Ipsum and lorem?</p>
  <div>
    <span
      role="radio"
      aria-checked="false"
      tabindex="0"
      aria-labelledby="q25_radio1-label"
      data-value="True"></span>
    <label id="q25_radio1-label">True</label>
  </div>
  <div>
    <span
      role="radio"
      aria-checked="false"
      tabindex="0"
      aria-labelledby="q25_radio2-label"
      data-value="False"></span>
    <label id="q25_radio2-label">False</label>
  </div>
  <div>
    <span
      role="radio"
      aria-checked="true"
      tabindex="0"
      aria-labelledby="q25_radio3-label"
      data-value="huh?"></span>
    <label id="q25_radio3-label">What is the question?</label>
  </div>
</div>


The role attribute only adds semantics; all of the functionality that comes natively with the HTML radio needs to be added with JavaScript and the HTML tabindex attribute.
Note: The first rule of ARIA is if a native HTML element or attribute has the semantics and behavior you require, use it instead of re-purposing an element and adding ARIA. Instead use the native HTML <input type="radio"> (with an associated <label>), which natively provides all the functionality required:

HTML
Copy to Clipboard
<fieldset>
  <legend>Ipsum and lorem?</legend>
  <div>
    <input type="radio" value="True" id="q25_radio1" name="q25" />
    <label for="q25_radio1">True</label>
  </div>
  <div>
    <input type="radio" value="False" id="q25_radio2" name="q25" />
    <label for="q25_radio2">False</label>
  </div>
  <div>
    <input type="radio" value="huh?" id="q25_radio3" name="q25" checked />
    <label for="q25_radio3">What is the question?</label>
  </div>
</fieldset>


The native HTML radio form control (<input type="radio">) has two states ("checked" or "not checked"). Similarly, an element with role="radio" can expose two states through the aria-checked attribute: true representing the checked state, and false representing the unchecked state. The aria-checked value of mixed is not valid to use for a radio button.
If a radio button is checked, the radio element has aria-checked set to true. If it is not checked, it has aria-checked set to false.
Each radio button element has role radio. The radio role should always be nested with other associated radios in a radiogroup. If it is not possible to nest the radio button within a radio group, use the id of the non-grouped radio in a space separated list of values as the value of the aria-owns attribute on the radiogroup element to indicate the relationship of the radiogroup to its radio members.
Each radio element is labelled by its content, has a visible label referenced by aria-labelledby, or has a label specified with aria-label. The containing radiogroup element should either have a visible label referenced by aria-labelledby or a label specified with aria-label. If elements providing additional information about either the radio group or each radio button are present, those elements should be referenced by the radiogroup element or radio elements with the aria-describedby property.
As radio is an interactive control; it must be focusable and keyboard accessible. If the role is applied to a non-focusable element, use the tabindex attribute to change this. The expected keyboard shortcut for activating a radio is the Space key. Use JavaScript to toggle the aria-checked attribute to true when a radio becomes checked while ensuing that all the other radio roles in the group are set to aria-checked="false".
To programmatically indicate that a radio button must be chosen from a radio group the aria-required attribute, with a value of true, must be specified on the radiogroup element. It is not expected to use the aria-required attribute on individual ARIA radio buttons.
All descendants are presentational

There are some types of user interface components that, when represented in a platform accessibility API, can only contain text. Accessibility APIs do not have a way of representing semantic elements contained in a radio. To deal with this limitation, browsers, automatically apply role presentation to all descendant elements of any radio element as it is a role that does not support semantic children.
For example, consider the following radio element, which contains a heading.
HTML
Copy to Clipboard
<div role="radio"><h6>name of my radio</h6></div>


Because descendants of radio are presentational, the following code is equivalent:

HTML
Copy to Clipboard
<div role="radio"><h6 role="presentation">name of my radio</h6></div>


From the assistive technology user's perspective, the heading does not exist since the previous code snippets are equivalent to the following in the accessibility tree:

HTML
Copy to Clipboard
<div role="radio">name of my radio</div>

Associated WAI-ARIA Roles, States, and Properties
radiogroup role

The radio buttons are contained in or owned by an element with role radiogroup. If unable to be nested within a radiogroup within the markup, the aria-owns attribute of the radiogroup contains the id values of the non-nested radio buttons in the group.
aria-checked

The value of aria-checked defines the state of a radio. When used with radio elements, the attribute has one of two possible values:

true

The radio is checked.
false

The radio is not checked.
Note: Use the tabindex attribute if the role="radio" is used on an element that does not natively accept keyboard focus. E.g., a <div> or <span>.
Keyboard interactions
Tab + Shift

Move focus into and out of the radio group. When focus moves into a radio group, and a radio button is already checked, focus is set on the checked button. If none of the radio buttons are checked, focus is set on the first radio button in the group.
Space

Checks the radio if not already checked. Unchecks a previously checked radio button in the radio group.
Right Arrow and Down Arrow

Move focus to and checks the next radio button in the group, unchecking the previously focused radio button. If focus is on the last radio button, focus moves to the first radio button.
Left Arrow and Up Arrow

Move focus to and checks the previous radio button in the group, unchecking the previously focused radio button. If focus is on the first radio button, focus moves to the last radio button.
Radios in a toolbar

Because arrow keys are used to navigate among elements of a toolbar and the Tab key moves focus in and out of a toolbar, when a radio group is nested inside a toolbar, the keyboard interaction of the radio group is slightly different from that of a radio group that is not inside of a toolbar. See radiogroup keyboard interactions for more information

Required JavaScript
onClick

Handle mouse clicks on both the radio and the associated label that will change the state of the radio by changing the value of the aria-checked attribute and the appearance of the radio so it appears checked or unchecked to the sighted user

onKeyPress

Handle the case where the user presses the Space key to change the state of the radio by changing the value of the aria-checked attribute and the appearance of the radio so it appears checked or unchecked to the sighted user

Examples

The following example uses ARIA to modify otherwise generic elements to be exposed as radio buttons. CSS and JavaScript are used to visually and programmatically modify the checked or unchecked state of the element.
HTML
HTML
Copy to Clipboard
<div role="radiogroup" aria-labelledby="legend" id="radiogroup">
  <p id="legend">
    Should you be using the <code>radio</code> role or
    <code>&lt;input type="radio"></code>?
  </p>
  <div>
    <span
      role="radio"
      aria-checked="true"
      tabindex="0"
      aria-labelledby="ariaLabel"
      data-value="True"></span>
    <label id="ariaLabel">ARIA role</label>
  </div>
  <div>
    <span
      role="radio"
      aria-checked="false"
      tabindex="0"
      aria-labelledby="htmllabel"
      data-value="False"></span>
    <label id="htmllabel">HTML <code>&lt;input type="radio"></code></label>
  </div>
</div>

CSS
CSS
Copy to Clipboard
[role="radio"] {
  padding: 5px;
}

[role="radio"][aria-checked="true"]::before {
  content: "(x)";
  font-family: monospace;
}

[role="radio"][aria-checked="false"]::before {
  content: "( )";
  font-family: monospace;
}

JavaScript

A lot of JavaScript is required to make radio buttons out of non-semantic HTML.
JS
Copy to Clipboard
// initialize all the radio role elements

const radioGroups = document.querySelectorAll('[role="radiogroup"]');

for (let i = 0; i < radioGroups.length; i++) {
  const radios = radioGroups[i].querySelectorAll("[role=radio]");
  for (let j = 0; j < radios.length; j++) {
    radios[j].addEventListener("keydown", function () {
      handleKeydown();
    });
    radios[j].addEventListener("click", function () {
      handleClick();
    });
  }
}

// handle mouse and touch events
let handleClick = function (event) {
  setChecked(this);
  event.stopPropagation();
  event.preventDefault();
};

// handle key presses
let handleKeydown = function (event) {
  switch (event.code) {
    case "Space":
    case "Enter":
      currentChecked();
      break;

    case "ArrowUp":
    case "ArrowLeft":
      previousRadioChecked();
      break;

    case "ArrowDown":
    case "ArrowRight":
      nextItemChecked();
      break;

    default:
      break;
  }
  event.stopPropagation();
  event.preventDefault();
};

// when a radio is selected, give it focus, set checked to true;
// ensure all other radios in radio group are not checked

setChecked = function () {
  // uncheck all the radios in group
  // iterated through all the radios in radio group
  // eachRadio.tabIndex = -1;
  // eachRadio.setAttribute('aria-checked', 'false');
  // set the selected radio to checked
  // thisRadio.setAttribute('aria-checked', 'true');
  // thisRadio.tabIndex = 0;
  // thisRadio.focus();
  // set the value of the radioGroup to the value of the currently selected radio
};


No JavaScript (or even CSS) would be needed had we used semantic HTML element with the name of each radio button in a group of radio buttons being the same:

HTML
Copy to Clipboard
<fieldset>
  <legend>
    Should you be using the <code>radio</code> role or
    <code>&lt;input type="radio"></code>?
  </legend>
  <div>
    <input type="radio" name="bestPractices" id="ariaLabel" value="True" />
    <label for="ariaLabel">ARIA role</label>
  </div>
  <div>
    <input type="radio" name="bestPractices" id="htmllabel" value="False" />
    <label for="htmllabel">HTML <code>&lt;input type="radio"></code></label>
  </div>
</fieldset>

Best practices

The first rule of ARIA is: if a native HTML element or attribute has the semantics and behavior you require, use it instead of re-purposing an element and adding an ARIA role, state or property to make it accessible. As such, it is recommended to use native HTML radio button form controls instead of recreating a radio's functionality with JavaScript and ARIA.

--------------------------------------------------

ARIA role/attribute name: ARIA: radiogroup role

The radiogroup role is a group of radio buttons.

Description

Radio groups are collections describing a set of related radio options. A radiogroup is a type of select list that can only have a single entry, or radio, checked at any one time.
When using HTML's native input radio button, <input type="radio">, the radio buttons are grouped when each of input radio buttons in the group is given the same name. Once a group of same-named input radio buttons is established, selecting any input radio button in that group automatically deselects any currently-selected input radio button in the same group. While this will associate the radio buttons together, to expose a grouping of radio buttons as a radiogroup explicitly set the ARIA role.
It is recommended to create radio groups by using same-named HTML input radio buttons, but, if you must use ARIA roles and attributes instead of semantic HTML form controls, custom radio buttons can and should act like native HTML radio input buttons.
When using non-semantic elements as radio buttons, you must ensure your users can only select one radio button from the group at a time. When one item in the group is checked, having their aria-checked attribute set to true, the previously checked item becomes unchecked, with its aria-checked attribute becoming false. The aria-checked attribute is set on the associated radio roles, not on the radiogroup itself.
Some radiogroup implementations initialize the set with all buttons in the unchecked state. Once a radio in a radiogroup is checked, it is generally not possible to return to an all-unchecked state.
The radiogroup must have an accessible name either by a visible label referenced by aria-labelledby or has a label specified with aria-label. If elements provide additional information about the radio group, those elements are referenced by the radiogroup element with the aria-describedby property.
Associated WAI-ARIA roles, states, and properties
radio role

One of a group of checkable buttons, in a radiogroup, where no more than one of the buttons can be checked at a time.
aria-labelledby / aria-label

The radiogroup must have an accessible name either by a visible label referenced by aria-labelledby or has a label specified with aria-label.
aria-describedby

Reference to elements providing additional information about the radiogroup

aria-required

Indicates that one radio within the group must have aria-checked="true" set before the form may be submitted. The required state is specified on the radiogroup element rather than one of the radio elements, unlike when using HTML radio buttons where the required attribute is set directly on one or more radio <input> elements.
aria-errormessage

Identifies the element that provides an error message for the radiogroup, if there is an error. That message should be hidden while not relevant.
Keyboard interactions

For radio buttons in a radiogroup that is NOT in a toolbar, the following keyboard interactions must be supported:

Tab and Shift + Tab

Move focus into and out of the radiogroup. When focus moves into a radiogroup, if a radio button is checked, focus is set on the checked button. If none of the radio buttons are checked, focus is set on the first radio button in the group.
Space

Checks the focused radio button if it is not already checked.
Right Arrow and Down Arrow

Moves focus to the next radio button in the group, unchecking the previously focused button, and checking the newly focused button. If focus is on the last button, focus moves to the first button.
Left Arrow and Up Arrow

Moves focus to the previous radio button in the group, unchecking the previously focused button, and checking the newly focused button. If focus is on the first button, focus moves to the last button.
Arrow keys are used to navigate among elements of a toolbar. When a radiogroup is nested inside a toolbar, users need to be able to navigate among all toolbar elements, including the radio buttons, without changing which radio button is checked. So, when navigating through a radiogroup in a toolbar with arrow keys, the button that is checked does not change. Rather, when inside a toolbar, the Space and Enter keys check the focused radio button if it is not already checked, with Tab moving focus into and out of the toolbar.
Required JavaScript features

User interactions for radiogroups must replicate the user interaction of a user entering into a group of same-named HTML radio buttons. Keyboard events for tabs, space, and arrow keys must be captured. Click events on both the radio elements and their associated labels must also be captured. Additionally, focus must be managed.
While generally moving off an a focused element brings you to the next focusable element in the DOM order, using the arrow keys to navigate through a group of radio button keeps you in the group, moving focus to the first radio button when the Right Arrow or Down Arrow is released when focus was on the last radio in the group, and moving to the last radio if the Left Arrow or Up Arrow is released if focus was on the first radio. Managing roving tabindex is one method to manage arrow key events.
Required CSS features

Use the [aria-checked="true"] attribute selector to style the checked state of checked radio buttons.
Use CSS :hover and :focus pseudo-classes for styling visual keyboard focus and hover. The focus and hover effect should encompass both the radio button and label to make it easier to perceive which option is being chosen and to indicate that clicking either the label or button will activate the radio button.
Examples

The basic set up for a radiogroup using non-semantic ARIA roles instead of semantic HTML is as follows:

HTML
Copy to Clipboard
<div role="radiogroup" aria-labelledby="question">
  <div id="question">Which is the best color?</div>
  <div id="radioGroup">
    <p>
      <span
        id="colorOption_0"
        tabindex="0"
        role="radio"
        aria-checked="false"
        aria-labelledby="purple"></span>
      <span id="purple">Purple</span>
    </p>
    <p>
      <span
        id="colorOption_1"
        tabindex="-1"
        role="radio"
        aria-checked="false"
        aria-labelledby="aubergine"></span>
      <span id="aubergine">Aubergine</span>
    </p>
    <p>
      <span
        id="colorOption_2"
        tabindex="-1"
        role="radio"
        aria-checked="false"
        aria-labelledby="magenta"></span>
      <span id="magenta">Magenta</span>
    </p>
    <p>
      <span
        id="colorOption_3"
        tabindex="-1"
        role="radio"
        aria-checked="false"
        aria-labelledby="all"></span>
      <span id="all">All of the above</span>
    </p>
  </div>
</div>


This could have been written using semantic HTML, which requires no CSS or JavaScript:

HTML
Copy to Clipboard
<fieldset>
  <legend>Which is the best color?</legend>
  <p>
    <input name="colorOption" type="radio" id="purple" />
    <label for="purple">Purple</label>
  </p>
  <p>
    <input name="colorOption" type="radio" id="aubergine" />
    <label for="aubergine">Aubergine</label>
  </p>
  <p>
    <input name="colorOption" type="radio" id="magenta" />
    <label for="magenta">Magenta</label>
  </p>
  <p>
    <input name="colorOption" type="radio" id="all" />
    <label for="all">All of the above</label>
  </p>
</fieldset>


In this <fieldset> example, while role="radiogroup" is not necessary, to have this grouping explicitly announced as radiogroup, include the ARIA role.

--------------------------------------------------

ARIA role/attribute name: ARIA: range role

The range abstract role is a generic type of structure role representing a range of values.

Note: The range role is an abstract role. It is included here for completeness of documentation. It is not to be used by web authors.

Description

The range role is an abstract role. It must not be used by web authors. It is the superclass for structural roles for elements that accept a value within a range of values, including the meter role, progressbar and slider. For these three, consider using the <meter> element, the <progress> element, and the <input/range>, respectively.
Best Practices

Do not use.

--------------------------------------------------

ARIA role/attribute name: ARIA: region role

The region role is used to identify document areas the author deems significant. It is a generic landmark available to aid in navigation when none of the other landmark roles are appropriate.

HTML
Copy to Clipboard
<div role="region" aria-label="Example">
  <!-- region content -->
</div>

Description

The region role is an ARIA landmark role. The region role should be reserved for sections of content sufficiently important that users will likely want to navigate to the section easily and to have it listed in a summary of the page. A region role is a more generic term, and should only be used if the section needing to be identified is not accurately described by one of the other landmark roles, such as banner, main, contentinfo, complementary, or navigation.
Every element with a region role should include a label that describes the purpose of the content in the region, preferably with an aria-labelledby referencing a visible header. If no visible appropriate header is present, aria-label should be used.
The region landmark role's content should make sense if separated from the main content of the document.
Using the <section> element will automatically communicate a section has a role of region if it is given an accessible name. Developers should always prefer using the correct semantic HTML element, in this case <section>, over using ARIA.
Associated WAI-ARIA Roles, States, and Properties
aria-labelledby or aria-label

Use this attribute to label the region. Often, the value of the aria-labelledby attribute will be the id of the element used to title the section. If no visible appropriate header is present, aria-label should be used.
Examples
HTML
Copy to Clipboard
<div role="region" aria-labelledby="region-heading">
  <h2 id="region-heading">
    This heading's `id` attribute helps this region have an accessible name
  </h2>
  <!-- region content -->
</div>

Accessibility concerns

Use sparingly! Landmark roles are intended to be used sparingly, to identify larger overall sections of the document. Using too many landmark roles can create "noise" in screen readers, making it difficult to understand the overall layout of the page.
Only use the region role if no other relevant content sectioning element or landmark role applies. If multiple regions exist on a page, it may be worth reinvestigating the page's overall structure.
Best practices

Prefer HTML

Using the <section> element will automatically communicate that a section has a role of region if it is given an accessible name. If at all possible, prefer using <section> instead.
Labeling landmarks

If there is more than one region landmark role in a document, provide a unique label for each one. This label will allow an assistive technology user to be able to quickly understand the purpose of each landmark.
HTML
Copy to Clipboard
<div role="region" aria-labelledby="use-discretion">
  <h3 id="use-discretion">Please use the `region` role with discretion</h3>
  <!-- content -->
</div>

…

<div role="region" aria-labelledby="please-reconsider">
  <h3 id="please-reconsider">Please reconsider your document structure</h3>
  <!-- content -->
</div>


In this example, the region's label is being generated by the aria-labelledby attribute.
Scrolling content areas with overflow text

If there is a content area with tabindex="0", add role="region" to convey to screen reader users that is a generic region. This is done to allow keyboard-only users to scroll regions with overflow text.
SVG

role="region" can be declared on areas of <svg> along with an aria-label to allow individual sections of the SVG to be described.

--------------------------------------------------

ARIA role/attribute name: ARIA: roletype role

The roletype role, an abstract role, is the base role from which all other ARIA roles inherit.

Note: The roletype role is an abstract role used for the ontology. It is included here for completeness of documentation. It should not be used by web authors.

Description

The roletype role's properties describe the structural and functional purpose of objects that are assigned this role, or "instances". A role is a concept that can be used to understand and operate instances. Note

Best Practices

Do not use.

--------------------------------------------------

ARIA role/attribute name: ARIA: row role

An element with role="row" is a row of cells within a tabular structure. A row contains one or more cells, grid cells or column headers, and possibly a row header, within a grid, table or treegrid, and optionally within a rowgroup.

HTML
Copy to Clipboard
<div
  role="table"
  aria-label="Populations"
  aria-describedby="country_population_desc">
  <div id="country_population_desc">World Populations by Country</div>
  <div role="rowgroup">
    <div role="row">
      <span role="columnheader" aria-sort="descending">Country</span>
      <span role="columnheader" aria-sort="none">Population</span>
    </div>
  </div>
  <div role="rowgroup">
    <div role="row">
      <span role="cell">Finland</span>
      <span role="cell">5.5 million</span>
    </div>
    <div role="row">
      <span role="cell">France</span>
      <span role="cell">67 million</span>
    </div>
  </div>
</div>

Description

The element with role="row" is a row within a grid, table, or treegrid, and optionally within a rowgroup that contains one or more cell, gridcell, columnheader, or rowheader elements within a static tabular structure. Using native HTML <tr> elements, whenever possible, is strongly encouraged.
To create an ARIA row, add role="row" to the container element. That row should be nested within a grid, table or treegrid. A group of rows can be nested within a grid, table or treegrid directly, or within a rowgroup in one of those containers. Each row contains child cells. These cells can be of different types, depending on whether they are column or row headers, or grid or regular cells.
A row can contain a number of attributes clarifying the row's role, including aria-colindex, aria-level, aria-rowindex, and aria-selected.
If the row is within a treegrid, rows can include the aria-expanded attribute, using the attribute to indicate the present status. This is not the case for an ordinary table or grid, in which the aria-expanded attribute is not present.
To create an interactive widget that has a tabular structure, use the grid pattern instead. If the interaction provides for the selection state of individual cells, if left to right and top to bottom navigation is provided, or if the user interface allows the rearranging of cell order or otherwise changing individual cell order such as through drag and drop, use grid or treegrid instead.
Note: Using the native HTML table element (<table>) along with the table row element (<tr>) whenever possible is strongly encouraged.
Associated WAI-ARIA roles, states, and properties
Context roles
role="rowgroup"

An optional contextual row parent, it establishes a relationship between descendant rows. It is a structural equivalent to the thead, tfoot, and tbody elements in an HTML table element.
role="table"

One of the three possible contexts (along with grid and treegrid) in which you'll find a row, it identifies the row as being part of a non-interactive table structure containing data arranged in rows and columns, similar to the native <table> HTML element.
role="grid"

One of the three possible contexts (along with table and treegrid) in which you'll find a row, it identifies the row as being part of a non-interactive table structure containing data arranged in rows and columns, similar to the native <table> HTML element.
role="treegrid"

Similar to a grid, but with rows that can be expanded and collapsed in the same manner as for a tree.
Descendant roles
role="cell"

A cell in a row within a tabular container.
role="gridcell"

A cell in a row within a grid or treegrid.
role="columnheader"

A header cell that is the structural equivalent of the HTML <th> element with a column scope (<tr scope="col">). Unlike a plain cell, the columnheader role establishes a relationship between it and all cells in the corresponding column.
role="rowheader"

A header cell that is the structural equivalent of the HTML <th> element with a row scope (<tr scope="row">). Unlike a plain cell, the rowheader role establishes a relationship between it and all cells in the corresponding row.
States and properties
aria-expanded state

The aria-expanded attribute, which defines the state of the row, can take one of three values, or be omitted:

aria-expanded="true": Row is currently expanded.
aria-expanded="false": Row is currently collapsed.
aria-expanded="undefined" or the attribute is missing: The row is neither expandable nor collapsible.
If the element with the aria-expanded attribute controls the expansion of another grouping container that is not 'owned by' the element, the author should reference the container by using the aria-controls attribute.
aria-selected state

Only relevant if the row is in an interactive container, such as a grid or treegrid, but not relevant if the row is in a table. The aria-selected attribute can take one of three values, or be omitted:

aria-selected="true": Row is currently selected
aria-selected="false": Row is not currently selected.
aria-selected="undefined" or the attribute is missing: The row is not selectable.
aria-colindex attribute

The aria-colindex attribute is only needed if columns are hidden from the DOM. It is generally placed on row children, rather than on the row itself. If the columns displayed are contiguous, then it can be placed on the row.
The attribute takes as its value an integer between 1 and the total number of columns within the table, grid or treegrid. When placed on the row, the aria-colindex defines an element's column index or position with respect to the total number of columns within a row. For example, in a table with 15 columns, and columns 4, 5, and 6 are in the DOM, aria-colindex="4" could be set on every row.
If the set of columns which is present in the DOM is not contiguous, or if there are cells spanning more than one row or column, put the aria-colindex on all of the children of each row instead of on the row itself.
If all the columns are in the DOM, this attribute is not necessary.
aria-rowindex attribute

The aria-rowindex attribute is only needed if rows are hidden from the DOM, to indicate which row, in the list of total rows, is being read. The attribute, placed with a unique value on each row, takes as its value an integer between 1 and the total number of rows within the table, grid or treegrid, indicating the position, or index, of each row. For example, if a table has 1,500 rows, but only the header and rows 47 and 52 are in the DOM, aria-rowindex="1" would be set on the header row, and aria-rowindex="47" and aria-rowindex="52" would be set on the 47th and 52nd row, respectively.
If all the rows are present in the DOM, this attribute is not necessary.
Keyboard Interactions

None

Required JavaScript features

None. For sortable columns, see the columnheader aria role.
Note: The first rule of ARIA use is you can use a native feature with the semantics and behavior you require already built in, instead of re-purposing an element and adding an ARIA role, state or property to make it accessible, then do so. Employ the HTML <table> element instead of the ARIA role of table whenever possible.
Examples
HTML
Copy to Clipboard
<div
  role="table"
  aria-label="Semantic Elements"
  aria-describedby="semantic_elements_table_desc"
  aria-rowcount="81">
  <div id="semantic_elements_table_desc">
    Semantic Elements to use instead of ARIA's roles
  </div>
  <div role="rowgroup">
    <div role="row">
      <span role="columnheader" aria-sort="none">ARIA Role</span>
      <span role="columnheader" aria-sort="none">Semantic Element</span>
    </div>
  </div>
  <div role="rowgroup">
    <div role="row" aria-rowindex="11">
      <span role="cell">header</span>
      <span role="cell">h1</span>
    </div>
    <div role="row" aria-rowindex="16">
      <span role="cell">header</span>
      <span role="cell">h6</span>
    </div>
    <div role="row" aria-rowindex="18">
      <span role="cell">rowgroup</span>
      <span role="cell">thead</span>
    </div>
    <div role="row" aria-rowindex="24">
      <span role="cell">term</span>
      <span role="cell">dt</span>
    </div>
  </div>
</div>


The above is a non-semantic ARIA table with five of 81 rows present in the DOM: One within a table header and four rows within the table body. The header row, alone in a header rowgroup, has two column headers. The columns are sortable, but not currently sorted, as indicated by the aria-sort property. The table body is in a separate rowgroup, with four rows currently in the DOM. Because not all the rows are in the DOM, we've included the aria-rowindex property on every row.
Best practices

Only use <table>, <tbody>, <thead>, <tr>, <th>, <td>, etc., for data table structure. You can add these ARIA roles to ensure accessibility should the native semantics of the table be removed, such as with CSS. A relevant use case for the ARIA table role is when the native semantics of a table are overridden by CSS's display property, such as by display: grid. In this case, you can use the ARIA table roles to add the semantics back in.
HTML
Copy to Clipboard
<table
  role="table"
  aria-label="Semantic Elements"
  aria-describedby="semantic_elements_table_desc"
  aria-rowcount="81">
  <caption id="semantic_elements_table_desc">
    Semantic Elements to use instead of ARIA's roles
  </caption>
  <thead role="rowgroup">
    <tr role="row">
      <th role="columnheader" aria-sort="none">ARIA Role</th>
      <th role="columnheader" aria-sort="none">Semantic Element</th>
    </tr>
  </thead>
  <tbody role="rowgroup">
    <tr role="row" aria-rowindex="11">
      <td role="cell">header</td>
      <td role="cell">h1</td>
    </tr>
    <tr role="row" aria-rowindex="16">
      <td role="cell">header</td>
      <td role="cell">h6</td>
    </tr>
    <tr role="row" aria-rowindex="18">
      <td role="cell">rowgroup</td>
      <td role="cell">thead</td>
    </tr>
    <tr role="row" aria-rowindex="24">
      <td role="cell">term</td>
      <td role="cell">dt</td>
    </tr>
  </tbody>
</table>


Above is the semantic way of writing a table. The ARIA roles are only necessary if the native semantics of the table, and therefore the table rows, are obliterated, such as via setting the display property to flex or grid.
Added benefits

none


--------------------------------------------------

ARIA role/attribute name: ARIA: rowgroup role

An element with role="rowgroup" is a group of rows within a tabular structure. A rowgroup contains one or more rows of cells, grid cells, column headers, or row headers within a grid, table or treegrid.

HTML
Copy to Clipboard
<div
  role="table"
  aria-label="Populations"
  aria-describedby="country_population_desc">
  <div id="country_population_desc">World Populations by Country</div>
  <div role="rowgroup">
    <div role="row">
      <span role="columnheader" aria-sort="descending">Country</span>
      <span role="columnheader" aria-sort="none">Population</span>
    </div>
  </div>
  <div role="rowgroup">
    <div role="row">
      <span role="cell">Finland</span>
      <span role="cell">5.5 million</span>
    </div>
    <div role="row">
      <span role="cell">France</span>
      <span role="cell">67 million</span>
    </div>
  </div>
</div>

Description

Rowgroup establishes a relationship between owned row elements and is a structural equivalent to the <thead>, <tfoot> and <tbody> elements in HTML. There is, however, no differentiation between different types of row groups. Their elements must be contained in, or owned by, elements with either the table or grid role. Using the native <thead>, <tfoot> and <tbody> HTML elements, whenever possible, is strongly encouraged.
To create an ARIA table header, table footer or table body, add role="rowgroup" to the element. That rowgroup should be nested within a grid, table or treegrid, encompassing a group of one or more rows. Each row, in turn, contains child cells. These cells can be of different types, depending on whether they are column or row headers, or plain or grid cells.
Note: Using the native HTML table element (<table>) along with the table header (<thead>), footer (<tfoot>), and body (<tbody>) elements whenever possible is strongly encouraged.
Associated WAI-ARIA roles, states, and properties
Context roles
role="table"

One of the three possible contexts (along with grid and treegrid) in which you'll find a row. It identifies the row as being part of a non-interactive table structure containing data arranged in rows and columns, similar to the native <table> HTML element.
role="grid"

One of the three possible contexts (along with table and treegrid) in which you'll find a row. It identifies the row as being part of a non-interactive table structure containing data arranged in rows and columns, similar to the native <table> HTML element.
role="treegrid"

Similar to a grid, but with rows that can be expanded and collapsed in the same manner as for a tree.
Descendant roles
role="row"

A row of cells within a tabular structure. A row contains one or more cells, gridcell, or column headers, and sometimes a row header.
Keyboard interactions

None

Required JavaScript features

None.
Note: The first rule of ARIA use is if you can use a native feature with the semantics and behavior you require already built in, instead of re-purposing an element and adding an ARIA role, state or property to make it accessible, then do so. Employ the HTML <table> element instead of the ARIA role of table whenever possible.
Examples
HTML
Copy to Clipboard
<div
  role="table"
  aria-label="Semantic Elements"
  aria-describedby="semantic_elements_table_desc"
  aria-rowcount="81">
  <div id="semantic_elements_table_desc">
    Semantic Elements to use instead of ARIA's roles
  </div>
  <div role="rowgroup">
    <div role="row">
      <span role="columnheader" aria-sort="none">ARIA Role</span>
      <span role="columnheader" aria-sort="none">Semantic Element</span>
    </div>
  </div>
  <div role="rowgroup">
    <div role="row" aria-rowindex="11">
      <span role="cell">header</span>
      <span role="cell">h1</span>
    </div>
    <div role="row" aria-rowindex="16">
      <span role="cell">header</span>
      <span role="cell">h6</span>
    </div>
    <div role="row" aria-rowindex="18">
      <span role="cell">rowgroup</span>
      <span role="cell">thead</span>
    </div>
    <div role="row" aria-rowindex="24">
      <span role="cell">term</span>
      <span role="cell">dt</span>
    </div>
  </div>
</div>


The above is a non-semantic ARIA table with a table header and table body, with five of 81 rows present in the DOM: one within a table header and four rows within the table body. The header row, alone in a header rowgroup, has two column headers. The columns are sortable, but not currently sorted, as indicated by the aria-sort property. The table body is a separate rowgroup, with four rows currently in the DOM. Because not all the rows are in the DOM, we've included the aria-rowindex property on every row.
Best practices

Only use <table>, <tbody>, <thead>, <tr>, <th>, <td>, and so on for data table structure. You can add these ARIA roles to ensure accessibility should the native semantics of the table be removed, such as with CSS. A relevant use case for the ARIA table role is when the CSS's display property overrides the native semantics of a table, such as by display: grid. In this case, you can use the ARIA table roles to add in the semantics.
HTML
Copy to Clipboard
<table
  role="table"
  aria-label="Semantic Elements"
  aria-describedby="semantic_elements_table_desc"
  aria-rowcount="81">
  <caption id="semantic_elements_table_desc">
    Semantic Elements to use instead of ARIA's roles
  </caption>
  <thead role="rowgroup">
    <tr role="row">
      <th role="columnheader" aria-sort="none">ARIA Role</th>
      <th role="columnheader" aria-sort="none">Semantic Element</th>
    </tr>
  </thead>
  <tbody role="rowgroup">
    <tr role="row" aria-rowindex="11">
      <td role="cell">header</td>
      <td role="cell">h1</td>
    </tr>
    <tr role="row" aria-rowindex="16">
      <td role="cell">header</td>
      <td role="cell">h6</td>
    </tr>
  </tbody>
</table>


Above is the semantic way of writing a table. The ARIA roles are only necessary if the native semantics of the table, and therefore the table rows, are obliterated, such as by setting the display property to flex or grid.
Added benefits

none


--------------------------------------------------

ARIA role/attribute name: ARIA: rowheader role

An element with role="rowheader" is a cell containing header information for a row within a tabular structure of a grid, table or treegrid.

Description

Rowheader is the header cell for a row, establishing a relationship between it and the other cells in the same row.
HTML
Copy to Clipboard
<div
  role="table"
  aria-label="Populations"
  aria-describedby="country_population_desc">
  <div id="country_population_desc">World Populations by Country</div>
  <div role="rowgroup">
    <div role="row">
      <span role="columnheader" aria-sort="descending">Country</span>
      <span role="columnheader" aria-sort="none">Population</span>
    </div>
  </div>
  <div role="rowgroup">
    <div role="row">
      <span role="rowheader">Finland</span>
      <span role="cell">5.5 million</span>
    </div>
    <div role="row">
      <span role="rowheader">France</span>
      <span role="cell">67 million</span>
    </div>
  </div>
</div>


It is a structural equivalent to the <th> element with a scope of row, <th scope="row">. Using the native <th> HTML element is strongly encouraged.
To create an ARIA row header, add role="rowheader" to the element. That row header must be nested within a row, which, in turn, is nested within a rowgroup, or directly within a grid, table or treegrid.
Note: Using the native table elements whenever possible, is strongly encouraged.
Associated WAI-ARIA roles, states, and properties
Context roles
role="row"

The only context in which you will find a row. It encompasses a cell or group of cells row, of which only one should be of rowheader type. Similar to the native <tr> HTML element.
Keyboard interactions

None

Required JavaScript features

None.
Note: The first rule of ARIA use is if you can use a native feature with the semantics and behavior you require already built in, instead of re-purposing an element and adding an ARIA role, state or property to make it accessible, then do so. Employ the HTML <table>, <tr>, <th>, <td>, and other table elements instead of the ARIA table roles whenever possible.
Examples
HTML
Copy to Clipboard
<div
  role="table"
  aria-label="Semantic Elements"
  aria-describedby="semantic_elements_table_desc"
  aria-rowcount="81">
  <div id="semantic_elements_table_desc">
    Semantic Elements to use instead of ARIA's roles
  </div>
  <div role="rowgroup">
    <div role="row">
      <span role="columnheader" aria-sort="none">ARIA Role</span>
      <span role="columnheader" aria-sort="none">Semantic Element</span>
    </div>
  </div>
  <div role="rowgroup">
    <div role="row" aria-rowindex="11">
      <span role="rowheader">header</span>
      <span role="cell">h1</span>
    </div>
    <div role="row" aria-rowindex="16">
      <span role="rowheader">header</span>
      <span role="cell">h6</span>
    </div>
    <div role="row" aria-rowindex="18">
      <span role="rowheader">rowgroup</span>
      <span role="cell">thead</span>
    </div>
    <div role="row" aria-rowindex="24">
      <span role="rowheader">term</span>
      <span role="cell">dt</span>
    </div>
  </div>
</div>


The above is a non-semantic ARIA table with a table header and table body, with five of 81 rows present in the DOM: one within a table header and four rows within the table body. The header row, alone in a header rowgroup, has two column headers. The columns are sortable, but not currently sorted, as indicated by the aria-sort property. The table body is a separate rowgroup, with four rows currently in the DOM. Each data table row has a row header. Because not all the rows are in the DOM, we've included the aria-rowindex property on every row.
Best practices

Only use <table>, <tbody>, <thead>, <tr>, <th>, <td>, and so on for data table structure. You can add these ARIA roles to ensure accessibility should the native semantics of the table be removed, such as with CSS. A relevant use case for all the ARIA table roles is when the CSS's display property overrides the native semantics of a table, such as by display: grid. In this case, you can use the ARIA table roles to add in the semantics.
HTML
Copy to Clipboard
<table
  role="table"
  aria-label="Semantic Elements"
  aria-describedby="semantic_elements_table_desc"
  aria-rowcount="81">
  <caption id="semantic_elements_table_desc">
    Semantic Elements to use instead of ARIA's roles
  </caption>
  <thead role="rowgroup">
    <tr role="row">
      <th role="columnheader" aria-sort="none">ARIA Role</th>
      <th role="columnheader" aria-sort="none">Semantic Element</th>
    </tr>
  </thead>
  <tbody role="rowgroup">
    <tr role="row" aria-rowindex="11">
      <th role="rowheader">header</th>
      <td role="cell">h1</td>
    </tr>
    <tr role="row" aria-rowindex="16">
      <th role="rowheader">header</th>
      <td role="cell">h6</td>
    </tr>
  </tbody>
</table>


Above is the semantic way of writing a table. The ARIA roles are only necessary if the native semantics of the table, and therefore the table row headers, are obliterated, such as by setting the display property to flex or grid.
Added benefits

none


--------------------------------------------------

ARIA role/attribute name: ARIA: scrollbar role

A scrollbar is a graphical object that controls the scrolling of content within a viewing area.

Description

A scrollbar is a range that controls what part of a viewport's content is currently visible in the viewport's frame; whether the viewport is a full browser size, an iframe, or any element's block formatting context.
What is scroll bar

Many applications provide native scroll bars when the content area is larger than the application window. Scrollbars generally appear on the right or bottom of the viewing area. Native scroll bars appear as thin rectangular track areas the length of the viewport it controls with a piece of UI called a thumb or scroller that can be dragged along a track to move the associated content within the viewport. Some scrollbars have arrows at each end of the track that allow scrolling the viewport a short set distance when activated.
Take this document as an example: if the viewport is the full browser window and the content is taller than the viewport, in most browsers the scroll bar on the right edge of the window represents the overall length of the page and the scroll thumb represents the portion of the page content that is currently in the viewport.
Scroll bars may also appear on viewports that are sub-sections of the full browser window. Continuing with this content as our example, if this content is embedded in an <iframe> or <object>, the native vertical scroll bar will be the height of the frame. A scroll bar generally is the length of the viewport, but isn't required to be.
If you aren't currently seeing a scroll bar, it may be because your browser only displays the scroll bar when scrolling or only when an element's content is too big to fit in its block formatting context. Depending on the browser and operating system, scroll bars can be made to be visible even when the content fits in the viewport when no scrolling is necessary or even possible.
ARIA scrollbar

It is always best to use native scroll bars. You can use the CSS overflow property to ensure the appearance of native scroll bars. A CSS scrollbar specification is being developed. Some browsers allow styling scroll bars via prefixed pseudo-elements.
Because native scroll bar styling has historically been limited, you may come across a scrollbar implemented in JavaScript that you need to support and make fully accessible. For this, you can use the scrollbar role to inform assistive technologies that a UI control is an interactive scrollbar.
An element with the scrollbar role is a graphical object that controls the scrolling of content within a viewing area; it is the ARIA role which indicates an element is a scroll bar. The HTML element that is most similar is the range <input> type, <input type="range">.
The scrollbar element has two required attributes: aria-controls and aria-valuenow. The aria-controls attribute references the id of the scrollable area it controls. The aria-valuenow property defines the current value of the scrollbar.
While the aria-valuenow is always required, the aria-valuemin and aria-valuemax properties only need to be set for the scrollbar role when the scrollbar's minimum value is not 0 or the maximum value is not 100. The value of aria-valuenow must always be between the minimum and maximum inclusive values, or between 0 and 100 inclusive if the minimum and maximum values default to 0 and 100 respectively. aria-valuenow communicates how close the viewport is to the bottom of the document. Think of it like a progress bar, where the start of the document is the minimum value and the end of the document is the maximum value.
A scrollbar represents the current value and range of possible values via the size of the scrollbar and position of the thumb with respect to the visible range of the orientation (horizontal or vertical) it controls. In other words, the scrollbar length (height or width) represents all the content within a viewport. The aria-valuemin value represents the beginning of the content and the scrollbar, the aria-valuemax value represents the end of the content and the end of the scrollbar. The aria-valuenow represents the content that is currently visible in the viewport and the current position, or value, of the movable thumb. The aria-valuenow value will generally be exposed as a percentage between aria-valuemin and aria-valuemax calculated by assistive technologies.
Note: Assistive technologies generally render the value of aria-valuenow as a percent of a range between the value of aria-valuemin and aria-valuemax, unless aria-valuetext is set. It is recommended to set the values for aria-valuemin, aria-valuemax, and aria-valuenow in a manner that is appropriate for this calculation.
Like a native scroll bar, users interact with scrollbar elements directly or indirectly using mouse, touchpad, keyboard, and voice input. scrollbar role implementations must also accommodate all these interaction methods.
When using a mouse, the user must be able to activate the scrollbar by clicking the scroll arrows at either end of the scroll bar, if present, clicking an empty portion of the scroll track, as well as clicking and dragging the scroll thumb.
Keyboard scrolling must also be supported. When focus is within the viewport controlled by a scrollbar, the Up Arrow and Down Arrow (or Left Arrow and Right Arrow for a horizontal scroll bar) should move the scroll bar thumb proportionally. Additionally, the Page Up, Page Down, Space, and Shift + Space keys must move the content and the scroll thumb the height (or width) of the viewport for each key press until the bottom or top (or left or right) of the content is in view.
JavaScript must be used to translate the scrollbar action into scrolling commands, providing the user with feedback by:

Visually updating the scrollbar element,
Scrolling the viewport's content, and
Updating the aria-valuenow property value.
The default orientation of the scrollbar role is vertical. Including aria-orientation="vertical", in this case, is optional. The orientation represents the orientation of the scrollbar and the scrolling effect on the viewing area controlled by the scrollbar. If the scrolling is left to right or right to left and not top to bottom, include aria-orientation="horizontal" on the element with the scrollbar role.
Note: An accessible name is required. If the scrollbar role is applied to an HTML <input> element (or <meter> or <progress> element), the accessible name can come from the associated <label>. Otherwise use aria-labelledby if a visible label is present or aria-label if a visible label is not present.
All descendants are presentational

There are some types of user interface components that, when represented in a platform accessibility API, can only contain text. Accessibility APIs do not have a way of representing semantic elements contained in a scrollbar. To deal with this limitation, browsers, automatically apply role presentation to all descendant elements of any scrollbar element as it is a role that does not support semantic children.
For example, consider the following scrollbar element, which contains a heading.
HTML
Copy to Clipboard
<div role="scrollbar"><h3>Title of my scrollbar</h3></div>


Because descendants of scrollbar are presentational, the following code is equivalent:

HTML
Copy to Clipboard
<div role="scrollbar"><h3 role="presentation">Title of my scrollbar</h3></div>


From the assistive technology user's perspective, the heading does not exist since the previous code snippets are equivalent to the following in the accessibility tree:

HTML
Copy to Clipboard
<div role="scrollbar">Title of my scrollbar</div>

Associated WAI-ARIA roles, states, and properties
aria-controls (Required)

Identifies the viewport, via the id, whose contents controlled by the scrollbar.
aria-valuenow (Required)

Set to a decimal value between 0, or aria-valuemin if present, and aria-valuemax indicating the current value of the scrollbar.
aria-valuetext

Assistive technologies often present the value of aria-valuenow as a percentage. If this would not be helpful, use this property to make the scrollbar value more understandable to users.
aria-valuemin

Set to a decimal value representing the minimum value, and less than aria-valuemax. If not present, the default value is 0.
aria-valuemax

Set to a decimal value representing the maximum value, and greater than aria-valuemin. If not present, the default value is 100.
aria-labelledby

When not using a native form control and therefore not able to associate the scrollbar with a <label>, if visible text is available that can provide the required accessible name, set to the id of an element containing text serving as a label. Otherwise, use aria-label.
aria-label

If no <label> can be used, and no visible text is present that can be referenced by aria-labelledby, provides the string value that labels the scrollbar element providing the required accessible name.
aria-orientation

By default, the orientation is vertical. The property can be included and set to horizontal, undefined (the default for all roles unless otherwise specified), or vertical.
Keyboard interactions
Up Arrow

The content in the viewport moves up one line with the thumb moving up the scroll bar slider proportionally, until the top of the content and scrollbar are reached.
Down Arrow

The content in the viewport moves down one line with the thumb moving down the scroll bar slider proportionally, until the bottom of the content and scrollbar are reached.
Left Arrow

With horizontal scrolling, the content in the viewport moves left the width of one character with the thumb moving left across the scroll bar slider proportionally, until the left edge of the content abuts the left end of the viewport and the thumb is aligned on the left end of the scrollbar.
Right Arrow

With horizontal scrolling, the content in the viewport moves right the width of one character with the thumb moving right across the scroll bar slider proportionally, until the right edge of the content abuts the right end of the viewport and the thumb is aligned on the right end of the scrollbar.
Page Up and Shift + Space

The content in the viewport moves up the height of one viewport with the thumb moving up the scroll bar slider proportionally, until the top of the content and scrollbar are reached.
Page Down and Space

The content in the viewport moves down the height of one viewport with the thumb moving down the scroll bar slider proportionally, until the bottom of the content and scrollbar are reached.the bottom or top of the content is in view.
Examples

The following is an example of a word likely being too long for a parent container.
HTML
Copy to Clipboard
<span id="pi-label">Pi</div>
<div id="pi">
3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
</div>
<div
  role="scrollbar"
  aria-labelledby="pi-label"
  aria-controls="pi"
  aria-orientation="horizontal"
  aria-valuenow="0"
  aria-valuemin="0"
  aria-valuemax="100">
  <div id="thumb"></div>
</div>


When using the ARIA roles instead of native UI features, CSS must be used to style the scrollbar and thumb and JavaScript must be used to handle all keyboard and pointer events.
CSS could have been used to ensure the overflowing value of PI had a native scrollbar:

HTML
Copy to Clipboard
<h3 id="PI">Pi</h3>
<p class="pi" tabindex="0" aria-labelledby="PI">
  3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
</p>

CSS
Copy to Clipboard
.pi {
  overflow: auto;
  max-width: 100%;
}


The above CSS means a native scroll bar will appear when the user interacts with the paragraph's viewport if the length of the longest word in the paragraph is wider than the paragraphs containing box. The tabindex attribute was added to allow people using a keyboard to navigate to, and scroll around the overflowed content.

--------------------------------------------------

ARIA role/attribute name: ARIA: search role

The search role is used to identify the search functionality; the section of the page used to search the page, site, or collection of sites.

HTML
Copy to Clipboard
<form role="search">
  <!-- search input -->
</form>

Description

The search role is a landmark role that can be added to the container element that encompasses all of the elements that combined to form the search feature of the document or application, including a descendant (<input type="search">). If a document includes more than one search, each should have a unique label, unless they are the same search repeated, then use the same name. There is a input of type search), though this does not define a search landmark by itself. Using <search> is an alternative way to define a search landmark.
Examples

When a <form> is a search form, use the search role instead of form role.
HTML
Copy to Clipboard
<form id="search" role="search">
  <label for="search-input">Search this site</label>
  <input type="search" id="search-input" name="search" spellcheck="false" />
  <input value="Submit" type="submit" />
</form>

Accessibility concerns

Landmark roles are intended to be used sparingly, to identify larger overall sections of the document. Using too many landmark roles can create "noise" in screen readers, making it difficult to understand the overall layout of the page.
Best practices

Prefer HTML

Using the <form> element in conjunction with a declaration of role="search" will provide the largest amount of support.
Labeling landmarks
Multiple landmarks

If there is more than one search landmark role in a document, provide a label for each landmark. This label will allow an assistive technology user to be able to quickly understand the purpose of each landmark.
HTML
Copy to Clipboard
<form id="site-search" role="search" aria-label="Sitewide">
  <!-- search input -->
</form>

…

<form id="page-search" role="search" aria-label="On this page">
  <!-- search input -->
</form>

Repeated landmarks

If a search landmark role in a document is repeated in a document, and both landmarks have identical content, use the same label for each landmark. An example of this would be repeating the sitewide search at the top and bottom of the page.
HTML
Copy to Clipboard
<header>
  <form id="site-search-top" role="search" aria-label="Sitewide">
    <!-- search input -->
  </form>
</header>

…

<footer>
  <form id="site-search-bottom" role="search" aria-label="Sitewide">
    <!-- search input -->
  </form>
</footer>

Redundant descriptions

Screen readers will announce the type of role the landmark is. Because of this, you do not need to describe what the landmark is in its label. For example, a declaration of role="search" with an aria-label="Sitewide search" may be announced redundantly as, "sitewide search search".

--------------------------------------------------

ARIA role/attribute name: ARIA: searchbox role

The searchbox role indicates an element is a type of textbox intended for specifying search criteria.

Description

The searchbox can be used instead of textbox when the text box is within an element with role search. A searchbox is the semantic equivalent is HTML's <input> of type search, <input type="search">, which should be used instead if possible.
The searchbox must have an accessible name. If the searchbox role is applied to an HTML <input> element, an associated <label> should be used. Otherwise, use aria-labelledby if a visible label is present, or aria-label if a visible label is not present.
The screen reader will announce "search box", "search edit", or "search field" plus the accessible name. This can be redundant if "search" is included in the label.
Examples
HTML
Copy to Clipboard
<div tabindex="0" aria-label="search" role="searchbox" contenteditable></div>


While the above is valid, it is simpler, more concise, and less redundant to the screen reader user to write:

HTML
Copy to Clipboard
<input type="search" />


The following is a search form with a searchbox and button, ARIA live region, and container for search results.
HTML
Copy to Clipboard
<form role="search">
  <input
    type="search"
    role="searchbox"
    aria-description="search results will appear below"
    id="search"
    value="" />
  <label for="search">Search this site</label>
  <button>Submit search</button>
</form>
<div aria-live="polite" role="region" aria-atomic="true">
  <div class="sr-only"></div>
</div>
<div id="search-results"></div>


Including role="searchbox" when the form is a search and the label indicates the element is a search may result in assistive technology announcing something along the lines of "search search this site search box", which is redundant. The inclusion of role="searchbox" is not necessary:

HTML
Copy to Clipboard
<input
  type="search"
  aria-description="search results will appear below"
  id="search"
  value="" />


--------------------------------------------------

ARIA role/attribute name: ARIA: section role

The section role, an abstract role, is a superclass role for renderable structural containment components.

Note: The section role is an abstract role. It is included here for completeness of documentation. It should not be used by web authors.

Description

The structural section role is an abstract role for categorizing all the section subclass roles. The role must not be used. Some subclasses, like alert, note, and tooltip are useful, and can be used to add semantics when no semantic HTML elements quite fit the purpose of a component. Others, like code, figure, and subscript, aren't necessary, as there are HTML element equivalents. In this case, <code> <figure> and <sub>, respectively.
Best Practices

Do not use.

--------------------------------------------------

ARIA role/attribute name: ARIA: sectionhead role

The sectionhead role, an abstract role, is superclass role for labels or summaries of the topic of its related section.

Note: The sectionhead role is an abstract role. It is included here for completeness of documentation. It should not be used by web authors.

Description

The structural sectionhead role is an abstract role for the subclass roles that identify the labels or summaries of the sections they label. The role must not be used. The four subclasses — columnheader, heading, rowheader, and tab. There are HTML element equivalents, like, <th scope="col"> for columnheader, <th scope="row"> for rowheader, and any of the HTML headings, h1 through h6 for heading. The tab role does not currently have an HTML equivalent.
Best Practices

Do not use.

--------------------------------------------------

ARIA role/attribute name: ARIA: select role

The select role, an abstract role, is superclass role for form widgets that allows the user to make selections from a set of choices.

Note: The select role is an abstract role. It is included here for completeness of documentation. It should not be used by web authors.

Description

The structural select role, an abstract role, is superclass role for four form widgets, listbox, menu, radiogroup, and tree, which allow users to make selections from a set of choices.
Best Practices

Do not use.

--------------------------------------------------

ARIA role/attribute name: ARIA: separator role

The separator role indicates the element is a divider that separates and distinguishes sections of content or groups of menuitems. The implicit ARIA role the native thematic break <hr> element is separator.

Description

A separator is a divider that separates and distinguishes sections of content or groups of menuitems. There are two types of separators: a static structure that provides a visible boundary, identical to the HTML <hr> element, and a focusable, moveable widget.
Elements with the role separator have an implicit aria-orientation value of horizontal.
Non-focusable separator

A non-focusable separator is a static structural element that can be used to help visually divide two groups of menu items in a menu or to provide a horizontal rule between two sections of a page. Thematic breaks that aren't focusable can still be perceivable by a screen reader user when using a reading cursor that does not depend on focus.
HTML
Copy to Clipboard
<h2>My first blog post</h2>
…
<img src="blueline.gif" role="separator" alt="" />
<h2>Two years later, my second post</h2>
…


In the example, an image creates a visual separator between two blog posts. The author could have used a semantic thematic break <hr> element and styled it with CSS to make it blue (and not have to change the image when they change the blog's theme), or the author could have encompassed each post in the semantic <article> element, or both.
HTML
Copy to Clipboard
<section role="feed">
  <article>
    <h2>My first blog post</h2>
    …
  </article>
  <hr />
  <article>
    <h2>Two years later, my second post</h2>
    …
  </article>
</section>

CSS
Copy to Clipboard
[role="feed"] > hr {
  height: 3px;
  background-color: blue;
}


An accessible name is not needed.
Focusable separator

The separator role can be used to identify the element as a visual separator between groups of items within a menu, such as groups of menuitemradio or menuitemcheckbox elements.
If the separator is focusable, providing a visible boundary between two sections of content and enabling the user to change the relative size of the sections it separates by changing its position, the value of aria-valuenow must be set to a number reflecting the current position of the separator and the value must be updated when it changes. The aria-valuemin and aria-valuemax should also be included if they aren't set to the default values of 0 and 100, respectively.
An accessible name, with aria-label should be included if there is more than one focusable separator.
All descendants are presentational

There are some types of user interface components that, when represented in a platform accessibility API, can only contain text. Accessibility APIs do not have a way of representing semantic elements contained in a separator. To deal with this limitation, browsers, automatically apply role presentation to all descendant elements of any separator element as it is a role that does not support semantic children.
For example, consider the following separator element, which contains a heading.
HTML
Copy to Clipboard
<div role="separator"><h3>Title of my separator</h3></div>


Because descendants of separator are presentational, the following code is equivalent:

HTML
Copy to Clipboard
<div role="separator"><h3 role="presentation">Title of my separator</h3></div>


From the assistive technology user's perspective, the heading does not exist since the previous code snippets are equivalent to the following in the accessibility tree:

HTML
Copy to Clipboard
<div role="separator">Title of my separator</div>

Associated WAI-ARIA roles, states, and properties
aria-orientation (default is horizontal for separator)

By default, the divider for separator roles is assumed to be horizontal. The value can be included and set to horizontal, undefined (the default for other roles unless otherwise specified), or vertical.
aria-valuenow

If the separator is focusable and has a known value, the aria-valuenow defines the current value. If not focusable or the value is unknown, do not include this attribute.
aria-valuemin (default is 0)

If the separator is focusable, and the minimum value is not 0, include the minimum value with aria-valuemin. If the

aria-valuemax (default is 100)

If the separator is focusable, and the maximum value is not 100, include aria-valuemax with a value equal to or larger than aria-valuemin.
aria-valuetext

If the separator is focusable, and the aria-valuenow is not optimal in providing the user with usable information, included aria-valuetext content will be read instead of the aria-valuenow value.

--------------------------------------------------

ARIA role/attribute name: ARIA: slider role

The slider role defines an input where the user selects a value from within a given range.

Description

The slider role is for range input widgets where the user selects a value from within given minimum and maximum values.
The slider role compared other range options

ARIA provides developers with six different range widget roles, including progressbar, meter, and slider.
The progressbar role, similar to HTML's <progress> element, is a read-only range indicating the portion of completion of a task, progressing in a single direction, such as a file upload's loading progress bar that eventually reaches 100% when fully loaded.
The meter role, similar to HTML's <meter> element, is a read-only gauge indicating the amount of something within a known range, such as a computer's battery indicator or a car's gas gauge.
The slider role, similar to HTML's input of type range, <input type="range">, is a read-write input range. Sliders allow users to select a value between set minimum and maximum values. The user selects a value by moving a slider thumb along a horizontal or vertical slider to select a value.
While all three of these ranges have the same ARIA states and properties, the slider role is the only read-write range: it is the only one whose value changes via user interaction. As such, it must be able to receive focus. In addition, keyboard interaction, mouse clicks, and touch interaction must be supported.
Warning: To change the slider value, touch-based assistive technologies need to respond to user gestures for increasing and decreasing the value by synthesizing key events. Fully test slider widgets using assistive technologies on devices where touch is a primary input mechanism before using the slider role (and all range widgets).
Common attributes

The aria-valuemin attribute sets the minimum value. If omitted or not a number, it defaults to 0 (zero).
The aria-valuemax attribute defines the maximum value. If it is missing or not a number, it defaults to 100.
The aria-valuenow attribute value must be between the minimum and maximum values, inclusive. This attribute is required for slider and meter, and optional for progressbar.
For slider, unless using the <input type="range"> element, the aria-valuenow value must be updated programmatically when the user updates the value.
The optional aria-valuetext attribute is included when the aria-valuenow numeric value doesn't reflect the intended value of the slider. As the minimum, maximum, and current values are all numeric, when the values those numbers represent are not numeric, the aria-valuetext attribute should be included with a string value defining the numeric value. For example, if using a slider for t-shirt sizes, the aria-valuetext attribute should shift from xx-small through to XX-large as the aria-valuenow increases.
The aria-valuetext value must be updated as the value or aria-valuenow is updated. While there is no equivalent HTML attribute for <input type="range">, you can include aria-valuetext on any <input> type. ARIA attributes are supported on semantic HTML elements.
When aria-valuetext is an important feature for a slider, consider using <select> with <option> elements instead. While not visually a range, every option's value is more accessible to all users, not just users of assistive technology.
An accessible name is required. If the range's role is applied to an HTML <input> element (or <meter> or <progress> element), the accessible name can come from the associated <label>. Otherwise use aria-labelledby if a visible label is present or aria-label if a visible label is not present.
When not using the HTML <input> element to create your slider, include the tabindex attribute to make the slider focusable. Of the three range types, only slider is user-interactive, and so is the only one that requires being able to receive focus. Focus should be placed on the slider thumb.
Sliders have an implicit aria-orientation value of horizontal. This attribute is not supported with meter or progressbar.
User interactions

Unlike the read-only meter and progressbar roles, a slider is an input, accepting user interaction. In addition to including the tabindex attribute to enable slider focus, keyboard and pointer device support must be implemented.
The slider represents the range of possible values. The position of the slider thumb along the slider represents the current value. User actions that must be supported include changing the value by dragging the thumb or clicking the slider for pointing devices and using directional keys such as arrow keys for the keyboard users. See keyboard interactions below.
Note: It is recommended to use native <input type="range"> elements rather than the slider role. User agents provide a stylized widget for the range input element, based on the current value as it relates to the minimum and maximum values. When using non-semantic elements, all features of the native semantic element need to be recreated with ARIA attributes, JavaScript and CSS.
Range with multiple thumbs

A multi-thumb slider is a slider with two or more thumbs that each set a value in a group of related values. For example, in a product search, a two-thumb slider could be used to enable users to set the minimum and maximum price limits for the search.
In many two-thumb sliders, the thumbs are not allowed to pass one another, such as when the slider sets the minimum and maximum values for a range. For example, in a price-range selector, the maximum value of the thumb that sets the lower end of the range is limited by the current value of the thumb that sets the upper end of the range. The minimum value of the upper-end thumb is also limited by the current value of the lower-end thumb.
It is not a requirement that the thumbs in multi-thumb sliders be dependent on the other thumb values, but intuitive user experience is a requirement, so it is recommended to avoid this anti-pattern.
All descendants are presentational

There are some types of user interface components that, when represented in a platform accessibility API, can only contain text. Accessibility APIs do not have a way of representing semantic elements contained in a slider. To deal with this limitation, browsers, automatically apply role presentation to all descendant elements of any slider element as it is a role that does not support semantic children.
For example, consider the following slider element, which contains a heading.
HTML
Copy to Clipboard
<div role="slider"><h3>Temperature in Celsius</h3></div>


Because descendants of slider are presentational, the following code is equivalent:

HTML
Copy to Clipboard
<div role="slider"><h3 role="presentation">Temperature in Celsius</h3></div>


From the assistive technology user's perspective, the heading does not exist since the previous code snippets are equivalent to the following in the accessibility tree:

HTML
Copy to Clipboard
<div role="slider">Temperature in Celsius</div>

Associated roles, states, and properties
aria-valuenow (required)

Set to a decimal value between aria-valuemin and aria-valuemax, indicating the current value of the slider.
aria-valuetext

Assistive technologies often present the value of aria-valuenow as a number. If this would not be accurate, use aria-valuetext to provide the slider with a more understandable value.
aria-valuemin

Set to a decimal value representing the minimum value, and less than aria-valuemax. If not present, the default value is 0.
aria-valuemax

Set to a decimal value representing the maximum value, and greater than aria-valuemin. If not present, the default value is 100.
aria-label or aria-labelledby

Defines the string value or identifies the element (or elements) that label the slider element providing an accessible name. An accessible name is required.
aria-orientation

Indicates whether the element's orientation is horizontal, vertical, or unknown/ambiguous. With a slider, the implicit value is horizontal but can be set to vertical. As it has an implicit value, the slider orientation is never ambiguous.
Examples

In the example below, we create a vertical thermometer with which the user can set the room temperature:

HTML
Copy to Clipboard
<div>
  <div id="temperatureLabel">Temperature</div>
  <div id="temperatureValue">20°C</div>
  <div id="temperatureSlider">
    <div
      id="temperatureSliderThumb"
      role="slider"
      aria-labelledby="temperatureLabel"
      aria-orientation="vertical"
      tabindex="0"
      aria-valuemin="15.0"
      aria-valuemax="25.0"
      aria-valuenow="20.0"
      aria-valuetext="20 degrees Celsius"
      style="top: calc((25 - 20)*2rem - 0.5rem)"></div>
  </div>
</div>


The position of the thumb is the maximum value minus the current value times the height of one degree, minus half the height of the thumb to center it. The rest of the styles are static.
CSS
Copy to Clipboard
[id="temperatureSlider"] {
  position: relative;
  height: 20rem;
  width: 1rem;
  outline: 1px solid;
  margin: 3rem;
}

[id="temperatureSliderThumb"] {
  position: absolute;
  height: 1rem;
  width: 2rem;
  background-color: currentcolor;
  left: -0.5rem;
}


For this example to work, we have to write a script to handle all keyboard and pointer events, including event listeners for pointermove, pointerup, focus, blur, and keydown, and provide styles for the default state and when the thumb and slider receive focus. The position of the thumb, the aria-valuenow and aria-valuetext values, and the inner text of the element with the id "temperatureValue" need to be updated every time ArrowLeft, ArrowDown, ArrowRight, ArrowUp, Home, End, and, optionally, PageDown and PageUp keys are released and when the user drags the thumb or otherwise clicks on the temperature slider.
Using semantic HTML, this could have been written as:

HTML
Copy to Clipboard
<label for="temperature"> Temperature </label>
<output id="temperatureValue">20°C</output>
<input
  type="range"
  id="temperatureSlider"
  min="15"
  max="25"
  step="0.1"
  value="20"
  aria-valuetext="20 degrees celsius"
  style="transform: rotate(-90deg);" />


By using <input>, we get an already-styled range-input widget with keyboard focus, focus styling, keyboard interactions, and value updated on user interaction for free. We still need to use JavaScript to change the aria-valuetext and the value of the <output> element.
There are a few ways to make a range input vertical. In this example, we used CSS transforms.
Keyboard interactions
Key(s)	Action
Right and Up arrows	Increase the selected value by one step
Left and Down arrows	Decrease the selected value by one step
Page Up	(Optional) increase the value by a set amount greater than one step
Page Down	(Optional) decrease the value by a set amount greater than one step
Home	Set the slider to the minimum value.
End	Set the slider to the maximum value.
For the optional Page Up and Page Down keys, the change in slider value should be by an amount larger than the step changes made by up and down arrows.
Best practices

If the slider is describing the loading progress of a particular region of a page, include the aria-describedby attribute to reference the slider status, and set the aria-busy attribute to true on the region until it is finished loading.
HTML's <input type="range"> implicitly has the role of slider. Do not use aria-valuemax or aria-valuemin attributes on <input type="range"> elements; use min and max instead. Otherwise, any global aria-* attributes and any other aria-* attributes applicable to the slider role.
Prefer HTML

It is recommended to use a native <input> of type range, <input type="range">, rather than the slider role.

--------------------------------------------------

ARIA role/attribute name: ARIA: spinbutton role

The spinbutton role defines a type of range that expects the user to select a value from among discrete choices.

Description

The spinbutton role indicates that the element is an input widget that restricts its value to a set or range of discrete values. The role also comes with increment and decrement functionality. For example, in a widget that enables users to choose an amount to bet in a game of Texas Holdem, the spinbutton role can allow users to select a number between the minimum and maximum bets in increments, as allowed by the current game rules.
The spinbutton represents the range of possible values. The value of the spinbutton input represents the current value.
Spinbuttons often have three components, including a text field that displays the current value, an increment button, and a decrement button. The text field is usually the only focusable component because the increment and decrement functions are keyboard accessible via arrow keys. Typically, the text field also allows users to directly edit the value.
In addition to including the tabindex attribute to enable spinbutton focus, keyboard and pointer device support must be implemented. Directional keys such as the arrow keys must be supported for keyboard users. Changing the value when increment and decrement buttons are clicked must be supported for pointing devices. See keyboard interactions below.
Note: It is recommended to use <input type="number"> element, or other input types for dates and time that also implicitly have the role="spinbutton" semantic, rather than the spinbutton role. User agents provide stylized widget for the these input elements which provide default increment, decrement, and native range limiting functionality. When using non-semantic elements, all features of the native semantic element need to be recreated with ARIA attributes, JavaScript, and CSS.
ARIA range widget options

ARIA provides developers with six different range widget roles, including progressbar, meter, slider, and spinbutton.
The progressbar role, similar to HTML's <progress> element, is a read-only range. It indicates the portion of completion of a task, progressing in a single direction, such as a file upload's loading progress bar that eventually reaches 100% when fully loaded.
The meter role, similar to HTML's <meter> element, is a read-only gauge. It indicates the amount of something within a known range, such as a computer's battery indicator or a car's gas gauge.
The slider role, similar to HTML's input of type range, <input type="range">, is a read-write input range. Sliders allow users to select a value between the predefined minimum and maximum values. The user selects a value by moving a slider thumb along a horizontal or vertical slider to select a value.
While all three of these ranges have the same ARIA states and properties, the spinbutton role is the only read-write range: it is the only one whose value changes via user interaction. As such, it must be able to receive focus. In addition, keyboard interaction, mouse clicks, and touch interaction must be supported.
Warning: To change the spinbutton value, touch-based assistive technologies need to respond to user gestures for increasing and decreasing the value by synthesizing key events. Fully test spinbutton widgets using assistive technologies on devices where touch is a primary input mechanism before using the spinbutton role (and all range widgets).
Common attributes

The aria-valuemin attribute sets the minimum value. If omitted or not a number, it defaults to 0 (zero).
The aria-valuemax attribute defines the maximum value. If it is missing or not a number, it defaults to 100.
The aria-valuenow attribute value must be between the minimum and maximum values, both inclusive. This attribute is required for spinbutton and meter, and optional for progressbar.
For spinbutton, unless using semantic HTML elements like <input type="number">, if the value is updated, the aria-valuenow value must also be updated programmatically.
The optional aria-valuetext attribute is included when the aria-valuenow numeric value doesn't reflect the intended value of the spinbutton. The optional minimum, maximum, and current values should be numeric. When the values these numbers represent are not numeric, the aria-valuetext attribute should be included with a string value defining the numeric value. For example, if using a spinbutton for t-shirt sizes, the aria-valuetext attribute should shift from XX-Small through XX-Large as the aria-valuenow increases.
The aria-valuetext value must be updated as the value or aria-valuenow is updated. ARIA attributes are supported on semantic HTML elements. While there is no equivalent HTML attribute for <input>, you can include aria-valuetext on any <input> type. When aria-valuetext is an important feature for a spinbutton, consider using <select> with <option> elements instead.
An accessible name is required. If the spinbutton role is applied to an HTML <input> element, the accessible name can come from the associated <label>. Otherwise, use aria-labelledby if a visible label is present or aria-label if a visible label is not present.
When not using the HTML <input> element to create your spinbutton, include the tabindex attribute to make the spinbutton focusable. The spinbutton role is user-interactive, and therefore, requires being able to receive focus. Focus should be placed on the spinbutton input and not on the associated buttons that increment and decrement the spinbutton value.
Descendants limited to buttons or text

There are some types of user interface components that, when represented in a platform accessibility API, can only contain specific content. The children or owned elements of spinbutton are limited to a textbox and two buttons. Alternatively, the spinbutton role can be applied to a text input and sibling buttons can be used to support the increment and decrement functions.
Associated roles, states, and properties
aria-valuenow (required)

Set to a decimal value between aria-valuemin and aria-valuemax, indicating the current value of the spinbutton. If not present, there is no default value.
aria-valuetext

Assistive technologies often present the value of aria-valuenow as a number. If aria-valuenow cannot be accurate, use aria-valuetext to provide the spinbutton with a more understandable value.
aria-valuemin

Set to a decimal value representing the minimum value and less than aria-valuemax. If not present, there is no default value.
aria-valuemax

Set to a decimal value representing the maximum value and greater than aria-valuemin. If not present, there is no default value.
aria-labelledby

Defines the string value or identifies the element (or elements) that label the spinbutton element providing an accessible name. An accessible name is required.
aria-label

Defines a string value that labels the spinbutton element. This provides an accessible name to the element when no visible label is available to provide the required accessible name via <label> or aria-labelledby.
Examples

In the example below, a spinbutton role has been defined to allow users to select a day of the month.
HTML
Copy to Clipboard
<p id="day">Enter the day of the month</p>
<button type="button" tabindex="-1" aria-label="previous day">˱</button>
<div
  role="spinbutton"
  tabindex="0"
  aria-valuenow="1"
  aria-valuetext="first"
  aria-valuemin="1"
  aria-valuemax="31"
  aria-labelledby="day">
  1
</div>
<button type="button" tabindex="-1" aria-label="next day">˲</button>


In this example, we included a negative tabindex to remove the buttons from the default tabbing order. We also added tabindex to a normally non-interactive <div> to add the spinbutton itself to the tabbing order. This example requires JavaScript to handle keyboard actions when the spinbutton has focus and when a mouse user clicks on the buttons.
With semantic HTML

This could have also been written using semantic HTML, removing the need for any CSS or JavaScript and also removing the need to include and provide functionality for extraneous incrementing and decrementing buttons. The code snippet below shows the previous example without the spinbutton role and using semantic HTML.
HTML
Copy to Clipboard
Play
<label for="day">Enter the day of the month</label>
<input
  type="number"
  value="1"
  aria-valuetext="first"
  min="1"
  max="31"
  id="day" />

Play

In this case, the only JavaScript needed would be to update the aria-valuetext when the input value changes, which really is an optional feature in this case.
Keyboard interactions
Key(s)	Action
Right and Up arrows	Increase the selected value by one step
Left and Down arrows	Decrease the selected value by one step
Page Up	(Optional) Increase the value by a set amount greater than or equal to one step
Page Down	(Optional) Decrease the value by a set amount greater than or equal to one step
Home	Set the spinbutton to the minimum value
End	Set the spinbutton to the maximum value

For the optional Page Up and Page Down keys, the change in spinbutton value should preferably be by an amount larger than the step changes made by Up and Down arrow keys.
Best practices

HTML's <input type="number"> implicitly has the role of spinbutton. HTML's <input type="date"> has 3 nested spin buttons, one each for month, day, and year. When using semantic HTML form elements for their intended purposes, do not use aria-valuemax or aria-valuemin attributes; use min and max instead. Otherwise, any global aria-* attributes and any other aria-* attributes are applicable to the spinbutton role.
Prefer semantic HTML

It is recommended to use the native <input> element of type number, <input type="number">, rather than the spinbutton role.

--------------------------------------------------

ARIA role/attribute name: ARIA: status role

The status role defines a live region containing advisory information for the user that is not important enough to be an alert.

Description

A status is a type of live region providing advisory information that is not important enough to justify an alert, which would immediately interrupt the announcement of a user's current activity. It is often, but not necessarily, presented as a status bar.
Do not give focus to the status when its content updates. Live regions are meant to inform users of dynamic updates that have occurred in other areas of the current web page, but which do not necessitate interrupting the user's current activity with a change in context. If a situation requires that focus needs to be moved, then using a status, or other live region, are likely not appropriate.
Elements with the role status have an implicit aria-live value of polite and an implicit aria-atomic value of true.
Associated WAI-ARIA roles, states, and properties
aria-atomic

Defines whether assistive technologies should present all, or only parts of, the changed region. Elements with the role status have an implicit aria-atomic value of true.
aria-live

Defines when assistive technology should inform the user of updates to content. Elements with the role status have an implicit aria-live value of polite, meaning screen readers will announce changes inside the log when the user is idle.
aria-label or aria-labelledby

Some screen readers announce the name of a status element before announcing its contents. If a name is visible, reference it using aria-labelledby. Including an aria-label provides a method for prefacing the visible content of a status element with text that is not displayed when a screen reader reads the content. Naming a status is not required so if nothing is appropriate both these attributes can be omitted.

--------------------------------------------------

ARIA role/attribute name: ARIA: structure role

The structure role is for document structural elements.

Note: The structure role is an abstract role. It is included here for completeness of documentation. It should not be used by web authors.

Description

Structure is a superclass abstract role for document structures, like as document, rowgroup, and sectionhead, that support the accessibility of dynamic web content by helping assistive technologies determine active content versus static document content. Some subclass roles, like section role, are in turn superclasses of other roles.
The structure role is the superclass for all document structure roles, which are used to provide a structural description for a section of content. Most structure roles should no longer be used as browsers now support semantic HTML element with the same meaning. The structure roles without HTML equivalents, such as the presentation role which means content is presentational only, provide information on the document structure to assistive technologies such as screen readers as equivalent native HTML tags are not available.
Best Practices

Do not use role="structure". Do use HTML and subclass structure roles.

--------------------------------------------------


--------------------------------------------------

ARIA role/attribute name: ARIA: switch role

The ARIA switch role is functionally identical to the checkbox role, except that instead of representing "checked" and "unchecked" states, which are fairly generic in meaning, the switch role represents the states "on" and "off."

This example creates a widget and assigns the ARIA switch role to it.

HTML
Copy to Clipboard
<button
  type="button"
  role="switch"
  aria-checked="true"
  id="speakerPower"
  class="switch">
  <span aria-hidden="true">off</span>
  <span aria-hidden="true">on</span>
</button>
<label for="speakerPower" class="switch">Speaker power</label>

Description

The ARIA switch role is identical to the checkbox role, except instead of being "checked" or "unchecked", it is either "on" or "off". Like the checkbox role, the aria-checked attribute is required. The two possible values are true and false. Unlike an <input type="checkbox"> or role="checkbox", there is no indeterminate or mixed state. The switch role does not support the value mixed for the aria-checked attribute; assigning a value of mixed to a switch instead sets the value to false.
Assistive technologies may choose to represent switch widgets with a specialized presentation to reflect the notion of an on/off switch.
Since a switch is an interactive control, it must be focusable and keyboard accessible. If the role is applied to a non-focusable element, use the tabindex attribute to change this. The expected keyboard shortcut for toggling the value of a switch is the Space key. The developer is required to change the value of the aria-checked attribute dynamically when the switch is toggled.
All descendants are presentational

There are some types of user interface components that, when represented in a platform accessibility API, can only contain text. Accessibility APIs do not have a way of representing semantic elements contained in a switch. To deal with this limitation, browsers, automatically apply role presentation to all descendant elements of any switch element as it is a role that does not support semantic children.
For example, consider the following switch element, which contains a heading.
HTML
Copy to Clipboard
<div role="switch"><h3>Title of my switch</h3></div>


Because descendants of switch are presentational, the following code is equivalent:

HTML
Copy to Clipboard
<div role="switch"><h3 role="presentation">Title of my switch</h3></div>


From the assistive technology user's perspective, the heading does not exist since the previous code snippets are equivalent to the following in the accessibility tree:

HTML
Copy to Clipboard
<div role="switch">Title of my switch</div>

Associated ARIA roles, states, and properties
aria-checked attribute

The aria-checked attribute is required when using the switch role, as it represents the current state of the widget that the switch role is applied to. A value of true represents the "on" state; false represents the "off" state; a value of mixed is not supported by the switch role, and is treated as false.
aria-readonly attribute

The aria-readonly attribute is supported by the switch role. It indicates whether the widget's state is editable by the user. A value of false means that the user can change the widget's state; a value of true means that the user cannot change the widget's state. The default value is false.
Required JavaScript features
Handler for click events

When the user clicks on the switch widget, a click event is fired, which must be handled in order to change the state of the widget.
Changing the aria-checked attribute

When a click event is fired on the switch widget, the handler must change the value of the aria-checked attribute from true to false, or vice versa.
Possible effects on user agents and assistive technology

When the switch role is added to an element, the user agent handles it like this:

The element is exposed to the system's accessibility infrastructure as having the switch role.
When the aria-checked attribute's value changes, an accessible event is fired using the system's accessibility API if one is available and it supports the switch role.
All elements that are descendants of an element with the switch role applied to it are automatically assigned role presentation. This prevents elements that are used to construct the switch from being interacted with individually by assistive technologies. Text in these elements remains visible to the user agent and may be read or otherwise delivered to the user, unless it's expressly hidden using display: none or aria-hidden="true".
The assistive technology, if it supports the switch role, responds by doing the following:

Screen readers should announce the element as a switch, optionally providing instructions as to how to activate the switch.
Note: There are varying opinions on how assistive technologies should handle this role; the above is a suggested practice and may differ from other sources.
Examples

The following examples should help you understand how to apply and use the switch role.
Adding the switch role in ARIA

This simple example just creates a widget and assigns the ARIA switch role to it. The button is styled with an appearance reminiscent of an on/off power switch.
HTML

The HTML is fairly simple here. The switch is implemented as a <button> element which is initially checked courtesy of its aria-checked attribute being set to "true". The switch has two child elements containing the "off" and "on" labels and is followed by a <label> identifying the switch.
HTML
Copy to Clipboard
Play
<button role="switch" aria-checked="true" id="speakerPower" class="switch">
  <span>off</span>
  <span>on</span>
</button>
<label for="speakerPower" class="switch">Speaker power</label>

JavaScript

This JavaScript code defines and applies a function to handle click events on switch widgets. The function changes the aria-checked attribute from true to false, or vice versa.
JS
Copy to Clipboard
Play
document.querySelectorAll(".switch").forEach((theSwitch) => {
  theSwitch.addEventListener("click", handleClickEvent, false);
});

function handleClickEvent(evt) {
  const el = evt.target;

  if (el.getAttribute("aria-checked") === "true") {
    el.setAttribute("aria-checked", "false");
  } else {
    el.setAttribute("aria-checked", "true");
  }
}

CSS

The purpose of the CSS is to establish a look and feel for the switch that's reminiscent of the power switch paradigm.
CSS
Copy to Clipboard
Play
button.switch {
  margin: 0;
  padding: 0;
  width: 70px;
  height: 26px;
  border: 2px solid black;
  display: inline-block;
  margin-right: 0.25em;
  line-height: 20px;
  vertical-align: middle;
  text-align: center;
  font:
    12px "Open Sans",
    "Arial",
    serif;
}

button.switch span {
  padding: 0 4px;
  pointer-events: none;
}

[role="switch"][aria-checked="false"] :first-child,
[role="switch"][aria-checked="true"] :last-child {
  background: #262;
  color: #eef;
}

[role="switch"][aria-checked="false"] :last-child,
[role="switch"][aria-checked="true"] :first-child {
  color: #bbd;
}

label.switch {
  font:
    16px "Open Sans",
    "Arial",
    sans-serif;
  line-height: 20px;
  vertical-align: middle;
  user-select: none;
}


The most interesting part is probably the use of attribute selectors and the :first-child and :last-child pseudo-classes to do all the heavy lifting of changing the appearance of the switch based on whether it's on or off.
Result

The result looks like this:

Play


--------------------------------------------------

ARIA role/attribute name: ARIA: tab role

The ARIA tab role indicates an interactive element inside a tablist that, when activated, displays its associated tabpanel.

HTML
Copy to Clipboard
<button role="tab" aria-selected="true" aria-controls="tabpanel-id" id="tab-id">
  Tab label
</button>

Description

An element with the tab role controls the visibility of an associated element with the tabpanel role. The common user experience pattern is a group of visual tabs above, or to the side of, a content area, and selecting a different tab changes the content and makes the selected tab more prominent than the other tabs.
Elements with the role tab must either be a child of an element with the tablist role, or have their id as part of the aria-owns property of a tablist. This combination identifies to assistive technology that the element is part of a group of related elements. Some assistive technology will provide a count of the number of tab role elements inside a tablist, and inform users of which tab they currently have targeted. Further, an element with the tab role should contain the aria-controls property identifying a corresponding tabpanel (that has a tabpanel role) by that element's id. When an element with the tabpanel role has focus, or a child of it has focus, that indicates that the connected element with the tab role is the active tab in a tablist.
When elements with the tab role are selected or active they should have their aria-selected attribute set to true. Otherwise, their aria-selected attribute should be set to false. When a single-selectable tablist is selected or active, the hidden attribute of the other tabpanels should be set to true until the user selects the tab associated with that tabpanel. When a multi-selectable tablist is selected or active, its corresponding controlled tabpanel should have its aria-expanded attribute set to true and its hidden attribute set to false, otherwise the reverse.
All descendants are presentational

There are some types of user interface components that, when represented in a platform accessibility API, can only contain text. Accessibility APIs do not have a way of representing semantic elements contained in a tab. To deal with this limitation, browsers, automatically apply role presentation to all descendant elements of any tab element as it is a role that does not support semantic children.
For example, consider the following tab element, which contains a heading.
HTML
Copy to Clipboard
<div role="tab"><h3>Title of my tab</h3></div>


Because descendants of tab are presentational, the following code is equivalent:

HTML
Copy to Clipboard
<div role="tab"><h3 role="presentation">Title of my tab</h3></div>


From the assistive technology user's perspective, the heading does not exist since the previous code snippets are equivalent to the following in the accessibility tree:

HTML
Copy to Clipboard
<div role="tab">Title of my tab</div>

Associated roles and attributes
aria-selected

boolean

aria-controls

id of element with tabpanel role

id

content

Keyboard interactions
Key	Action
Tab	When focus is outside of the tablist moves focus to the active tab. If focus is on the active tab moves focus to the next element in the keyboard focus order, ideally the active tab's associated tabpanel.
→	Focuses and optionally activates the next tab in the tab list. If the current tab is the last tab in the tab list it activates the first tab.
←	Focuses and optionally activates the previous tab in the tab list. If the current tab is the first tab in the tab list it activates the last tab.
Delete	When allowed removes the currently selected tab from the tab list.
Required JavaScript features

Note: While there are ways to build tab-like functionality without JavaScript, there is no substitute combination using only HTML and CSS that will provide the same set of functionality that's required above for accessible tabs with content.
Example

This example combines the role tab with tablist and elements with tabpanel to create an interactive group of tabbed content. Here we are enclosing our group of content in a div, with our tablist having an aria-label which labels it for assistive technology. Each tab is a button with the attributes previously mentioned. The first tab has both tabindex="0" and aria-selected="true" applied. These two attributes must always be coordinated as such—so when another tab is selected, it will then have tabindex="0" and aria-selected="true" applied. All unselected tabs must have aria-selected="false" and tabindex="-1".
All of the tabpanel elements have tabindex="0" to make them tabbable, and all but the currently active one have the hidden attribute. The hidden attribute will be removed when a tabpanel becomes visible with JavaScript. There is some basic styling applied that restyles the buttons and changes the z-index of tab elements to give the illusion of it connecting to the tabpanel for active elements, and the illusion that inactive elements are behind the active tabpanel.
HTML
Copy to Clipboard
Play
<div class="tabs">
  <div role="tablist" aria-label="Sample Tabs">
    <button
      role="tab"
      aria-selected="true"
      aria-controls="panel-1"
      id="tab-1"
      tabindex="0">
      First Tab
    </button>
    <button
      role="tab"
      aria-selected="false"
      aria-controls="panel-2"
      id="tab-2"
      tabindex="-1">
      Second Tab
    </button>
    <button
      role="tab"
      aria-selected="false"
      aria-controls="panel-3"
      id="tab-3"
      tabindex="-1">
      Third Tab
    </button>
  </div>
  <div id="panel-1" role="tabpanel" tabindex="0" aria-labelledby="tab-1">
    <p>Content for the first panel</p>
  </div>
  <div id="panel-2" role="tabpanel" tabindex="0" aria-labelledby="tab-2" hidden>
    <p>Content for the second panel</p>
  </div>
  <div id="panel-3" role="tabpanel" tabindex="0" aria-labelledby="tab-3" hidden>
    <p>Content for the third panel</p>
  </div>
</div>


There are two things we need to do with JavaScript: we need to change focus and tab index of our tab elements with the right and left arrows, and we need to change the active tab and tabpanel when we click on a tab.
To accomplish the first, we listen for the keydown event on the tablist. If the event's key is ArrowRight or ArrowLeft, we react to the event. We start by setting the tabindex of the current tab element to -1, making it no longer tabbable. Then, if the right arrow is being pressed, we increase our tab focus counter by one. If the counter is greater than the number of tab elements we have, we circle back to the first tab by setting that counter to 0. If the left arrow is being pressed, we decrease our tab focus counter by one, and if it is then less than 0, we set it to the number of tab elements minus one (to get to the last element). Finally, we set focus to the tab element whose index is equal to the tab focus counter, and set its tabindex to 0 to make it tabbable.
To handle changing the active tab and tabpanel, we have a function that takes in the event, gets the element that triggered the event, the triggering element's parent element, and its grandparent element. We then find all tabs with aria-selected="true" inside the parent element and sets it to false, then sets the triggering element's aria-selected to true. After that, we find all tabpanel elements in the grandparent element, make them all hidden, and finally select the element whose id is equal to the triggering tab's aria-controls and removes the hidden attribute, making it visible.
JS
Copy to Clipboard
Play
window.addEventListener("DOMContentLoaded", () => {
  // Only handle one particular tablist; if you have multiple tab
  // lists (might even be nested), you have to apply this code for each one
  const tabList = document.querySelector('[role="tablist"]');
  const tabs = tabList.querySelectorAll(':scope > [role="tab"]');

  // Add a click event handler to each tab
  tabs.forEach((tab) => {
    tab.addEventListener("click", changeTabs);
  });

  // Enable arrow navigation between tabs in the tab list
  let tabFocus = 0;

  tabList.addEventListener("keydown", (e) => {
    // Move right
    if (e.key === "ArrowRight" || e.key === "ArrowLeft") {
      tabs[tabFocus].setAttribute("tabindex", -1);
      if (e.key === "ArrowRight") {
        tabFocus++;
        // If we're at the end, go to the start
        if (tabFocus >= tabs.length) {
          tabFocus = 0;
        }
        // Move left
      } else if (e.key === "ArrowLeft") {
        tabFocus--;
        // If we're at the start, move to the end
        if (tabFocus < 0) {
          tabFocus = tabs.length - 1;
        }
      }

      tabs[tabFocus].setAttribute("tabindex", 0);
      tabs[tabFocus].focus();
    }
  });
});

function changeTabs(e) {
  const targetTab = e.target;
  const tabList = targetTab.parentNode;
  const tabGroup = tabList.parentNode;

  // Remove all current selected tabs
  tabList
    .querySelectorAll(':scope > [aria-selected="true"]')
    .forEach((t) => t.setAttribute("aria-selected", false));

  // Set this tab as selected
  targetTab.setAttribute("aria-selected", true);

  // Hide all tab panels
  tabGroup
    .querySelectorAll(':scope > [role="tabpanel"]')
    .forEach((p) => p.setAttribute("hidden", true));

  // Show the selected panel
  tabGroup
    .querySelector(`#${targetTab.getAttribute("aria-controls")}`)
    .removeAttribute("hidden");
}

Play

Best practices

It is recommended to use a <button> element with the role tab for their built-in functional and accessible features instead, as opposed to needing to add them yourself. For controlling tab key functionality for elements with the role tab, it is recommended to set all non-active elements to tabindex="-1", and to set the active element to tabindex="0".
Precedence order

What are the related properties, and in what order will this attribute or property be read, which property will take precedence over this one, and which property will be overwritten.

--------------------------------------------------

ARIA role/attribute name: ARIA: table role

The table value of the ARIA role attribute identifies the element containing the role as having a non-interactive table structure containing data arranged in rows and columns, similar to the native <table> HTML element.

HTML
Copy to Clipboard
<div
  role="table"
  aria-label="Semantic Elements"
  aria-describedby="semantic_elements_table_desc"
  aria-rowcount="81">
  <div id="semantic_elements_table_desc">
    Semantic Elements to use instead of ARIA's roles
  </div>
  <div role="rowgroup">
    <div role="row">
      <span role="columnheader" aria-sort="none">ARIA Role</span>
      <span role="columnheader" aria-sort="none">Semantic Element</span>
    </div>
  </div>
  <div role="rowgroup">
    <div role="row" aria-rowindex="11">
      <span role="cell">header</span>
      <span role="cell">h1</span>
    </div>
    <div role="row" aria-rowindex="16">
      <span role="cell">header</span>
      <span role="cell">h6</span>
    </div>
    <div role="row" aria-rowindex="18">
      <span role="cell">rowgroup</span>
      <span role="cell">thead</span>
    </div>
    <div role="row" aria-rowindex="24">
      <span role="cell">term</span>
      <span role="cell">dt</span>
    </div>
  </div>
</div>

Description

An element with role="table" is a static tabular structure with rows containing cells. The cells are not focusable or selectable, though widgets within individual cells of the table can be interactive. Using a native HTML <table> element whenever possible is strongly encouraged.
Warning: If a table maintains a selection state, has two-dimensional navigation, or allows the user to rearrange cell order use grid or treegrid instead.
To create an ARIA table, add role="table" to the container element. Within that container, each row has role="row" set and contains child cells. Each cell has a role of either columnheader, rowheader, or cell. Rows can be children of the table or within a rowgroup.
The table caption can be defined via aria-labelledby or aria-label. All other semantic table elements, such as <tbody>, <thead>, <tr>, <th>, and <td>, need to be added via associated roles, such as rowgroup, row, columnheader, and cell.
If the table contains sortable columns or rows, the aria-sort attribute should be added on the header cell element (not the table itself). If any rows or columns are hidden, the aria-colcount or aria-rowcount should be included indicating the total number of columns or rows, respectively, along with the aria-colindex or aria-rowindex on each cell. The aria-colindex or aria-rowindex is set to the position of a cell within the row or column, respectively. If the table includes cells that span multiple rows or multiple columns, then aria-rowspan or aria-colspan should be included as well. Realize, it is much simpler to use the <table> element, along with all the related semantic elements and attributes that are all supported by all assistive technologies.
To create an interactive widget that has a tabular structure, use the grid pattern instead. If the interaction provides for the selection state of individual cells, if left to right and top to bottom navigation is provided, or if the user interface allows the rearranging of cell order or otherwise changing individual cell order such as through drag and drop, use grid or treegrid instead.
Note: Using a native HTML table element whenever possible is strongly encouraged.
Associated WAI-ARIA roles, states, and properties
role="rowgroup"

An optional child of the table, the row group encapsulates a group of rows, similar to <thead>, <tbody>, and <tfoot>.
role="row"

A row within the table, and optionally within a rowgroup that contains one or more cells, column headers, or row headers.
aria-describedby attribute

Takes as its value the id of the element that serves as a description for the table.
aria-label attribute

The aria-label provides an accessible name for the table.
aria-colcount attribute

This attribute is only required if the columns are not present in the DOM all the time. It provides an explicit indication of the number of columns in the full table. Set the value to the total number of columns in the full table. If unknown, set aria-colcount="-1".
aria-rowcount attribute

This attribute is only required if the rows are not present in the DOM all the time, such as scrollable tables that reuse rows to minimize the number of DOM nodes. It provides an explicit indication of the number of rows in the full table. Set the value to the total number of rows in the full table. If unknown, set aria-rowcount="-1".
Keyboard interactions

None

Required JavaScript features

None. For sortable columns, see the columnheader aria role.
Note: The first rule of ARIA use is if you can use a native feature with the semantics and behavior you require already built in, instead of re-purposing an element and adding an ARIA role, state or property to make it accessible, then do so. Employ the HTML <table> element instead of the ARIA role of table whenever possible.
Examples
HTML
Copy to Clipboard
<div
  role="table"
  aria-label="Semantic Elements"
  aria-describedby="semantic_elements_table_desc"
  aria-rowcount="81">
  <div id="semantic_elements_table_desc">
    Semantic Elements to use instead of ARIA's roles
  </div>
  <div role="rowgroup">
    <div role="row">
      <span role="columnheader" aria-sort="none">ARIA Role</span>
      <span role="columnheader" aria-sort="none">Semantic Element</span>
    </div>
  </div>
  <div role="rowgroup">
    <div role="row" aria-rowindex="11">
      <span role="cell">header</span>
      <span role="cell">h1</span>
    </div>
    <div role="row" aria-rowindex="16">
      <span role="cell">header</span>
      <span role="cell">h6</span>
    </div>
    <div role="row" aria-rowindex="18">
      <span role="cell">rowgroup</span>
      <span role="cell">thead</span>
    </div>
    <div role="row" aria-rowindex="24">
      <span role="cell">term</span>
      <span role="cell">dt</span>
    </div>
  </div>
</div>


The above is part of a table. While the full table has 81 entries, as indicated by the aria-rowcount property, only four are currently visible. The columns are sortable, but not currently sorted, as indicated by the aria-sort property on the column headers.
Best practices

Only use <table>, <tbody>, <thead>, <tr>, <th>, <td>, etc., for data table structure. You can add these ARIA roles to ensure accessibility should the native semantics of the table be removed, such as with CSS. A relevant use case for the ARIA table role is when CSS's display property overrides the native semantics of a table, such as by display: grid. In this case, you can use the ARIA table roles to re-add the semantics.
Added benefits

none


--------------------------------------------------

ARIA role/attribute name: ARIA: tablist role

The tablist role identifies the element that serves as the container for a set of tabs. The tab content are referred to as tabpanel elements.

Description

You may be interacting with a tabbed interface as you read this! Browser tabs allow a user have multiple web pages open in a single window. Clicking on a tab in the tablist at the top of the browser window enables the user to display the associated content in the main content area, the tabpanel, one site at a time. This is called a "tab design pattern".
When implementing a tab design pattern, the tab, tablist and tabpanel roles are used.
Tabs are a set of layered sections of content, known as tab panels, that display one panel of content at a time. Each tab panel has an associated tab element, that, when activated, displays the panel. The list of tab elements is arranged along one edge of the currently displayed panel, most commonly the top edge, nested in a tablist element.
Each tab in a tablist serves as a label for one tabpanel and can be activated to display that panel. The tablist is the containing element for the set of tab elements contained.
When a tabbed interface is initialized, one tab panel is displayed and its associated tab is styled to indicate that it is active. When the user activates one of the other tab elements, the previously displayed tab panel is hidden, the tab panel associated with the activated tab becomes visible, and the tab is considered "active".
For a single-selectable tablist, the non-active tabpanel elements should be hidden from the user until the user selects the tab associated with that tabpanel.
When creating a multi-selectable tablist, include aria-multiselectable="true" on the tablist element.
The tab elements not the tablist, have the aria-selected attribute. Set to aria-selected="true" for the tabs associated with each visible tabpanel. The tabs associated with hidden tabpanel elements have their aria-selected attributes set to false.
If the tab list has a visible label, set aria-labelledby to the id of the labelling element. If not, use aria-label to provide a label.
To be keyboard accessible, focus must be managed for the descendants of this role.
Elements with the tablist role have an implicit aria-orientation value of horizontal.
Associated WAI-ARIA roles, states, and properties
tab role

Required Owned Elements. Every tablist must have one or more tab children.
aria-multiselectable

When set to true, indicates the user may select more than one tab from the tablist descendants.
aria-orientation

If the tablist element is vertically oriented, set aria-orientation="vertical". The default is horizontal.
Keyboard interactions

For the tab list:

Tab

When focus moves into the tab list, places focus on the active tab element.
When the tab list contains the focus, moves focus to the next element in the page tab sequence outside the tablist, which is the tabpanel unless the first element containing meaningful content inside the tabpanel is focusable.
When focus is on a tab element in a horizontal tab list:

Left Arrow

moves focus to the previous tab. If focus is on the first tab, moves focus to the last tab. Optionally, activates the newly focused tab

Right Arrow

Moves focus to the next tab. If focus is on the last tab element, moves focus to the first tab. Optionally, activates the newly focused tab

When focus is on a tab element in a vertical tab list:

Up Arrow

moves focus to the previous tab. If focus is on the first tab, moves focus to the last tab. Optionally, activates the newly focused tab

Down Arrow

Moves focus to the next tab. If focus is on the last tab element, moves focus to the first tab. Optionally, activates the newly focused tab

If the tab list is horizontal, it does not listen for Down Arrow or Up Arrow so those keys can provide their normal browser scrolling functions even when focus is inside the tab list.
When focus is on a tab in a tablist with either horizontal or vertical orientation:

Space or Enter

Activates the tab if it was not activated automatically on focus.
Home (Optional)

Moves focus to the first tab. Optionally, activates the newly focused tab

End (Optional)

Moves focus to the last tab. Optionally, activates the newly focused tab

Shift + F10

If the tab has an associated popup menu, opens the menu.
Delete (Optional)

If deletion is allowed, deletes (closes) the current tab element and its associated tab panel, sets focus on the tab following the tab that was closed, and optionally activates the newly focused tab. If there is not a tab that followed the tab that was deleted, e.g., the deleted tab was the right-most tab in a left-to-right horizontal tab list, sets focus on and optionally activates the tab that preceded the deleted tab. If the application allows all tabs to be deleted, and the user deletes the last remaining tab in the tab list, the application moves focus to another element that provides a logical work flow. As an alternative to Delete, or in addition to supporting Delete, the delete function is available in a context menu.
Examples

See the tabpanel, tab, and tablist example in the tab role definition.

--------------------------------------------------

ARIA role/attribute name: ARIA: tabpanel role

The ARIA tabpanel is a container for the resources of layered content associated with a tab.

Description

The tabpanel role indicates the element is a container for the resources associated with a tab role, where each tab is contained in a tablist.
A tabpanel is part of a tab interface, a common user experience pattern in which a group of visual tabs allow for quickly switching between multiple layered views. Each tab is defined as such with the tab role, and these tabs are contained within an element with the tablist role. The tablist is often visually positioned above or to the side of a content area, containing the associated tabpanels. The tabpanel is the role of the container for each pane of content that is associated with a corresponding tab in the tab interface's tablist.
In many tab interfaces, only a single tabpanel will be visible at a time. However, some interfaces may require multiple tab panels to be displayed at once. In these cases the tablist would be provided the aria-multiselectable attribute, and the tab elements would then use the aria-expanded attribute to indicate whether its associated tabpanel was visible or not. The tab's selected state would instead be used to indicate which tabpanel is the currently 'active' panel. For example, this could indicate which tabpanel keyboard focus would move to if someone were to press the tab key when focused on an tab within the multi-select tablist.
In single-select tab interfaces, only the tabpanel associated with the currently selected tab is displayed. All other tabpanel elements associated with the unselected tabs must be hidden from users. So when tab selection changes, the displayed tabpanel would also, while the previously-displayed tabpanel would then become hidden.
In multi-select tab interfaces, multiple tabpanel elements may be displayed, matching the expanded state of their associated tab elements.
Tabs do not act as anchor links to individual panels — and upon activation, keyboard focus should remain on the current tab element and not automatically move to the newly displayed tabpanel. While a tab interface may be progressively enhanced based off an underlying markup pattern of in-page hyperlinks pointing to their associated sections of content, when JavaScript is used to modify these elements into a tabbed interface, the hyperlinks' default behavior should be prevented. Ideally, this could be done by removing or modifying the href attribute, as this would have the added benefit of removing the hyperlink-specific menu items from the element's browser context menu.
When keyboard focus is on a tablist, or a tab within the tablist, the Tab key should be programmed to move from the focused tab — which may or may not be the selected tab — to the tabpanel which represents the currently selected tab.
Each tab in a tablist can serve as the label for its corresponding tabpanel. Include the id of each tab as the value for each tabpanel's aria-labelledby attribute.
You can also optionally associate each tabpanel with its associated tab by including the id of the tabpanel as the value of the tab's aria-controls attribute.
When a tabbed interface is initialized, one tabpanel is displayed and its associated tab is styled to indicate that it is active, reflecting its programmatic state. All inactive tabpanel elements must be hidden to all users. This is most commonly achieved by use of CSS's display: none.
See the ARIA tab role article for more information specific to the use of this role.
Include tabindex="-1" to allow a tabpanel to receive focus without including the tabpanel in the page's keyboard focus order.
Make sure to define styles for a tabpanel for when it receives focus, optimally using the CSS :focus pseudo-class, so keyboard users know there was a change in focus and are aware of what content currently has focus.
Carousels can be created using this tab pattern: A slide picker controls can be marked up as tabs in a tablist with the slide represented by a tabpanel element.
Associated Roles and Attributes
tab role

Controls the visibility of the associated tabpanel

tablist role

Group of tab elements.
aria-labelledby

Provides an accessible name. References the tab element that controls the panel

aria-expanded

Should be used on the necessary tab elements if a multi-selectable tablist is used.
Keyboard interactions

See the tablist keyboard interactions in the tablist role definition.
Example

See the tabpanel, tab, and tablist example in the tab role definition.

--------------------------------------------------

ARIA role/attribute name: ARIA: term role

The term role can be used for a word or phrase with an optional corresponding definition.

Description

The term role can be used for a word or phrase with an optional corresponding definition. It is equivalent in semantics to the HTML <dfn> element and the definition term (<dt>) element within a definition list (<dl> ).
The term role is used to explicitly identify a word or phrase for which a definition has been provided by the author or is expected to be provided by the user. If there is an existing definition, or a form or form control to enter a definition, authors SHOULD set aria-details to point to the related element.
Don't use the role="term" on interactive elements like links because it can interfere with assistive technology users ability to interact with the element. Also, the term itself is the accessible name, so do not use aria-label or aria-labelledby.
Warning: The accessible name should be the term itself, so DO NOT use aria-label or aria-labelledby.
Associated WAI-ARIA roles, states, and properties

None.
Keyboard interactions

None.
Required JavaScript features

None.
Examples
HTML
Copy to Clipboard
<p>
  <span role="term">Mansplaining</span>,
  <span role="definition"
    >a portmanteau of "man" and "explain", is the patronizing act of explaining
    without being asked to do so, to someone already learned on the topic, often
    after someone has already explained it</span
  >.
</p>


Including better semantics, the above could also be written:

HTML
Copy to Clipboard
<p>
  <dfn role="term">Mansplaining</dfn>,
  <span role="definition"
    >a portmanteau of "man" and "explain", is the patronizing act of explaining
    without being asked to do so, to someone already learned on the topic, often
    after someone has already explained it</span
  >.
</p>


or without any ARIA (but possibly not how you want it presented)

HTML
Copy to Clipboard
<dl>
  <dt>Mansplaining</dt>
  <dd>
    A portmanteau of "man" and "explain", is the patronizing act of explaining
    without being asked to do so, to someone already learned on the topic, often
    after someone has already explained it.
  </dd>
</dl>

Accessibility concerns

Don't use the role="term" on interactive elements such as links as it can interfere with the assistive technology user's ability to interact with the element.
Best Practices

Allow the term itself to define the accessible name. Do not use aria-label or aria-labelledby.
Prefer HTML


--------------------------------------------------

ARIA role/attribute name: ARIA: textbox role

The textbox role is used to identify an element that allows the input of free-form text. Whenever possible, rather than using this role, use an <input> element with type="text", for single-line input, or a <textarea> element for multi-line input.

Description

When an element has the textbox role, the browser sends an accessible textbox event to assistive technologies, which can then notify the user about it.
The default is a single line input, in which Return or Enter submits the form; in this case, it is preferable to use an HTML <input> with type="text". To create a multi-line text box which supports line breaks, as in an HTML <textarea>, set aria-multiline="true". Including the HTML contenteditable attribute ensures the text node is editable.
HTML
Copy to Clipboard
<!-- Simple text input field -->
<div id="txtboxLabel">Enter your five-digit zip code</div>
<div
  role="textbox"
  contenteditable="true"
  aria-placeholder="5-digit zip code"
  aria-labelledby="txtboxLabel"></div>

<!-- Multi-line text area -->
<div id="txtboxMultilineLabel">Enter the tags for the article</div>
<div
  role="textbox"
  contenteditable="true"
  aria-multiline="true"
  aria-labelledby="txtboxMultilineLabel"
  aria-required="true"></div>


Semantic elements are more concise and require no JavaScript to support textbox features.
HTML
Copy to Clipboard
<label for="txtbox">Enter your five-digit zip code</label>
<input type="text" placeholder="5-digit zip code" id="txtbox" />

<!-- Multi-line text area -->
<label for="txtboxMultiline">Enter the tags for the article</label>
<textarea id="txtboxMultiline" required></textarea>


Where a text field is read-only, indicated this by setting aria-readonly="true" on the element.
Associated ARIA properties
aria-activedescendant attribute

Taking as it's value the ID of is either a descendant of the element with DOM focus or is a logical descendant as indicated by the aria-owns attribute, it indicates when that element has focus, when it is part of a composite widget such as a combobox. For example, in a combobox, focus may remain on the textbox while the value of aria-activedescendant on the textbox element refers to a descendant of a popup listbox that is controlled by the textbox. This attribute must be updated programmatically as the focus changes.
aria-autocomplete attribute

Indicates whether and how the user's input into the field could trigger display of a prediction of the intended value. It supports the following values:

inline: Predicted text is inserted after the caret.
list: Predicted text is presented as a collection of values.
both: Predicted text is presented as a collection of values, with the text needed to complete one value inserted after the caret.
none (default): Predicted text is not offered.
If list or both is set, the aria-controls and aria-haspopup attributes should also be included. The value of aria-controls is the ID of the element that contains the list of suggested values. Additionally, either the textbox or a containing element with role combobox has a value for aria-haspopup that matches the role of the element that contains the list of suggested values.
aria-multiline attribute

If aria-multiline="true" is set, the AT informs the user that the textbox supports multi-line input, with the expectation that Enter or Return will create a line break rather than submitting the form. ARIA does not alter the behavior of the element; rather this feature must be controlled by the developer. If false is set, or the attribute is omitted and defaults to false, the user expectation is that the control is a single line text box, and Enter or Return submits the form.
aria-placeholder attribute

Represents a hint (word or phrase) to the user about what to enter into the text field. The hint should be a sample value or a brief description of the expected format. This information should not be used as a substitute for a label: a label is focusable, permanent, indicates what kind of information is expected, and increases the hit area for setting focus on the control, whereas placeholder text is only temporary hint about the expected value, which if implemented incorrectly can decrease accessibility. The placeholder should be visible when the control's value is the empty string such as when the control first receives focus and when users remove a previously-entered value. Instead of using aria-placeholder, use the semantic <input type="text"> or <textarea> with a placeholder attribute.
aria-readonly attribute

Indicates that the user cannot modify the value of the text field. Instead of using aria-readonly, use the semantic <input type="text"> or <textarea> with a readonly attribute.
aria-required attribute

Indicates that a value must be provided for the field before it is submitted. Instead of using aria-required, use the semantic <input type="text"> or <textarea> with a required attribute.
Keyboard interactions

In a single-line use (when aria-multiline is false or not used), the Return or Enter key submits the form. In a multi-line use (when aria-multiline is true), Return or Enter key inserts a line break.
JavaScript features

All features associated with any and all properties and states must be maintained, and forms submission on enter or return on a single line textbox needs to be handled.
Focus event handler and aria-activedescendant attribute

If you are implementing a composite widget, such as a combobox composed of a text box and a listbox, you need to manage the aria-activedescendant attribute using a handler. Before using this technique, ensure that the browsers you need to target currently support it. See the specification of aria-descendant for further information.
Note: It is a better practice to use an <input> element with type="text", or a <textarea> element instead of the ARIA textbox role. When using either semantic element, the ARIA textbox role is not necessary. See Notes on Using ARIA in HTML.
Possible effects on user agents and assistive technology

When the textbox role is added to an element, or such an element becomes visible, the user agent should do the following:

Expose the element as having a textbox role in the operating system's accessibility API.
Fire an accessible textbox event using the operating system's accessibility API if it supports it.
Assistive technology products should listen for such an event and notify the user accordingly:

Screen readers should announce its label and role when focus first lands on a textbox. If it also contains content, this should be announced as with a regular textbox.
Screen magnifiers may enlarge the textbox.
Note: Opinions may differ on how assistive technology should handle this technique. The information provided above is one of those opinions and may be experienced differently.
Examples

Example 1: Adding the role in the HTML code for single line input

The snippet below shows how the textbox role is added directly into the HTML source code.
HTML
Copy to Clipboard
<div role="textbox" contenteditable="true"></div>

Example 2: Adding the role in the HTML code for multi-line input

The snippet below shows how the textbox role is added directly into the HTML source code.
HTML
Copy to Clipboard
<div role="textbox" contenteditable="true" aria-multiline="true"></div>

Best practices
Be sure to add the contenteditable="true" attribute to the HTML element to which this role is applied. Do so even if you set aria-readonly to true; in this way, you communicate that the content would be editable if it were not read-only.

--------------------------------------------------

ARIA role/attribute name: ARIA: timer role

The timer role indicates to assistive technologies that an element is a numerical counter listing the amount of elapsed time from a starting point or the remaining time until an end point. Assistive technologies will not announce updates to a timer as it has an implicit aria-live value of off.

HTML
Copy to Clipboard
<div role="timer" id="eggtimer">0</div>


This defines this div element as a timer with no remaining time.

Description

The timer role indicates to assistive technologies that this part of the web content is a live region containing a timer listing the time remaining or elapsed time. A timer's inner text should be an updating current time measurement. While the value does not necessarily need to be machine parsable, it should continuously update at regular intervals unless the timer is paused or reaches its end-point.
Along with alert, log, marquee, and status the timer role is a live region and can be modified by live region attributes.
Associated WAI-ARIA roles, states, and properties
aria-label or aria-labelledby

Some screen readers announce the name of a timer element before announcing its contents. If a name is visible, reference it using aria-labelledby. Including an aria-label provides a method for prefacing the visible content of a timer element with text that is not displayed when a screen reader reads the content. Naming a timer is not required so if nothing is appropriate both these attributes can be omitted.
aria-live

Elements with the role timer have an implicit aria-live value of off.
Accessibility concerns

If a time limit needs to be in place, for example, for security reasons, the user should have the option to turn it off or extend it. This restriction does not apply if the time limit is due to a live event, such as an auction or a game, or if the time to complete the form is essential for a valid submission.

--------------------------------------------------

ARIA role/attribute name: ARIA: toolbar role

The toolbar role defines the containing element as a collection of commonly used function buttons or controls represented in a compact visual form.

Description

A toolbar is a collection of commonly used controls, such as buttons or checkboxes, grouped together in a compact visual form. The toolbar role can be used to communicate the presence and purpose of such a grouping to screen reader users and can help reduce the number of tab stops for keyboard users. Only use the toolbar role to group 3 or more controls.
The toolbar is commonly a subset of functions found in a menubar as a way to reduce user effort. If you have more than one toolbar in a menubar, each toolbar requires a label; which you can include with aria-labelledby or aria-label.
When creating a toolbar, you need to implement focus management and keyboard interactions within the toolbar, handling when the same keyboard interactions is used both in the toolbar and in included native control. The Left Arrow and Right Arrow should be used to navigate between the controls within a horizontal tool bar. The Up Arrow and Down Arrow should be used if the toolbar is vertical — in which case you also want to include the aria-orientation="vertical" — or, in a horizontal toolbar, can be reserved for operating controls, such as spin buttons that require vertical arrow keys to operate.
Avoid including controls whose operation requires arrow keys used for toolbar navigation. If you must include such a control, make it the last control in the toolbar. For example, in a horizontal toolbar, a textbox could be included as the last element.
If any of the otherwise interactive elements within the toolbar are temporarily disabled, consider letting them remain focusable so screen reader users can be made aware of their presence.
Associated WAI-ARIA roles, states, and properties
aria-orientation

Elements with the role toolbar have an implicit aria-orientation value of horizontal.
aria-labelledby / aria-label

If the toolbar has a visible label, reference it by ID with the aria-labelledby attribute. Otherwise, provide an aria-label. If there is more than one toolbar in a menu, naming is required.
Keyboard interactions

Implement focus management so the keyboard tab sequence includes one stop for the toolbar and arrow keys move focus among the controls in the toolbar.
Tab and Shift + Tab

Move focus into and out of the toolbar. When focus moves into a toolbar:

If focus is moving into the toolbar for the first time, focus is set on the first control that is not disabled.
If the toolbar has previously contained focus, focus is optionally set on the control that last had focus. Otherwise, it is set on the first control that is not disabled.
Home (Optional)

Moves focus to first element.
End (Optional)

Moves focus to last element.
Horizontal toolbar

Elements with the role toolbar have an implicit aria-orientation value of horizontal. If the toolbar indeed has this orientation, the following keyboard interactions need to be implemented:

Left Arrow (For a horizontal toolbar (the default)

Moves focus to the previous control. Optionally, focus movement may wrap from the first element to the last element.
Right Arrow (For a horizontal toolbar (the default)

Moves focus to the next control. Optionally, focus movement may wrap from the last element to the first element.
In toolbars with multiple rows of controls, allow the left and right arrows to wraps from row to row, leaving the option of reserving vertical arrow keys for operating controls, such as navigating among radios buttons, or incrementing/decrementing a numeric spinner.
Vertical toolbar

If the toolbar is vertical, ensure aria-orientation="vertical" is set, and the following keyboard interactions are implemented:

Down Arrow (For a horizontal toolbar (the default)

Moves focus to the previous control. Optionally, focus movement may wrap from the first element to the last element.
Up Arrow (For a horizontal toolbar (the default)

Moves focus to the next control. Optionally, focus movement may wrap from the last element to the first element.
Required JavaScript features

Implement focus management so the keyboard tab sequence includes one stop for the toolbar and arrow keys move focus among the controls in the toolbar. When tabbing into the toolbar, focus returns to the control that last had focus.
While the toolbar element itself does not receive focus, focus on movement into, out of, and within the toolbar has to be managed. On load, the first element in the tabbing sequence within the toolbar has tabindex="0" with tabindex="-1" set on all other focusable elements within the toolbar. Depending on the [keyboard interaction], the element receiving focus gets set to tabindex="0" and the element that just lost focus gets switched back to tabindex="-1". Set focus, element.focus(), on the element that has tabindex="0". This is called "roving tabindex". A benefit of using roving tabindex to manage focus is that the browser will scroll the newly focused element into view.
If the design calls for a specific element to be focused the next time the user moves focus into the toolbar with Tab or Shift + Tab, check if that target element has tabindex="0" when toolbar loses focus.
When the toolbar has focus within it, provide visual cues. When an element within the toolbar has focus, a visual cue must be included on both the toolbar itself - to help the toolbar supports directional navigation with the arrow keys - and the control that has focus. The CSS pseudoclasses of :focus and :focus-within can be used to target both elements.
Examples

Toolbar example from W3C, the World Wide Web Consortium

Accessibility concerns

Avoid including controls whose operation requires arrow keys used for toolbar navigation (right and left arrows, or top and bottom for vertical toolbars). If you must include such a control, make it the last control in the toolbar. For example, in a horizontal toolbar, a textbox could be included as the last element.
If any of the otherwise interactive elements within the toolbar are disabled, consider letting them remain focusable so screen reader users can be made aware of their presence.

--------------------------------------------------

ARIA role/attribute name: ARIA: tooltip role

A tooltip is a contextual text bubble that displays a description for an element that appears on pointer hover or keyboard focus.

Description

Tooltips provide contextual information about an element when that owning element receives focus or is hovered over, but is otherwise not visible on the page. The tooltip is displayed automatically, after a brief delay; the user does not request it. While a tooltip can be placed on any content, they generally are tips for tools or controls, such as providing additional content for icons that have brief labels (or no labels at all, which is not accessible!).
A tooltip typically becomes visible, after a short delay of generally one to five seconds, in response to a mouse hover, or after the owning element receives keyboard focus. Just as it is opened automatically, without user request, it is closed automatically when the focus is lost or on mouse out. It must stay open when the mouse moves over the tooltip itself, and should also close when the user presses the Escape key.
Because the tooltip itself never receives focus and is not in the tabbing order, a tooltip can not contain interactive elements like links, inputs, or buttons.
The tooltip is not the appropriate role for the more information "i" icon, ⓘ. A tooltip is directly associated with the owning element. The ⓘ isn't 'described by' detailed information; the tool or control is.
The use of the ARIA tooltip role is a supplement to the normal browser tooltip behavior. An example of a native browser tooltip is the way some browsers display an element's title attribute on long mouse hover. One cannot activate this feature through either keyboard focus or through touch interaction, making this feature inaccessible. If the information is important enough to include as a tooltip or title, consider including it in visible text.
Elements with the tooltip role should be referenced through the use of aria-describedby before or when the tooltip is displayed. The aria-describedby attribute is on the owning element, not on the tooltip.
The tooltip is not considered a popup in terms of the aria-haspopup property on the owning element, which is why we used "text bubble" in the introductory definition.
Though a tooltip may appear and disappear, as its appearance is automatic and not intentionally controlled by the user, the aria-expanded role is not supported.
The accessible name of a tooltip can come from the contents. While, in theory, they could come from an aria-label or aria-labelledby, in most cases, using ARIA properties to provide a tooltip with an accessible name is not recommended.
Tooltips provide additional information, generally with no direct interaction on the tooltip itself. They are generally associated with the content they're defining via an aria-describedby with the id of the primary element. Therefore, if the tooltip has an accessible name explicitly set, that name is exposed as the primary element's description rather than the contents of the tooltip, meaning the tooltip contents may never be discovered by a screen reader user.
Associated WAI-ARIA roles, states, and properties
The element that serves as the tooltip container has role="tooltip" set.
The element that triggers the tooltip references the tooltip element with aria-describedby.
Keyboard interactions
Escape

Closes the tooltip

The tooltip should appear on focus or when the element is hovered on, without additional interaction. It should disappear automatically when the focus on the owning element is lost or the mouse is moved outside the owning element and the tooltip. While the tooltip does not receive focus, the Escape should close it if it is open.
Required JavaScript features

The tooltip is displayed and disappears via keyboard focus and removal of focus and by the mouse events - mousing over and mousing out.
The tooltip never receives focus. Focus stays on the owning element.
The tooltip can be hidden with the Escape key

The tooltip stays open when hovered

The tooltip is only hidden via JavaScript and CSS selectors. If JavaScript is not available the tooltip is shown.
Examples
HTML
Copy to Clipboard
<label for="password">Password:</label>
<input aria-describedby="passwordrules" id="password" type="password" />
<div role="tooltip" id="passwordrules">
  <p>Password Rules:</p>
  <ul>
    <li>Minimum of 8 characters</li>
    <li>
      Include at least one lowercase letter, one uppercase letter, one number
      and one special character
    </li>
    <li>Unique to this website</li>
  </ul>
</div>


The tooltip can be instantiated with CSS. Change the class name with JavaScript to a class that hides the tooltip if the user hits the Escape key.
CSS
Copy to Clipboard
[role="tooltip"],
.hide-tooltip.hide-tooltip.hide-tooltip + [role="tooltip"] {
  visibility: hidden;
  position: absolute;
  top: 2rem;
  left: 2rem;
  background: black;
  color: white;
}
[aria-describedby]:hover,
[aria-describedby]:focus {
  position: relative;
}
[aria-describedby]:hover + [role="tooltip"],
[aria-describedby]:focus + [role="tooltip"] {
  visibility: visible;
}


The above hides the tooltip with CSS in the default state or if the hide-tooltip class has been added with JavaScript (when the user hit Escape), with high specificity to ensure the tooltip doesn't show. When the owning element receives focus, it gets positioned relatively and the tooltip becomes visible.
Accessibility concerns

If the information is important enough for a tooltip, isn't it important enough to always be visible?

The tooltip must stay open when hovered, even if that technically means the mouse moves out of the owning element. As content which appears on hover can be difficult or impossible to perceive if a user is required to keep their mouse pointer over the trigger, WCAG 1.4.13 states that content made visible should be persistent, meaning it should not disappear without user action.
Best Practices

Instead of using tooltips and hiding important information, consider writing clear, succinct, always visible descriptions. If you have space, don't use tooltips or toggletips. Just provide clear labels and sufficient body text.

--------------------------------------------------

ARIA role/attribute name: ARIA: tree role

A tree is a widget that allows the user to select one or more items from a hierarchically organized collection.

Description

A tree widget is a hierarchical list with parent and child nodes that can expand and collapse. Any item in the hierarchy may have child tree items, set with role="treeitem". Tree items that have children can be expanded or collapsed, showing and hiding their children.
An example of a tree is a file system selection user interface: a tree view displaying folders and files. Folder items can be expanded to reveal the contents of the folder — which may be files, folders, or both — and collapsed, hiding its contents.
ARIA tree views are navigated primarily with arrow keys on the keyboard instead of the Tab. This form of navigation is not common for most browser content, though normal and expected for native applications. For this reason, before creating a tree view, consider alternative options to address the functionality you need.
Warning: Tree views use navigation more similar to native applications than to web applications. For this reason, consider alternative options to address the functionality you need before creating a tree view.
Single and multiple select trees

Trees can be "single-select", allowing users to choose just one item for an action, or "multi-select", where users are able to select more than one item for an action. In multi-select trees, the tree has aria-multiselectable set to true. Otherwise, aria-multiselectable is either set to false or the default value of false is implied. In both cases, to be keyboard accessible, focus must be managed for all tree descendants.
In some implementations of single-select tree, the focused item also has a selected state; this is known as "selection follows focus". When a single-select tree receives focus, if none of the tree items are selected before the tree receives focus, focus is set on the first node. If a tree item is selected before the tree receives focus, focus is set on the selected tree item. In single-select trees, aria-selected is set to true for the selected tree items and it is not present on any other tree item in the tree.
In multi-select trees, all selected tree items have aria-selected="true" set and all tree item nodes that are selectable but not currently selected have aria-selected="false" set. Do not includes the aria-selected attribute on tree items that are not selectable.
When a multi-select tree receives focus, if none of the tree items are selected before the tree receives focus, focus is set on the first tree item. If one or more tree items are selected before the tree receives focus, focus is set on the first selected node.
In multi-select trees, the selected state is always independent of the focus. For example, in a typical file system navigator, the user can move focus to select any number of files for an action, such as copy or move. The visual design should make it clear which items are selected and which item has focus.
Tree hierarchy

In a tree view, the tree node is the root node; it can have child, grandchild, and further descendant treeitem nodes.
Each element serving as a tree node has role treeitem, except for the root tree node which has a role of tree. A tree does not have a parent tree node - it is the root node. If a node is both nested in a tree and has descendant tree items, then it has the role treeitem and the aria-expanded attribute; aria-expanded="false" is set when the node is in a closed state, aria-expanded="true" is set when the node is in an open state.
treeitem nodes can be direct children of the tree root node, nested within a treeitem node, or, optionally nested in a group element, which, when nested in a tree is an expandable collection of treeitem elements.
Do not include aria-expanded on end nodes — those without tree item children — as that would incorrectly describe the node as a parent node to assistive technologies.
DOM placement and presence

All treeitems are contained in or owned by an element with role tree. If there are any tree items that are not direct descendants of the tree in the markup, include aria-owns on the owning tree container to include elements that are not DOM children of the container. These non-child owned elements will appear in the reading order in the sequence they are referenced and after any tree items that are DOM children. Scripts that manage focus need to ensure the visual focus order matches this assistive technology reading order.
If the complete set of available nodes is not present in the DOM due to dynamic loading as the user moves focus in or scrolls the tree, each node has aria-level, aria-setsize, and aria-posinset specified.
Accessible name

The tree must be provided with an accessible name. Either reference a visible label referenced with aria-labelledby or specify a label with aria-label.
Menu orientation

Elements with the role tree have an implicit aria-orientation value of vertical. If the tree element is horizontally oriented, include aria-orientation="horizontal".
Associated WAI-ARIA roles, states, and properties
role="treeitem"

An item in a tree.
role="group"

An expandable collection of tree items.
aria-labelledby

Identifies the element (or elements) that labels the tree providing the required accessible name when a visible label is present. Otherwise use aria-label.
aria-label

Defines a string value that labels the tree when no visible label is present.
aria-orientation

indicates whether the tree orientation is horizontal or vertical; defaults to vertical if omitted.
aria-multiselectable

When set to true, indicates the user may select more than one tree item from the tree's current selectable descendants.
Keyboard interactions

For a vertically oriented tree, which is the default orientation:

Right arrow	
When focus is on a closed node, opens the node; focus does not move.
When focus is on an open node, moves focus to the first child node.
When focus is on an end node (a tree item with no children), does nothing.
Left arrow	
When focus is on an open node, closes the node.
When focus is on a child node that is also either an end node or a closed node, moves focus to its parent node.
When focus is on a closed tree, does nothing.
Down Arrow	Moves focus to the next node that is focusable without opening or closing a node.
Up Arrow	Moves focus to the previous node that is focusable without opening or closing a node.
Home	Moves focus to the first node in the tree without opening or closing a node.
End	Moves focus to the last node in the tree that is focusable without opening the node.
Enter	Performs the default action of the currently focused node. For parent nodes, it opens or closes the node. In single-select trees, if the node has no children, selects the current node if not already selected (which is the default action).
Type a character*	
Focus moves to the next node with a name that starts with the typed character.
If multiple characters are typed in rapid succession, focus moves to the next node with a name that starts with the string of characters typed.
* (Optional)	Expands all siblings that are at the same level as the current node.
* Type-ahead is recommended for all trees, especially for trees with more than 7 root nodes

Multi-select keyboard interactions

There are two interaction models for multi-select trees: While you can require that users press a modifier key, such as Shift or Control while navigating the list in order to avoid losing selection states, the model that does not require the user to hold a modifier key is recommended.
Recommended multi user select model
Space	Toggles the selection state of the focused node.
Shift + Down Arrow (Optional)	Moves focus to and toggles the selection state of the next node.
Shift + Up Arrow (Optional)	Moves focus to and toggles the selection state of the previous node.
Shift + Space (Optional)	Selects contiguous nodes from the most recently selected node to the current node.
Control + Shift + Home (Optional)	Selects the node with focus and all nodes up to the first node. Optionally, moves focus to the first node.
Control + Shift + End (Optional)	Selects the node with focus and all nodes down to the last node. Optionally, moves focus to the last node.
Control + A (Optional)	Selects all nodes in the tree. Optionally, if all nodes are selected, it can also unselect all nodes.
Alternative multi-selection model

The alternative multi-selection model is a modifier key model in which moving focus without holding a modifier key such as Shift or Control unselects all selected nodes except for the focused node:

Shift + Down Arrow	Moves focus to and toggles the selection state of the next node.
Shift + Up Arrow	Moves focus to and toggles the selection state of the previous node.
Control + Down Arrow	Without changing the selection state, moves focus to the next node.
Control + Up Arrow	Without changing the selection state, moves focus to the previous node.
Control + Space	Toggles the selection state of the focused node.
Shift + Space (Optional)	Selects contiguous nodes from the most recently selected node to the current node.
Control + Shift + Home (Optional)	Selects the node with focus and all nodes up to the first node. Optionally, moves focus to the first node.
Control + Shift + End (Optional)	Selects the node with focus and all nodes down to the last node. Optionally, moves focus to the last node.
Control + A (Optional)	Selects all nodes in the tree. Optionally, if all nodes are selected, it can also unselect all nodes.

--------------------------------------------------

ARIA role/attribute name: ARIA: treegrid role

The treegrid role identifies an element as being grid whose rows can be expanded and collapsed in the same manner as for a tree.

Description

A treegrid is a hierarchical data grid, or table, consisting of tabular information that is editable or interactive. A treegrid is a combination of the tree and grid roles. Like a grid, the treegrid is made up of rows, columns, and gridcells. Like a tree, parent nodes in a treegrid are expandable and collapsible. The treegrid widget contains one or more row elements, optionally with rowgroup elements grouping the rows. Each row, in turn, contains one or more cells. Each cell is either a DOM descendant of or owned by a row element and is either a columnheader, rowheader, or gridcell element, with the gridcell role being used for all cells that do not contain column or row header information.
A row that can be expanded or collapsed to show or hide a set of child rows is a parent row. Each parent row has the aria-expanded state set on either the row element or on a cell contained in the row.
The aria-expanded state is set to true when the child rows are displayed and set to false when the child rows are hidden. Elements that do not control display of child rows should not have the aria-expanded attribute because the presence of the attribute indicates to assistive technologies that the element with the attribute is a parent.
When your grid UI calls for rows supporting aria-expanded or if your grid requires supporting aria-posinset, aria-setsize, or aria-level, use treegrid and not grid.
Each row or gridcell in a row should be keyboard focusable, and keyboard focus for all these tree grid descendants must be managed. The exception to this rule is column header cells which aren't required to be focusable if they do not provide functionality such as sort or filter. Every row and cell should either contain a focusable element or be focusable itself, regardless of whether individual cell content is editable or interactive.
Single and multi-select treegrids

If the treegrid allows the user to choose just one item for an action, then it is known as a single-select treegrid. In single-select treegrids, the item with focus also has a selected state set with aria-selected.
If the treegrid supports selection of more than one row or cell, it is a multi-select treegrid. In the multi-select treegrid, the selected state is independent of the focus. The visual design and assistive technologies must distinguish between items that are selected and the item that has focus.
For multi-select treegrids, include aria-multiselectable="true" on the element with the treegrid role. All selected rows or cells have aria-selected set to true. All rows and cells that are selectable but not currently selected have aria-selected set to false. Don't include the aria-selected attribute on rows and cells that are not individually selectable as the presence of the attribute indicates to assistive technologies that the row or cell is selectable.
Orphan rows

In cases where a child row or rowgroup is not nested within the treegrid in the DOM, the aria-owns attribute, referencing all of the IDs of the non-descendant children must be set on the treegrid element. If rows or cells are included in a treegrid via aria-owns, they will be presented to assistive technologies after the DOM descendants of the treegrid element unless the grid's actual DOM descendants are also included in the aria-owns attribute.
Treegrids with dynamically loaded content

If some rows or columns are not in the DOM and are dynamically loaded when scrolling, aria-colcount, aria-rowcount, aria-colindex and aria-rowindex come into play. The aria-colcount and aria-rowcount properties get set on the treegrid. The values being the total number of columns and rows of the fully loaded grid, respectively. The indexes for each row and column get set on individual cells, not on the treegrid element.
A treegrid's accessible name, description, and focus

The element with the role of treegrid must have an accessible name. If an appropriate label is visible in the content, provide the name via aria-labelledby. In other words, if there is an element in the user interface that serves as a label for the treegrid, include aria-labelledby as an attribute on the element with the role of treegrid, and set the value of the attribute to the id of the labelling element or elements. If no visible label is present, use aria-label instead. Not both.
If the content includes a caption or description for the treegrid, include aria-describedby on the treegrid element with the attribute value being the id of the element containing the description.
If the treegrid container itself receives focus, the value of its aria-activedescendant property should reference the id of the selected row, columnheader, rowheader or gridcell, unless roving tabindex is used to manage focus between those roles, in which case aria-activedescendant should not be used.
If the treegrid is disabled, make that disabled state visually apparent, programmatically enforced, and include the aria-disabled attribute on the treegrid itself to inform assistive technologies of its disabled state.
Treegrid sorting

If the treegrid provides sort functions, the aria-sort attribute is included on relevant header cell elements, not on the grid itself.
Treegrid menus

If the treegrid has an attached menu that opens when right clicked, include aria-haspopup="true" on the treegrid element. This informs assistive technologies that the treegrid has an associated popup. The ability for both keyboard and pointer device users to open and set focus in the menu must be added with JavaScript.
Read-only treegrids

By default, treegrids are assumed to be editable. If a tree grid is not editable, use the aria-readonly attribute to inform assistive technologies the treegrid is readonly. The attribute value, when set on the element with the treegrid role, propagates down to all columnheader, rowheader, and gridcell elements. That global value can be overridden for individual gridcell elements by including aria-readonly on individual tree grid element descendants.
Like all ARIA attributes, adding aria-readonly only informs assistive technologies that the content is or is not editable, but it does nothing to enable or disable interactivity. That must be done with HTML's global contenteditable attribute or with JavaScript.
Associated WAI-ARIA roles, states, and properties
row role

A row of cells within a tabular structure, optionally within a rowgroup. Contains one or more rows of grid cells, column headers, or row headers.
rowgroup role

A group of rows within a tabular structure.
gridcell role

Intended to mimic the functionality of the HTML <td> element, is found in grid and treegrid roles and must be the direct child of a row.
columnheader role

A cell in a row containing header information for a column, similar to the native <th> element with column scope

rowheader role

A cell containing header information for a row within a tabular structure.
aria-expanded

For expandable items, the value is true or false. Also indicates that the item is expandable, so should not be present if the item cannot be expanded.
aria-owns

Identifies a contextual relationship between a parent and its child elements when the DOM hierarchy cannot be used to represent the relationship

aria-labelledby

Use this attribute to label the treegrid. The aria-labelledby attribute is generally the id of the element used to title the treegrid.
aria-label

A human-readable string value which identifies the treegrid. If there's a visible label, then aria-labelledby should be used instead.
Keyboard interactions

Being able to move focus among rows and cells of the grid with a keyboard must be implemented in order to create an accessible treegrid. Moving focus into the grid may result in the first cell or the first row being focused. Whether focus goes to the next adjacent cell or the row depends on its content requirements, with some treegrids not providing focus to rows.
The following keyboard interactions need to be supported when an element in the grid has received focus, e.g., after a user has moved focus to the grid with Tab.
Enter

If cell-only focus is enabled and focus is on the first cell with the aria-expanded property, opens or closes the child rows. Otherwise, performs the default action for the cell.
Tab

If the row containing focus contains focusable elements such as an <input>, <button> or <a>, moves the focus to the next input in the row. If focus is on the last focusable element in the row, moves focus out of the treegrid widget to the next focusable element.
Right Arrow

If focus is on a collapsed row, expand the row. If focus is on an expanded row or is on a row that does not have child rows, moves focus to the first cell in the row. If focus is on the right-most cell in a row, focus does not move. If focus is on any other cell, moves focus one cell to the right.
Left Arrow

If focus is on an expanded row, collapses the row. If focus is on a collapsed row or on a row that does not have child rows, focus does not move. If focus is on the first cell in a row and row focus is supported, moves focus to the row. If focus is on the first cell in a row and row focus is not supported, focus does not move. If focus is on any other cell, moves focus one cell to the left.
Down Arrow

If focus is on a row, moves focus one row down. If focus is on the last row, focus does not move. If focus is on a cell, moves focus one cell down. If focus is on the bottom cell in the column, focus does not move.
Up Arrow

If focus is on a row, moves focus one row up. If focus is on the first row, focus does not move. If focus is on a cell, moves focus one cell up. If focus is on the top cell in the column, focus does not move.
Page Down

If focus is on a row or cell, moves focus down a predetermined number of rows or cells. Usually, it moves down the equivalent of the height of the treegrid, scrolling so the bottom row in the currently visible set of rows becomes one of the first visible rows. If focus is in the last row, focus does not move.
Page Up

If focus is on a row or cell, moves focus up an predetermined number of rows. Usually, it moves up the equivalent of the height of the treegrid, scrolling so the top row in the currently visible set of rows becomes one of the last visible rows. If focus is in the first row, focus does not move.
Home Control + Home

If focus is on a row, moves focus to the first row. If focus is in the first row, focus does not move. If focus is on a cell, moves focus to the first cell in the row. If focus is in the first cell of the row, focus does not move.
End Control + End

If focus is on a row, moves focus to the last row. If focus is in the last row, focus does not move. If focus is on a cell, moves focus to the last cell in the row. If focus is in the last cell of the row, focus does not move. If not all rows are present in the DOM, this can be used to focus on the last row present in the DOM, or on the last row available if the entire database were present in the DOM.
If a treegrid supports selection of cells, rows, or columns, the following keys are commonly used for these functions.
Control + Space

If focus is on a row, selects all cells. If focus is on a cell, selects the column that contains the focus.
Shift + Space

If focus is on a row, select the row. If focus is on a cell, select the row that contains the focus. If the treegrid includes a column with checkboxes for selecting rows, this key can also be used as a shortcut for checking the box when focus is not on the checkbox.
Control + A

Selects all cells.
Shift + Right Arrow

if focus is on a cell, extends selection one cell to the right.
Shift + Left Arrow

if focus is on a cell, extends selection one cell to the left.
Shift + Down Arrow

If focus is on a row, extends selection to all the cells in the next row. If focus is on a cell, extends selection one cell down.
Shift + Up Arrow

If focus is on a row, extends selection to all the cells in the previous row. If focus is on a cell, extends selection one cell up.
If navigation functions can dynamically add more rows or columns to the DOM, key events that move focus to the beginning or end of the grid, such as control + End, may move focus to the last row in the DOM rather than the last available row in the back-end data.
While navigation keys, such as arrow keys, are moving focus from cell to cell, they are not available to do something like operate a combobox or move an editing caret inside of a cell. If this functionality is needed, see Editing and Navigating Inside a Cell.
Accessibility concerns

It is important for all cells to be able to receive or contain keyboard focus because screen readers are generally in application reading mode, rather than their document reading mode, when users are interacting with the grid. While in application mode, a screen reader user hears only focusable elements and content that labels focusable elements. If content can't receive focus, screen reader users may unknowingly overlook elements contained in the treegrid.

--------------------------------------------------

ARIA role/attribute name: ARIA: treeitem role

A treeitem is an item in a tree.

Description

A tree is a hierarchical list with parent and child nodes that can expand and collapse. A treeitem is a node in a tree. The root of the tree is tree, but all tree nodes are treeitem elements, even if they themselves have nested treeitem nodes.
An example of a tree is a file system selection user interface: a tree view displaying folders and files. Each folder and file is a treeitem. Folder items, which are treeitem elements, can be expanded to reveal the contents of the folder—which may be files, folders, or both, and are all treeitems—and collapsed, hiding its contents.
In a tree hierarchy, the root node has the role tree. All other nodes, other than the root node, have the role of treeitem, whether or not they have children. A treeitem that is a parent is a parent node. A treeitem that is not a parent is an end node.
Tree items that have children can be expanded or collapsed, showing and hiding their children. A parent node that is expanded so its child nodes are visible is an open node. A parent node that is collapsed so the child nodes are not visible is a closed node.
Each parent node contains or owns an element with role group. A parent node is an expandable collection of treeitem elements. These child nodes are not direct descendants of the parent node: rather, they should be enclosed in an element with the group role.
Each parent node should include the aria-expanded attribute. It is set to false when closed true when open. End nodes should not have the aria-expanded attribute included as the presence of the attribute indicates to assistive technologies that the node is a parent.
Note: ARIA tree views use navigation more similar to native applications than to web applications and are navigated primarily with arrow keys on the keyboard instead of the Tab. This form of navigation is not common for most browser content, though normal and expected for native applications. For this reason, consider alternative options to address the functionality you need before creating a tree view.
Any element with a treeitem role must be nested in, or owned by, an element with role tree. Tree items can be a child of tree, treeitem, or an element with role group that is contained in, or owned by, an element with role tree or treeitem. If a treeitem is not nested within a tree, or nested in a group that is owned by a tree, include the id of the treeitem in the aria-owns attribute value on the owning tree, treeitem or group element.
Trees can be "single-select", allowing users to choose just one treeitem for an action, or "multi-select", where users are able to select more than one treeitem nodes for an action. In both cases, to be keyboard accessible, focus must be managed for all tree descendants.
In single-select trees, only one treeitem can have aria-selected (or aria-checked) set to true. When a single-select tree receives focus, if no treeitem is selected before the tree receives focus, focus is set on the first treeitem. If a treeitem is selected before the tree receives focus, focus is set on the single treeitem that has aria-selected="true" set.
All nodes that are selectable but not selected have either aria-selected or aria-checked set to false. If the tree contains nodes that are not selectable, do not include either aria-selected or aria-checked, as the presence of either attribute indicates to assistive technologies the node is selectable.
No more than one node can be selected at a time unless the tree node has aria-multiselectable="true" set.
When a multi-select tree receives focus, if none of the tree items are selected before the tree receives focus, focus is set on the first treeitem. If one or more tree items are selected before the tree receives focus, focus is set on the first selected treeitem.
In multi-select trees, all selected tree items have either aria-selected="true" (or aria-checked="true") set. All tree item nodes that are selectable but not currently selected should have aria-selected="false" (or aria-checked="false") set.
Either aria-selected or aria-checked can be used to indicate selection for treeitem elements. Some user interfaces indicate selection with aria-selected in single-select trees and with aria-checked in multi-select trees.
Using both aria-selected and aria-checked in the same tree is strongly discouraged. Don't use both aria-selected and aria-checked on treeitems in a single tree unless the meaning and purpose of aria-selected is different from the meaning and purpose of aria-checked, the meaning and purpose of each state apparent, and the user interface provides a separate method for controlling each state.
In multi-select trees, the selected state should be independent of the focus. For example, in a typical file system navigator, the user can move focus to select any number of files for an action, such as copy or move. The visual design should make it clear which items are selected and which item has focus.
If the complete set of available treeitems is not present in the DOM due to dynamic loading as the user moves focus in or scrolls the tree, each treeitem should have aria-level, aria-setsize, and aria-posinset specified.
A treeitem is required to have an accessible name. Generally, that name comes from the treeitem's contents. The accessible name can also be set via aria-label or aria-labelledby.
Associated WAI-ARIA roles, states, and properties
tree role

The root node for the hierarchical list of parent and child treeitem nodes that can expand and collapse

group role

Identifies a set of treeitem child nodes.
aria-expanded

Set on the root tree and on group nodes that are parents of treeitem nodes, to indicate whether the tree view is expanded (true) or collapsed (false).
aria-selected

Set to true or false, indicates a treeitem is selectable, and whether or not it is currently selected.
aria-checked

Set to true or false, indicates the treeitem can be checked, and whether or not it is currently checked.
Keyboard interactions

For a vertically oriented tree, which is the default orientation:

Right arrow	
When focus is on a closed node, opens the node; focus does not move.
When focus is on an open node, moves focus to the first child node.
When focus is on an end node (a tree item with no children), does nothing.
Left arrow	
When focus is on an open node, closes the node.
When focus is on a child node that is also either an end node or a closed node, moves focus to its parent node.
When focus is on a closed tree, does nothing.
Down Arrow	Moves focus to the next node that is focusable without opening or closing a node.
Up Arrow	Moves focus to the previous node that is focusable without opening or closing a node.
Home	Moves focus to the first node in the tree without opening or closing a node.
End	Moves focus to the last node in the tree that is focusable without opening the node.
Enter	Performs the default action of the currently focused node. For parent nodes, it opens or closes the node. In single-select trees, if the node has no children, selects the current node if not already selected (which is the default action).
Type a character*	
Focus moves to the next node with a name that starts with the typed character.
If multiple characters are typed in rapid succession, focus moves to the next node with a name that starts with the string of characters typed.
* (Optional)	Expands all siblings that are at the same level as the current node.
* Type-ahead is recommended for all trees, especially for trees with more than 7 root nodes

Multi-select keyboard interactions

There are two interaction models for multi-select trees: While you can require that users press a modifier key, such as Shift or Control while navigating the list in order to avoid losing selection states, the model that does not require the user to hold a modifier key is recommended.
Recommended multi user select model
Space	Toggles the selection state of the focused node.
Shift + Down Arrow (Optional)	Moves focus to and toggles the selection state of the next node.
Shift + Up Arrow (Optional)	Moves focus to and toggles the selection state of the previous node.
Shift + Space (Optional)	Selects contiguous nodes from the most recently selected node to the current node.
Control + Shift + Home (Optional)	Selects the node with focus and all nodes up to the first node. Optionally, moves focus to the first node.
Control + Shift + End (Optional)	Selects the node with focus and all nodes down to the last node. Optionally, moves focus to the last node.
Control + A (Optional)	Selects all nodes in the tree. Optionally, if all nodes are selected, it can also unselect all nodes.
Examples

The following is how one might mark up a directory listing of web development courses as a tree view:

HTML
Copy to Clipboard
<div>
  <h3 id="treeLabel">Developer Learning Path</h3>
  <ul role="tree" aria-labelledby="treeLabel">
    <li role="treeitem" aria-expanded="true">
      <span>Web</span>
      <ul role="group">
        <li role="treeitem" aria-expanded="false">
          <span>Languages</span>
          <ul role="group">
            <li role="treeitem" aria-expanded="false">
              <span>HTML</span>
              <ul role="group">
                <li role="treeitem">Document structure</li>
                <li role="treeitem">Head elements</li>
                <li role="treeitem">Semantic elements</li>
                <li role="treeitem">Attributes</li>
                <li role="treeitem">Web forms</li>
              </ul>
            </li>
            <li role="treeitem">CSS</li>
            <li role="treeitem">JavaScript</li>
          </ul>
        </li>
        <li role="treeitem" aria-expanded="false">
          <span>Accessibility</span>
          <ul role="group">
            <li role="treeitem" aria-label="accessibility object model">AOM</li>
            <li role="treeitem">WCAG</li>
            <li role="treeitem">ARIA</li>
          </ul>
        </li>
        <li role="treeitem" aria-expanded="false">
          <span>Web Performance</span>
          <ul role="group">
            <li role="treeitem">Load time</li>
          </ul>
        </li>
        <li role="treeitem">APIs</li>
      </ul>
    </li>
  </ul>
</div>


The above provides the semantics for a tree view, but does not provide any of the interactivity. That must be added in with JavaScript.
If the tree items aren't by default focusable, JavaScript can be used tabIndex="-1" to all the treeitems except the one that should receive focus when the user tabs into the tree which should be set to tabIndex="0".
All the keyboard functionality in Keyboard interactions and all pointer events need to be programmed, including focus management, going up and down the tree, expanding and collapsing parent nodes, and selection management.
If the tree has more than 7 tree items, including type ahead functionality is recommended.

--------------------------------------------------

ARIA role/attribute name: ARIA: widget role

The widget role, an abstract role, is an interactive component of a graphical user interface (GUI).

Note: The widget role is an abstract role used for the ontology. It is included here for completeness of documentation. It should not be used by web authors.

Description

The abstract widget role is a superclass role for some interactive GUI elements and grouping roles. role="widget" should not be confused with widgets roles, such as option, menuitem, and searchbox.
The widget role is a superclass role several abstract interactive GUI roles, including command, composite, input, range, and separator (if focusable), which should not be used by web authors.
The abstract widget role is also a superclass role for some grouping roles which can be used by web authors, including gridcell, row, separator (when not focusable), and tab, which can and should be used when appropriate. When the user navigates to one of these non-abstract roles of widget, keyboard events can switch to an application browsing mode, and pass keyboard events through to the browser.
Best Practices

Do not use.

--------------------------------------------------

ARIA role/attribute name: ARIA: window role

The window role defines a browser or app window.

Note: The window role is an abstract role. It is included here for completeness of documentation. It should not be used by web authors.

Description

The window role, an abstract role, is a superclass for roles defining a browser or app window. The sub-class roles, currently only the dialog role, have a window-like GUI, or graphical user interface, whether it's a full native window or just a section of a document styled to look like a window, where role="dialog" would be appropriate.
Best Practices

Do not use.

--------------------------------------------------

